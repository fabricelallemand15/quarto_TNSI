---
title: "Ch. 5 - Arbres : Cours - Partie 2 - Implémentation des Arbres Binaires en Python"
---

## 1. Choix de l'implémentation

Pour implémenter un arbre binaire en Python, la méthode la plus standard et la plus "propre" scientifiquement consiste à définir une classe pour les **Nœuds**.

Un **Arbre Binaire** est alors simplement :

*   Soit `None` (l'arbre vide).
*   Soit une instance de la classe `Noeud` (la racine), qui pointe vers deux autres arbres binaires (ses fils).

Cette approche distingue bien la structure récursive et évite de créer des objets "vides" inutiles.

## 2. La classe `Noeud`

Voici une implémentation moderne et documentée.

```python
class Noeud:
    def __init__(self, etiquette, gauche=None, droit=None):
        """
        Crée un nouveau noeud.
        :param etiquette: La valeur stockée dans le noeud.
        :param gauche: Le sous-arbre gauche (instance de Noeud ou None).
        :param droit: Le sous-arbre droit (instance de Noeud ou None).
        """
        self.etiquette = etiquette
        self.gauche = gauche
        self.droit = droit

    def est_feuille(self) -> bool:
        """Renvoie True si le noeud est une feuille."""
        return self.gauche is None and self.droit is None

    def __repr__(self):
        """Représentation textuelle pour le débogage."""
        return f"Noeud({self.etiquette})"
```

### Construction d'un arbre

Pour construire l'arbre suivant :

```{mermaid}
graph TD
    A((A)) --- B((B))
    A --- C((C))
    B --- D((D))
    B --- E((E))
```

```python
# Construction de bas en haut (Bottom-Up)
d = Noeud("D")
e = Noeud("E")
b = Noeud("B", d, e)
c = Noeud("C")
a = Noeud("A", b, c)

# L'arbre est représenté par sa racine 'a'
mon_arbre = a
```

## 3. Fonctions de base sur les arbres

Puisque l'arbre vide est représenté par `None`, nous ne pouvons pas utiliser de méthodes d'instance (comme `arbre.taille()`) directement sur un arbre qui pourrait être vide. Nous définissons donc des **fonctions** qui prennent l'arbre en paramètre.

### 3.1. Taille et Hauteur

```python
def taille(arbre) -> int:
    """
    Calcule la taille de l'arbre (nombre total de noeuds).
    """
    if arbre is None:
        return 0
    else:
        return 1 + taille(arbre.gauche) + taille(arbre.droit)

def hauteur(arbre) -> int:
    """
    Calcule la hauteur de l'arbre.
    Convention : Hauteur(vide) = 0, Hauteur(feuille) = 1.
    """
    if arbre is None:
        return 0
    else:
        return 1 + max(hauteur(arbre.gauche), hauteur(arbre.droit))
```

### 3.2. Visualisation (Bonus)

Pour visualiser l'arbre, nous pouvons utiliser une fonction récursive qui affiche l'arbre dans la console (tourné à 90°).

```python
def affiche(arbre, niveau=0, prefixe="Racine: "):
    """Affiche l'arbre dans la console de manière textuelle."""
    if arbre is None:
        return
    
    # On affiche d'abord le sous-arbre droit (pour qu'il soit en haut)
    affiche(arbre.droit, niveau + 1, " /-- ")
    
    # On affiche le noeud courant
    print("    " * niveau + prefixe + str(self.etiquette))
    
    # On affiche le sous-arbre gauche
    affiche(arbre.gauche, niveau + 1, " \\-- ")
```

## 4. Arbres Binaires de Recherche (ABR)

Pour les ABR, nous pouvons créer une classe spécifique ou simplement utiliser des fonctions d'insertion. Voici une approche fonctionnelle pure (sans modification en place) et une approche avec modification.

### Insertion (Version récursive)

```python
def insere_abr(arbre, valeur):
    """
    Insère une valeur dans un ABR et renvoie la nouvelle racine.
    Si l'arbre est vide, crée un nouveau noeud.
    """
    if arbre is None:
        return Noeud(valeur)
    
    if valeur < arbre.etiquette:
        arbre.gauche = insere_abr(arbre.gauche, valeur)
    elif valeur > arbre.etiquette:
        arbre.droit = insere_abr(arbre.droit, valeur)
    # Si valeur == arbre.etiquette, on ne fait rien (pas de doublons)
    
    return arbre
```

Exemple d'utilisation :
```python
abr = None
abr = insere_abr(abr, 10)
abr = insere_abr(abr, 5)
abr = insere_abr(abr, 15)
abr = insere_abr(abr, 2)
```

### Recherche

```python
def appartient_abr(arbre, valeur) -> bool:
    """Renvoie True si la valeur est dans l'ABR."""
    if arbre is None:
        return False
    
    if valeur == arbre.etiquette:
        return True
    elif valeur < arbre.etiquette:
        return appartient_abr(arbre.gauche, valeur)
    else:
        return appartient_abr(arbre.droit, valeur)
```
