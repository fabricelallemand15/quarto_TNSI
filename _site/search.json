[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "arbresgraphes/arbres_cours.html",
    "href": "arbresgraphes/arbres_cours.html",
    "title": "Arbres (Cours)",
    "section": "",
    "text": "Définition\n\n\n\nEn informatique, un arbre est une structure de données qui peut se représenter sous forme d’une hiérarchie dont chaque élément est appelé nœud, le nœud initial étant appelé racine.\n\n\n\n\n\n\n\n\n\n\n\n\n\nVocabulaire\n\n\n\n\nChaque nœud a exactement un nœud père, sauf le nœud racine (situé en haut) qui n’a pas de père.\nUn nœud peut avoir une nombre quelconque de fils.\nLes nœuds qui n’ont pas de fils sont appelés des feuilles (situées aux extrémités des branches !).\nLes nœuds possèdent une valeur, ou clef, ou encore étiquette.\n\n\n\nPar exemple, dans l’arbre représenté ci-dessus :\n\n\n\n\n\n\nExemple\n\n\n\n\nLa racine possède l’étiquette D.\nLe nœud père D a trois fils U, L et A.\nLe nœud V a pour père le nœud A.\nLes nœuds C, L et X sont des feuilles.\n\n\n\n\n\n\n\nVoici quelques exemples de situations dans lesquelles une structure de données arborescente est utile.\n\n\nDéjà rencontrée dans le chapitre sur les systèmes d’exploitation en première, une arborescence de dossiers dans un disque dur peut être modélisée par un arbre.\n\n\n\n\n\n\n\n\nLE DOM (Document Object Model) est une interface de programmation pour les pages web dans laquelle une page HTML est modélisée sous la forme d’un arbre.\nPar exemple, le code HTML ci-dessous sera modélisé par l’arbre en-dessous (source : w3.org).\n&lt;TABLE&gt;\n    &lt;ROWS&gt; \n      &lt;TR&gt; \n        &lt;TD&gt;Shady Grove&lt;/TD&gt;\n        &lt;TD&gt;Aeolian&lt;/TD&gt; \n      &lt;/TR&gt; \n      &lt;TR&gt;\n        &lt;TD&gt;Over the River, Charlie&lt;/TD&gt;\n        &lt;TD&gt;Dorian&lt;/TD&gt; \n      &lt;/TR&gt; \n    &lt;/ROWS&gt;\n&lt;/TABLE&gt;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDifférents paramètres numériques peuvent être définis concernant un arbre.\n\n\n\n\n\n\nDéfinitions\n\n\n\n\nLa taille d’un arbre est son nombre total de nœuds.\nLa profondeur d’un nœud est le nombre de nœuds de la branche allant de la racine à ce nœud, en comptant les extrémités.\nLa hauteur d’un arbre est la profondeur de son nœud le plus profond. Par convention, si l’arbre est vide, sa hauteur vaut 0, si l’arbre n’est composé que d’un nœud racine, sa hauteur vaut 1.\n\n\n\n\n\n\n\n\n\nExemple\n\n\n\nConsidérons l’arbre ci-dessous :\n\n\n\n\n\n\nLa taille de cet arbre est égale à 7.\nLa profondeur du nœud C est égale à 3, celle de X est égale à 4.\nLa hauteur de cet arbre est égale à 4 : X est le nœud le plus profond."
  },
  {
    "objectID": "arbresgraphes/arbres_cours.html#introduction",
    "href": "arbresgraphes/arbres_cours.html#introduction",
    "title": "Arbres (Cours)",
    "section": "",
    "text": "Définition\n\n\n\nEn informatique, un arbre est une structure de données qui peut se représenter sous forme d’une hiérarchie dont chaque élément est appelé nœud, le nœud initial étant appelé racine.\n\n\n\n\n\n\n\n\n\n\n\n\n\nVocabulaire\n\n\n\n\nChaque nœud a exactement un nœud père, sauf le nœud racine (situé en haut) qui n’a pas de père.\nUn nœud peut avoir une nombre quelconque de fils.\nLes nœuds qui n’ont pas de fils sont appelés des feuilles (situées aux extrémités des branches !).\nLes nœuds possèdent une valeur, ou clef, ou encore étiquette.\n\n\n\nPar exemple, dans l’arbre représenté ci-dessus :\n\n\n\n\n\n\nExemple\n\n\n\n\nLa racine possède l’étiquette D.\nLe nœud père D a trois fils U, L et A.\nLe nœud V a pour père le nœud A.\nLes nœuds C, L et X sont des feuilles.\n\n\n\n\n\n\n\nVoici quelques exemples de situations dans lesquelles une structure de données arborescente est utile.\n\n\nDéjà rencontrée dans le chapitre sur les systèmes d’exploitation en première, une arborescence de dossiers dans un disque dur peut être modélisée par un arbre.\n\n\n\n\n\n\n\n\nLE DOM (Document Object Model) est une interface de programmation pour les pages web dans laquelle une page HTML est modélisée sous la forme d’un arbre.\nPar exemple, le code HTML ci-dessous sera modélisé par l’arbre en-dessous (source : w3.org).\n&lt;TABLE&gt;\n    &lt;ROWS&gt; \n      &lt;TR&gt; \n        &lt;TD&gt;Shady Grove&lt;/TD&gt;\n        &lt;TD&gt;Aeolian&lt;/TD&gt; \n      &lt;/TR&gt; \n      &lt;TR&gt;\n        &lt;TD&gt;Over the River, Charlie&lt;/TD&gt;\n        &lt;TD&gt;Dorian&lt;/TD&gt; \n      &lt;/TR&gt; \n    &lt;/ROWS&gt;\n&lt;/TABLE&gt;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDifférents paramètres numériques peuvent être définis concernant un arbre.\n\n\n\n\n\n\nDéfinitions\n\n\n\n\nLa taille d’un arbre est son nombre total de nœuds.\nLa profondeur d’un nœud est le nombre de nœuds de la branche allant de la racine à ce nœud, en comptant les extrémités.\nLa hauteur d’un arbre est la profondeur de son nœud le plus profond. Par convention, si l’arbre est vide, sa hauteur vaut 0, si l’arbre n’est composé que d’un nœud racine, sa hauteur vaut 1.\n\n\n\n\n\n\n\n\n\nExemple\n\n\n\nConsidérons l’arbre ci-dessous :\n\n\n\n\n\n\nLa taille de cet arbre est égale à 7.\nLa profondeur du nœud C est égale à 3, celle de X est égale à 4.\nLa hauteur de cet arbre est égale à 4 : X est le nœud le plus profond."
  },
  {
    "objectID": "arbresgraphes/arbres_cours.html#arbres-binaires",
    "href": "arbresgraphes/arbres_cours.html#arbres-binaires",
    "title": "Arbres (Cours)",
    "section": "2. Arbres binaires",
    "text": "2. Arbres binaires\n\n2.1. Définition\n\n\n\n\n\n\nDéfinition\n\n\n\nUn arbre binaire est un arbre dans lequel chaque nœud possède au plus deux fils au niveau inférieur, appelés gauche et droite.\n\n\nL’arbre donné en exemple ci-dessus n’est pas un arbre binaire car le nœud D possède 3 fils.\nL’arbre ci-dessous est un arbre binaire :\n\n\n\n\n\n\n\n2.2. Sous-arbres\nChaque nœud n’ayant que deux fils (au maximum), nous pouvons définir un sous-arbre gauche et un sous-arbre droit qui sont tous les deux également des arbres binaires (éventuellement vides).\n\n\n\n\n\n\n\n\n\n\n\nExemple\n\n\n\nPour l’arbre représenté ci-dessous, nous avons mis en évidence le sous-arbre gauche et le sous-arbre droit du nœud racine C.\nLe nœud Q admet comme sous-arbre gauche le nœud H et comme sous-arbre droit, l’arbre vide.\n\n\nCette notion de sous arbre permet de mettre en évidence la structure récursive d’un arbre binaire : un arbre binaire est un arbre dans lequel chaque nœud possède un arbre fils gauche et un arbre fils droit qui sont tous deux des arbres binaires.\n\n\n2.3. Hauteur d’un arbre binaire\nNous avons défini plus haut les notions de taille et de hauteur d’un arbre.\nNotons ici \\(n\\) la taille d’un arbre binaire et \\(h\\) sa hauteur. Ces deux entiers ne sont pas indépendants l’un de l’autre.\nUn cas extrême est le cas de l’arbre filiforme dans lequel chaque nœud n’a qu’un fils. La figure ci-dessous est réalisée avec \\(n=7\\).\n\n\n\n\n\nDans ce cas, nous avons \\(n=h\\) : la hauteur de l’arbre est égale au nombre de nœuds de l’arbre.\nUn autre cas “extrême” est le cas d’un arbre complet : il s’agit d’un arbre binaire dans lequel tous les nœuds (sauf les feuilles) ont exactement deux fils et toutes les feuilles ont la même profondeur. La figure ci-dessous représente un arbre complet à 7 nœuds.\n\n\n\n\n\nDans un tel arbre, le nombre de nœuds est doublé à chaque niveau. Si la hauteur est \\(h\\), le nombre total de nœuds est donc égal à :\n\\[n=1+2^1+2^2+2^3+\\ldots+2^{h-1}\\]\n(on numérote les niveaux de \\(0\\) à \\(h-1\\))\nOn obtient donc le résultat suivant :\n\n\n\n\n\n\nLien entre hauteur et taille d’un arbre binaire complet\n\n\n\nSoit un arbre binaire complet de taille \\(n\\) et de hauteur \\(h\\).\nOn a alors :\n\\[n=2^h-1\\]\n\n\n\n\n\n\n\n\nPreuve\n\n\n\n\n\nNous avons vu que \\(n=1+2^1+2^2+2^3+\\ldots+2^{h-1}\\). Cette somme est la somme des premiers termes d’une suite géométrique de raison 2.\nOn peut donc utiliser la formule de calcul vue en première en Mathématiques :\n\\[1+2^1+2^2+2^3+\\ldots+2^{h-1} = \\frac{2^h-1}{2-1}=2^h-1\\]\nPour ceux qui n’auraient jamais vu cette formule, sa preuve n’est pas difficile : il suffit de calculer le produit \\((2-1)(1+2^1+2^2+2^3+\\ldots+2^{h-1})\\) en développant :\n\\[(2-1)(1+2^1+2^2+2^3+\\ldots+2^{h-1})= 2^1+2^2+2^3+\\ldots+2^{h} -1-2^1-2^2-2^3-\\ldots-2^{h-1}\\]\nTous les termes s’annulent sauf \\(2^{h}\\) et \\(-1\\), d’où le résultat.\n\n\n\nTout arbre étant situé entre ces deux cas extrêmes, nous pouvons écrire un encadrement du nombre de nœuds \\(n\\) en fonction de la hauteur \\(h\\), valable pour tout arbre binaire :\n\\[h\\leqslant n\\leqslant 2^h-1\\]\nÀ partir de cet encadrement de \\(n\\), on peut déduire un encadrement de \\(h\\). Nous avons déjà de façon évidente \\(h\\leqslant n\\). La seconde inégalité \\(n\\leqslant 2^h-1\\) est équivalente à \\(n+1\\leqslant 2^h\\).\nPour isoler \\(h\\) dans cette inégalité, nous avons besoin de la fonction logarithme binaire. Le logarithme binaire d’un entier positif est son exposant quand on l’écrit sous la forme d’une puissance de 2. Par exemple \\(\\log_2(8)=3\\) car \\(2^3=8\\) et \\(\\log_2(2^h)=h\\). Cette fonction \\(\\log_2\\) étant intuitivement croissante, nous obtenons, en l’appliquant à l’inégalité \\(n+1\\leqslant 2^h\\) : \\(\\log_2(n+1)\\leqslant h\\).\nNous avons finalement l’encadrement suivant :\n\n\n\n\n\n\nEncadrement de la hauteur d’un arbre binaire\n\n\n\nSoit un arbre binaire de taille \\(n\\) et de hauteur \\(h\\).\nOn a alors :\n\\[\\log_2(n+1)\\leqslant h\\leqslant n\\]\n\n\nCet encadrement nous sera utile lors du calcul du coût d’exécution des algorithmes sur les arbres."
  },
  {
    "objectID": "arbresgraphes/arbres_cours.html#arbres-binaires-de-recherche",
    "href": "arbresgraphes/arbres_cours.html#arbres-binaires-de-recherche",
    "title": "Arbres (Cours)",
    "section": "3. Arbres binaires de recherche",
    "text": "3. Arbres binaires de recherche\n\n\n\n\n\n\nDéfinition\n\n\n\nUn arbre binaire de recherche (ABR) est un arbre binaire dont les clefs des nœuds (leur valeur) vérifient les propriétés suivantes :\n\nla clef d’un nœud est supérieure à celle de chaque nœud de son sous-arbre gauche.\nla clef d’un nœud est inférieure à celle du chaque nœud de son sous-arbre droit.\n\n\n\nCette définition n’a de sens que dans le cas où les clefs des nœuds sont toujours comparables entre elles. Dans la pratique, nous travaillerons toujours avec des clefs numériques ou alphanumériques (ordre alphabétique).\nNous supposerons toujours que toutes les clefs sont différentes.\n\n\n\n\n\n\n\n\n\n\n\nRemarque\n\n\n\nDans un ABR, pour un nœud donné, tous les nœuds de son sous-arbre gauche ont des clefs inférieures et tous les nœuds de son sous-arbre droit ont des clefs supérieures."
  },
  {
    "objectID": "arbresgraphes/arbres_exercices.html",
    "href": "arbresgraphes/arbres_exercices.html",
    "title": "Exercices sur les arbres",
    "section": "",
    "text": "Les exercices précédés du symbole  sont à faire sur machine, en sauvegardant le fichier si nécessaire.\nLes exercices précédés du symbole  doivent être résolus par écrit."
  },
  {
    "objectID": "arbresgraphes/arbres_exercices.html#fa-solid-pencil-alt-exercice-1",
    "href": "arbresgraphes/arbres_exercices.html#fa-solid-pencil-alt-exercice-1",
    "title": "Exercices sur les arbres",
    "section": " Exercice 1",
    "text": "Exercice 1\nOn considère l’arbre binaire ci-dessous :\n\n\n\n\n\n\nDéterminer la profondeur du nœud 6.\nDéterminer la hauteur de cet arbre.\nExpliquer pourquoi cet arbre n’est pas un arbre binaire de recherche.\nModifier l’arbre (en conservant les mêmes clefs) pour en faire un ABR."
  },
  {
    "objectID": "arbresgraphes/arbres_exercices.html#fa-solid-pencil-alt-exercice-2",
    "href": "arbresgraphes/arbres_exercices.html#fa-solid-pencil-alt-exercice-2",
    "title": "Exercices sur les arbres",
    "section": " Exercice 2",
    "text": "Exercice 2\nOn considère l’arbre binaire ci-dessous :\n\n\n\n\n\n\nJustifier qu’il s’agit bien d’un arbre binaire.\nDonner la clef de la racine.\nDonner le sous-arbre droit du nœud A.\nLe nœud C est-il une feuille ? Justifier.\nDonner la taille de cet arbre.\nDonner la profondeur du nœud B.\nDonner la hauteur de cet arbre."
  },
  {
    "objectID": "arbresgraphes/arbres_exercices.html#fa-solid-pencil-alt-exercice-3",
    "href": "arbresgraphes/arbres_exercices.html#fa-solid-pencil-alt-exercice-3",
    "title": "Exercices sur les arbres",
    "section": " Exercice 3",
    "text": "Exercice 3\nSoit les valeurs suivantes : 14, 22, 8, 47, 42, 13, 1, 24, 33, 74.\nConstruire un arbre binaire de recherche à partir de ces valeurs."
  },
  {
    "objectID": "arbresgraphes/graphes_cours.html",
    "href": "arbresgraphes/graphes_cours.html",
    "title": "Graphes (Cours)",
    "section": "",
    "text": "Définition\n\n\n\nUn graphe non orienté est constitué :\n\nd’un ensemble fini de sommets (représentés par des points) ;\nd’un ensemble d’arêtes (représentées par des traits) qui relient des sommets entre eux.\n\n\n\nLa figure ci-dessous représente un graphe dont les sommets sont numérotés de 0 à 6.\n\n\n\nGraphe non orienté\n\n\n\n\n\n\n\n\nDéfinition\n\n\n\nUn graphe orienté est constitué :\n\nd’un ensemble fini de sommets (représentés par des points) ;\nd’un ensemble d’arcs (représentés par des flèches) qui relient des sommets entre eux.\n\n\n\nLa figure ci-dessous représente un graphe orienté dont les sommets sont numérotés de 0 à 6.\n\n\n\nGraphe orienté\n\n\n\nUn peu de vocabulaire :\n\ndeux sommets reliés par une arête (ou un arc) sont dits adjacents, ou voisins ;\nun sommet est dit isolé s’il n’est relié à aucun autre sommet ;\nl’ordre d’un graphe est le nombre de ses sommets ;\nle degré d’un sommet \\(S\\), noté \\(deg(S)\\), est le nombre d’arêtes (ou d’arcs) qui le relient à d’autres sommets ;\n\n\n\n\nLa structure d’arbre déjà rencontrée dans le cours est un cas particulier de graphe non orienté.\n\n\n\n\n\n\nDéfinition\n\n\n\nUn arbre est un graphe non orienté qui satisfait les conditions suivantes :\n\nil est connexe ;\nil n’a pas de cycle.\n\n\n\nExplications : connexe signifie que tous les sommets sont reliés entre eux par un chemin (il n’y a pas de points isolés). pas de cycle signifie que l’on ne peut pas revenir au même sommet en passant par le même chemin.\nEn particulier le graphe ci-dessus (?@fig-graphe1) n’est pas un arbre, car il n’est pas connexe (le sommet 6 n’est pas relié au sommet 1) et il contient un cycle (le chemin 1-2-4-1).\n\n\n\nVoici quelques situations pouvant être modélisées par un graphe :\n\nun réseau routier ;\nun réseau de télécommunications ;\nun réseau social ;\nun réseau électrique ;"
  },
  {
    "objectID": "arbresgraphes/graphes_cours.html#notion-de-graphe",
    "href": "arbresgraphes/graphes_cours.html#notion-de-graphe",
    "title": "Graphes (Cours)",
    "section": "",
    "text": "Définition\n\n\n\nUn graphe non orienté est constitué :\n\nd’un ensemble fini de sommets (représentés par des points) ;\nd’un ensemble d’arêtes (représentées par des traits) qui relient des sommets entre eux.\n\n\n\nLa figure ci-dessous représente un graphe dont les sommets sont numérotés de 0 à 6.\n\n\n\nGraphe non orienté\n\n\n\n\n\n\n\n\nDéfinition\n\n\n\nUn graphe orienté est constitué :\n\nd’un ensemble fini de sommets (représentés par des points) ;\nd’un ensemble d’arcs (représentés par des flèches) qui relient des sommets entre eux.\n\n\n\nLa figure ci-dessous représente un graphe orienté dont les sommets sont numérotés de 0 à 6.\n\n\n\nGraphe orienté\n\n\n\nUn peu de vocabulaire :\n\ndeux sommets reliés par une arête (ou un arc) sont dits adjacents, ou voisins ;\nun sommet est dit isolé s’il n’est relié à aucun autre sommet ;\nl’ordre d’un graphe est le nombre de ses sommets ;\nle degré d’un sommet \\(S\\), noté \\(deg(S)\\), est le nombre d’arêtes (ou d’arcs) qui le relient à d’autres sommets ;\n\n\n\n\nLa structure d’arbre déjà rencontrée dans le cours est un cas particulier de graphe non orienté.\n\n\n\n\n\n\nDéfinition\n\n\n\nUn arbre est un graphe non orienté qui satisfait les conditions suivantes :\n\nil est connexe ;\nil n’a pas de cycle.\n\n\n\nExplications : connexe signifie que tous les sommets sont reliés entre eux par un chemin (il n’y a pas de points isolés). pas de cycle signifie que l’on ne peut pas revenir au même sommet en passant par le même chemin.\nEn particulier le graphe ci-dessus (?@fig-graphe1) n’est pas un arbre, car il n’est pas connexe (le sommet 6 n’est pas relié au sommet 1) et il contient un cycle (le chemin 1-2-4-1).\n\n\n\nVoici quelques situations pouvant être modélisées par un graphe :\n\nun réseau routier ;\nun réseau de télécommunications ;\nun réseau social ;\nun réseau électrique ;"
  },
  {
    "objectID": "arbresgraphes/graphes_cours.html#implémentations-dun-graphe",
    "href": "arbresgraphes/graphes_cours.html#implémentations-dun-graphe",
    "title": "Graphes (Cours)",
    "section": "2. Implémentations d’un graphe",
    "text": "2. Implémentations d’un graphe\nL’objectif de cette section est de définir une structure de données en Python permettant de représenter un graphe.\nLes opérations suivantes doivent être possibles (cf. FORTIER (2022)):\n\ncréer un graphe vide ;\najouter un sommet ;\najouter une arête (ou un arc) ;\nsupprimer un sommet ;\nsupprimer une arête (ou un arc) ;\nvérifier si deux sommets sont adjacents ;\nconnaître la liste des sommets adjacents à un sommet donné.\n\nNous étudions deux implémentations : par matrice d’adjacence et par liste d’adjacence.\n\n2.1. Matrice d’adjacence\nRappel : une matrice est un tableau à deux dimensions, où chaque élément est identifié par un couple de coordonnées (ligne, colonne). En Python, on peut représenter une matrice par une liste de listes.\n\n\n\n\n\n\nDéfinition\n\n\n\nLa matrice d’adjacence d’un graphe \\(G\\) (orienté ou non) est une matrice carrée \\(A\\) de taille \\(n\\) telle que :\n\n\\(A_{i,j} = 1\\) si les sommets \\(i\\) et \\(j\\) sont adjacents ;\n\\(A_{i,j} = 0\\) si les sommets \\(i\\) et \\(j\\) ne sont pas adjacents.\n\n\n\nExemple : la matrice d’adjacence du graphe non orienté de la figure ci-dessus (?@fig-graphe1) est la suivante :\n\n\n\n\n\nGraphe Fig.1\n\n\n\n\\[\n\\begin{pmatrix}\n0 & 0 & 0 & 0 & 0 & 0 & 1 \\\\\n0 & 0 & 1 & 1 & 1 & 0 & 0 \\\\\n0 & 1 & 0 & 0 & 1 & 1 & 0\\\\\n0 & 1 & 0 & 0 & 1 & 0 & 0\\\\\n0 & 1 & 1 & 1 & 0 & 0 & 0\\\\\n0 & 0 & 1 & 0 & 0 & 0 & 0\\\\\n1 & 0 & 0 & 0 & 0 & 0 & 0\n\\end{pmatrix}\n\\]\n\n\n\nRemarques : dans le cas d’un graphe non orienté, la matrice d’adjacence est symétrique par rapport à la diagonale principale. Dans le cas d’un graphe orienté, la matrice d’adjacence n’est pas forcément symétrique.\n\n\n\n\n\n\nTP Python\n\n\n\nTP Python : implémentation des graphes par matrice d’adjacence\n\n\n\n\n\n2.2. Liste d’adjacence\n\n\n\n\n\n\nDéfinition : liste d’adjacence\n\n\n\nLa liste d’adjacence d’un graphe \\(G\\) (orienté ou non) dont les sommets sont les entiers compris entre 0 et \\(n-1\\) est une liste \\(L\\) de taille \\(n\\) telle que :\n\n\\(L[i]\\) est la liste des sommets adjacents au sommet \\(i\\).\n\n\n\nExemple : la liste d’adjacence du graphe non orienté de la figure ci-dessus (?@fig-graphe1) est la suivante :\n\n\n\n\n\nGraphe Fig.1\n\n\n\n\\[\n\\begin{array}{|c|c|}\n\\hline\n0 & [6] \\\\\n\\hline\n1 & [2,3,4] \\\\\n\\hline\n2 & [1,4,5] \\\\\n\\hline\n3 & [1,4] \\\\\n\\hline\n4 & [1,2,3] \\\\\n\\hline\n5 & [2] \\\\\n\\hline\n6 & [0] \\\\\n\\hline\n\\end{array}\n\\]\n\n\n\nDans le cas d’un graphe comportant peu d’arêtes, la liste d’adjacence occupe moins de mémoire que la matrice d’adjacence. Mais certaines opérations, comme la vérification de l’adjacence de deux sommets ou la suppression d’une arête, sont plus coûteuses en temps d’exécution.\n\n\n\n\n\n\nTP Python\n\n\n\nDans le TP ci-dessous, vous devez implémenter la structure de graphe par liste d’adjacence. Vous devez également implémenter les fonctions permettant de passer d’une représentation à l’autre.\nTP Python : implémentation des graphes par liste d’adjacence"
  },
  {
    "objectID": "arbresgraphes/graphes_exercices.html",
    "href": "arbresgraphes/graphes_exercices.html",
    "title": "Exercices sur les graphes",
    "section": "",
    "text": "Les exercices précédés du symbole  sont à faire sur machine, en sauvegardant le fichier si nécessaire.\nLes exercices précédés du symbole  doivent être résolus par écrit."
  },
  {
    "objectID": "arbresgraphes/graphes_exercices.html#fa-solid-pencil-alt-exercice-1",
    "href": "arbresgraphes/graphes_exercices.html#fa-solid-pencil-alt-exercice-1",
    "title": "Exercices sur les graphes",
    "section": " Exercice 1",
    "text": "Exercice 1\nOn dit qu’un graphe est simple s’il n’y a pas de boucle ni de double arête. Un graphe simple est dit complet s’il est non orienté et que chaque paire de sommets est reliée par une arête.\nDessiner un graphe complet d’ordre 3, puis un graphe complet d’ordre 4."
  },
  {
    "objectID": "arbresgraphes/graphes_exercices.html#fa-solid-pencil-alt-exercice-2",
    "href": "arbresgraphes/graphes_exercices.html#fa-solid-pencil-alt-exercice-2",
    "title": "Exercices sur les graphes",
    "section": " Exercice 2",
    "text": "Exercice 2\nGraphe d’un réseau électrique\nUn de vos amis travaille pour un distributeur d’électricité.\nIl doit proposer à son supérieur une représentation du réseau reliant différentes villes. Comme il n’y arrive pas trop, il voudrait que vous la lui fassiez.\nPour simplifier le problème, il a déjà renommé les villes en A, B, C, D, E et F. De plus, il vous donne les informations suivantes :\n\nla ville B est reliée par un réseau électrique aux villes A, C et D,\nla ville A est reliée par un réseau électrique aux villes B, E et F,\nla ville C est reliée par un réseau électrique aux villes B, D, E et F,\nla ville D est reliée par un réseau électrique aux villes B, C et F,\nla ville E est reliée par un réseau électrique aux villes A, C et F,\nla ville F est relié par un réseau électrique aux villes A, C, D et E.\n\nProposer un graphe qui modélise la situation.\nCe graphe est-il complet ? Pourquoi ?\nDonner sa matrice d’adjacence."
  },
  {
    "objectID": "arbresgraphes/graphes_exercices.html#fa-solid-pencil-alt-exercice-3",
    "href": "arbresgraphes/graphes_exercices.html#fa-solid-pencil-alt-exercice-3",
    "title": "Exercices sur les graphes",
    "section": " Exercice 3",
    "text": "Exercice 3\nVoici un ensemble de relations :\n\nA est ami avec tout le monde sauf G,\nB est ami avec A, D et H,\nC est ami avec A, F, G et H,\nD est ami avec A, B et H,\nE est ami avec A et H,\nF est ami avec A et C,\nG est ami avec C et H,\nH est ami avec A, B, C, D, E et G.\n\n\nReprésenter ce graphe et vérifier qu’il est non orienté.\nImplémenter ce graphe sous la forme d’une liste d’adjacence dans laquelle chaque clé représente le nœud étudié.\nÉcrire la matrice d’adjacence et vérifier qu’elle est symétrique (on utilisera l’ordre alphabétique pour indexer les nœuds). 4 Implémenter la matrice en python sous la forme d’une liste de liste."
  },
  {
    "objectID": "arbresgraphes/graphes_exercices.html#fa-solid-pencil-alt-exercice-4",
    "href": "arbresgraphes/graphes_exercices.html#fa-solid-pencil-alt-exercice-4",
    "title": "Exercices sur les graphes",
    "section": " Exercice 4",
    "text": "Exercice 4\nVoici un graphe représentant les distances dans le réseau sud-est.\n\n\n\nRéseau sud-Est\n\n\n\nImplémenter ce graphe sous la forme d’un dictionnaire de liste dans lequel chaque clé représente le nœud étudié et les sommets adjacents sont représentés sous la forme d’une liste de dictionnaires clé(sommet adjacent): valeur(distance).\nÉcrire la matrice d’adjacence et vérifier qu’elle est symétrique(on utilisera l’ordre alphabétique pour indexer les nœuds).\nProposer un algorithme qui renvoie tous les chemins possibles pour aller de Nice à Lyon sans jamais passer deux fois par la même ville. On utilisera trois paramètres d’entrée: le graphe implémenté sous la forme d’un dictionnaire d’adjacence comme celui de la question 2 et les deux villes de départ et d’arrivée."
  },
  {
    "objectID": "arbresgraphes/implementationArbres.html",
    "href": "arbresgraphes/implementationArbres.html",
    "title": "Implémentation des arbres en Python",
    "section": "",
    "text": "L’objectif de cette partie est d’implémenter la structure d’arbre binaire en Python. Nous allons pour cela utiliser la Programmation Orientée Objet et construire un module réutilisable proposant à l’utilisateur une interface (API) permettant de travailler avec les arbres binaires."
  },
  {
    "objectID": "arbresgraphes/implementationArbres.html#arbres-binaires",
    "href": "arbresgraphes/implementationArbres.html#arbres-binaires",
    "title": "Implémentation des arbres en Python",
    "section": "1. Arbres binaires",
    "text": "1. Arbres binaires\nUne interface souhaitable devrait permettre de :\n\nCréer un arbre vide ;\nAccéder au sous-arbre gauche et au sous-arbre droit d’un nœud ;\nAccéder à une clef ;\nTester si un nœud est une feuille ;\nTester si un arbre est vide ;\nRetourner la taille ;\nRetourner la hauteur.\n\nDe plus, il serait souhaitable de parvenir à afficher un arbre de façon visuelle.\nNous avons vu que la structure d’arbre binaire est une structure récursive : cette propriété est exploitée dans l’implémentation que nous allons présenter. Pour définir un arbre, il suffit de définir un nœud racine ainsi que les deux sous-arbres gauche et droite qui sont eux-même des arbres binaires. Cela revient à assimiler un arbre à sa racine associée à un lien vers ses deux fils.\nNous définissons ci-dessous un objet ArbreBinaire possédant trois attributs clef, gauche, droit. Pour respecter les principes de la POO, et notamment la notion d’encapsulation, nous avons défini des méthodes d’accès aux attributs (elles commencent par get) et des méthodes de modification des attributs (elles commencent par set) et on s’interdira tout accès ou affectation direct(e) du type arbre.racine = ....\nLa méthode setRacine, qui permet de définir la clef d’un nœud assure que chaque nœud a toujours un sous-arbre gauche et un sous-arbre droit, éventuellement vides, ce qui facilite le traitement des arbres dans les algorithmes suivants. On matérialise ici l’aspect récursif de la structure.\nclass ArbreBinaire:\n    \"\"\" Implémentation de la structure d'arbre binaire \"\"\"\n\n    def __init__(self):\n        self.racine = None\n        # les sous-arbres gauche et droit doivent être des \n        # instances de l'objet ArbreBinaire\n        self.gauche = None\n        self.droit = None\n\n    def setRacine(self, racine):\n        \"\"\"définit la clef de la racine de l'instance\n         et crée les sous arbres vides gauches et droits\"\"\"\n        self.racine = racine\n        if self.gauche is None:\n            self.gauche = ArbreBinaire()\n        if self.droit is None:\n            self.droit = ArbreBinaire()\n    \n    def getRacine(self):\n        \"\"\"retourne la clef de la racine de l'arbre\"\"\"\n        return self.racine\n\n    def getSousArbreGauche(self):\n        return self.gauche\n\n    def setSousArbreGauche(self, arbre):\n        if isinstance(arbre, ArbreBinaire):\n            self.gauche = arbre\n\n    def getSousArbreDroit(self):\n        return self.droit\n\n    def setSousArbreDroit(self, arbre):\n        if isinstance(arbre, ArbreBinaire):\n            self.droit = arbre\n\n    def estVide(self) -&gt; bool:\n        return self.racine is None\n\n    def estFeuille(self) -&gt; bool:\n        if self.estVide():\n            return False\n        else:\n            return self.gauche.estVide() and self.droit.estVide()\n\n    def __str__(self):\n        if self.estVide():\n            return \"()\"\n        elif self.estFeuille():\n            return f\"('{self.racine}', (), ())\"\n        else:\n            return f\"('{self.racine}', {self.gauche.__str__()}, {self.droit.__str__()})\"\nLa classe est complétée par une méthode estVide permettant de tester si un arbre est vide ou non et une méthode estFeuille permettant de tester si un nœud est une feuille ou non (on confond un nœud avec un arbre de hauteur 1).\nLa dernière méthode est la méthode spéciale __str__ qui définit la façon dont un arbre va être affiché par la fonction print. Ici, on a choisi un affichage sous forme de tuple du type (clef, sous-arbre gauche, sous-arbre droit).\nPour créer un module, on enregistre le code ci-dessus dans un fichier nommé par exemple structures.py.\nOn peut ensuite utiliser notre nouvelle structure dans un autre fichier Python (dans le même dossier), ou dans la console interactive, en important le module :\nfrom structures import *\n\na = ArbreBinaire()\na.setRacine(8)\na.getSousArbreGauche().setRacine(3)\na.getSousArbreDroit().setRacine(9)\nb = a.getSousArbreGauche()\nc = a.getSousArbreDroit()\nb.getSousArbreGauche().setRacine(7)\nb.getSousArbreDroit().setRacine(5)\nc.getSousArbreDroit().setRacine(1)\nprint(a)\nOn obtient en sortie :\n&gt;&gt;&gt; (8, (3, (7, (), ()), (5, (), ())), (9, (), (1, (), ())))\nCela correspond à l’arbre représenté ci-dessous :\n\n\n\n\n\nOn peut tester les autres méthodes dans la console :\nprint(c)\n&gt;&gt;&gt; (9, (), (1, (), ()))\nc.getSousArbreGauche().estVide()\n&gt;&gt;&gt; True\nc.estFeuille()\n&gt;&gt;&gt; False\nc.getSousArbreDroit().estFeuille()\n&gt;&gt;&gt; True\nNous pouvons maintenant ajouter au fichier structures.py les deux fonctions suivantes (en dehors de la classe ArbreBinaire car ce ne sont pas des méthodes) qui retournent respectivement la taille et la hauteur d’un arbre binaire.\ndef taille(arbre) -&gt; int:\n    \"\"\"Retourne la taille de l'arbre, càd son nombre de noeuds\"\"\"\n    if arbre.racine is None:\n        return 0\n    else:\n        return 1 + taille(arbre.gauche) + taille(arbre.droit)\n\ndef hauteur(arbre) -&gt; int:\n    \"\"\"Retourne la hauteur de l'arbre\"\"\"\n    if arbre.racine is None:\n        return 0\n    else:\n        return 1 + max(hauteur(arbre.gauche), hauteur(arbre.droit))\nPrendre le temps de bien comprendre comment fonctionnent ces deux fonctions …\ntaille(a)\n&gt;&gt;&gt; 6\nhauteur(a)\n&gt;&gt;&gt; 3\nCe module structures sera utilisé en exercices et plus tard dans l’année lorsque nous étudierons les algorithmes sur les arbres."
  },
  {
    "objectID": "arbresgraphes/implementationArbres.html#arbres-binaires-de-recherche-abr",
    "href": "arbresgraphes/implementationArbres.html#arbres-binaires-de-recherche-abr",
    "title": "Implémentation des arbres en Python",
    "section": "2. Arbres binaires de recherche (ABR)",
    "text": "2. Arbres binaires de recherche (ABR)\nLes ABR sont des arbres binaires. Nous pouvons donc créer une classe ABR fille de la classe ArbreBinaire en utilisant la notion d’héritage et de polymorphisme de la POO (voir les compléments de cours à ce sujet). Nous définissons une méthode spécifique : l’insertion d’une clef. Cette méthode ajoute une clef à un ABR existant en s’assurant que l’arbre obtenu est toujours un ABR (le nouveau nœud est toujours une feuille).\nclass ABR(ArbreBinaire):\n    \"\"\" Implémentation de la structure d'arbre binaire de recherche \"\"\"\n\n    def __init__(self):\n        super().__init__()\n\n    def setRacine(self, racine):\n        \"\"\"définit la clef de la racine de l'instance\n         et crée les sous arbres vides gauches et droits\n         Provoque une erreur si la racine casse la structure d'ABR\"\"\"\n        self.racine = racine\n        if self.gauche is None:\n            self.gauche = ABR()\n        if self.droit is None:\n            self.droit = ABR()\n        if not estABR(self):\n            raise Exception(\"Cette affectation de clef casse la structure ABR !!!\")\n\n    def insere(self, racine):\n        \"\"\"insère une clef dans l'arbre en préservant la structure ABR\"\"\"\n        if self.racine is None:\n            self.racine = racine\n            self.gauche = ABR()\n            self.droit = ABR()\n        else:\n            if racine &lt; self.racine:\n                self.gauche.insere(racine)\n            else:\n                self.droit.insere(racine)\nPour définir un arbre binaire de recherche valide, on utilisera toujours la méthode insere car elle permet de s’assurer de toujours conserver un ABR.\nPour faciliter la vérification, nous définissons une fonction estABR qui peut s’appliquer aussi bien à un arbre binaire quelconque qu’à un ABR et qui retourne True si l’arbre est un ABR et False sinon.\ndef estABR(arbre, mini=-float(\"inf\"), maxi=+float(\"inf\")) -&gt; bool:\n    if arbre.getRacine() is None:\n        return True\n    else:\n        return estABR(arbre.getSousArbreGauche(), mini, arbre.getRacine()) and \n               estABR(arbre.getSousArbreDroit(), arbre.getRacine(), maxi) and \n               mini &lt; arbre.racine &lt; maxi\nPrendre le temps de bien comprendre cette fonction …\nUtilisation :\nfrom structures import *\n\na = ABR()\na.setRacine(8)\na.insere(5)\na.insere(3)\na.insere(12)\na.insere(10)\na.insere(15)\nprint(a)\nprint(estABR(a))\n# Affectation directe à proscrire :\n# a.getSousArbreDroit().setRacine(1) ## provoque une erreur\nSortie :\n(8, (5, (3, (), ()), ()), (12, (10, (), ()), (15, (), ())))\nTrue\nL’arbre correspond à :\n\n\n\n\n\nLe module structure.py est à conserver : il sera utilisé en exercices et dans les chapitres suivants.\n\n\n\n\n\n\nComplément\n\n\n\nOn peut ajouter une fonctionnalité de représentation graphique d’un arbre en utilisant les bibliothèques networkx et matplotlib. Ajouter la fonction ci-dessous au fichier structures.py :\nimport networkx as nx\nimport matplotlib.pyplot as plt\n\ndef afficheArbre(arbre, size=(4,4), null_node=False):\n\"\"\"\nsize : tuple de 2 entiers. Si size est int -&gt; (size, size)\nnull_node : si True, trace les liaisons vers les sous-arbres vides\n\"\"\"\narbreAsTuple = eval(arbre.__str__())\ndef parkour(arbre, noeuds, branches, labels, positions, profondeur, \n            pos_courante, pos_parent, null_node):\n    if arbre != ():\n        noeuds[0].append(pos_courante)\n        positions[pos_courante] = (pos_courante, profondeur)\n        profondeur -= 1\n        labels[pos_courante] = str(arbre[0])\n        branches[0].append((pos_courante, pos_parent))\n        pos_gauche = pos_courante - 2 ** profondeur\n        parkour(arbre[1], noeuds, branches, labels, positions, profondeur, \n                pos_gauche, pos_courante, null_node)\n        pos_droit = pos_courante + 2 ** profondeur\n        parkour(arbre[2], noeuds, branches, labels, positions, profondeur, \n                pos_droit, pos_courante, null_node)\n    elif null_node:\n        noeuds[1].append(pos_courante)\n        positions[pos_courante] = (pos_courante, profondeur)\n        branches[1].append((pos_courante, pos_parent))\n\nif arbreAsTuple == ():\n    return\n\nbranches = [[]]\nprofondeur = hauteur(arbre)\npos_courante = 2 ** profondeur\nnoeuds = [[pos_courante]]\npositions = {pos_courante: (pos_courante, profondeur)}\nlabels = {pos_courante: str(arbreAsTuple[0])}\n\nif null_node:\n    branches.append([])\n    noeuds.append([])\n\nprofondeur -= 1\nparkour(arbreAsTuple[1], noeuds, branches, labels, positions, profondeur, \n        pos_courante - 2 ** profondeur, pos_courante, null_node)\nparkour(arbreAsTuple[2], noeuds, branches, labels, positions, profondeur, \n        pos_courante + 2 ** profondeur, pos_courante, null_node)\n\nmon_arbre = nx.Graph()\n\nif type(size) == int:\n    size = (size, size)\nplt.figure(figsize=size)\n\nnx.draw_networkx_nodes(mon_arbre, positions, nodelist=noeuds[0], \n                       node_color=\"white\", node_size=550, edgecolors=\"blue\")\nnx.draw_networkx_edges(mon_arbre, positions, edgelist=branches[0], \n                       edge_color=\"black\", width=2)\nnx.draw_networkx_labels(mon_arbre, positions, labels)\n\nif null_node:\n    nx.draw_networkx_nodes(mon_arbre, positions, nodelist=noeuds[1], \n                           node_color=\"white\", node_size=50, edgecolors=\"grey\")\n    nx.draw_networkx_edges(mon_arbre, positions, edgelist=branches[1], \n                           edge_color=\"grey\", width=1)\n\nax = plt.gca()\nax.margins(0.1)\nplt.axis(\"off\")\nplt.show()\nplt.close()\nUtilisation :\nfrom structures import *\n\na = ABR()\na.setRacine(8)\na.insere(5)\na.insere(3)\na.insere(12)\na.insere(10)\na.insere(15)\n\nafficheArbre(a)\nSortie :"
  },
  {
    "objectID": "arbresgraphes/index.html",
    "href": "arbresgraphes/index.html",
    "title": "Programme",
    "section": "",
    "text": "Contenus\nCapacités attendues\nCommentaires\n\n\n\n\nArbres : structures hiérarchiques. Arbres binaires : nœuds, racines, feuilles, sous-arbres gauches, sous-arbres droits.\nIdentifier des situations nécessitant une structure de données arborescente. Évaluer quelques mesures des arbres binaires (taille, encadrement de la hauteur, etc.).\nOn fait le lien avec la rubrique « algorithmique ».\n\n\n\n\n\n\n\n\n\n\n\nContenus\nCapacités attendues\nCommentaires\n\n\n\n\nGraphes : structures relationnelles. Sommets, arcs, arêtes, graphes orientés ou non orientés.\nModéliser des situations sous forme de graphes. Écrire les implémentations correspondantes d’un graphe : matrice d’adjacence, liste de successeurs/de prédécesseurs. Passer d’une représentation à une autre.\nOn s’appuie sur des exemples comme le réseau routier, le réseau électrique, Internet, les réseaux sociaux. Le choix de la représentation dépend du traitement qu’on veut mettre en place : on fait le lien avec la rubrique « algorithmique »."
  },
  {
    "objectID": "arbresgraphes/index.html#programme",
    "href": "arbresgraphes/index.html#programme",
    "title": "Programme",
    "section": "",
    "text": "Contenus\nCapacités attendues\nCommentaires\n\n\n\n\nArbres : structures hiérarchiques. Arbres binaires : nœuds, racines, feuilles, sous-arbres gauches, sous-arbres droits.\nIdentifier des situations nécessitant une structure de données arborescente. Évaluer quelques mesures des arbres binaires (taille, encadrement de la hauteur, etc.).\nOn fait le lien avec la rubrique « algorithmique ».\n\n\n\n\n\n\n\n\n\n\n\nContenus\nCapacités attendues\nCommentaires\n\n\n\n\nGraphes : structures relationnelles. Sommets, arcs, arêtes, graphes orientés ou non orientés.\nModéliser des situations sous forme de graphes. Écrire les implémentations correspondantes d’un graphe : matrice d’adjacence, liste de successeurs/de prédécesseurs. Passer d’une représentation à une autre.\nOn s’appuie sur des exemples comme le réseau routier, le réseau électrique, Internet, les réseaux sociaux. Le choix de la représentation dépend du traitement qu’on veut mettre en place : on fait le lien avec la rubrique « algorithmique »."
  },
  {
    "objectID": "arbresgraphes/TParbres.html",
    "href": "arbresgraphes/TParbres.html",
    "title": "TP - Manipulation d’arbres",
    "section": "",
    "text": "Ce T.P. est à réaliser et à rendre dans Capytale.\n\nOuvrez le lien ci-dessus ;\nConnectez-vous avec vos identifiants ENT ;\nEntrez le code du TP : 15c9-991659\nCliquez sur “Go !”."
  },
  {
    "objectID": "arbresgraphes/TParbres.html#t.p.-arbres-binaires-quelques-compléments-utiles",
    "href": "arbresgraphes/TParbres.html#t.p.-arbres-binaires-quelques-compléments-utiles",
    "title": "TP - Manipulation d’arbres",
    "section": "",
    "text": "Ce T.P. est à réaliser et à rendre dans Capytale.\n\nOuvrez le lien ci-dessus ;\nConnectez-vous avec vos identifiants ENT ;\nEntrez le code du TP : 15c9-991659\nCliquez sur “Go !”."
  },
  {
    "objectID": "arbresgraphes/tp_graphe_liste.html",
    "href": "arbresgraphes/tp_graphe_liste.html",
    "title": "TP - Implémentation des graphes par liste d’adjacence",
    "section": "",
    "text": "Cliquer ici pour accéder à la version notebook de ce TP sur Capytale\nOn considère un graphe \\(G\\) dont les sommets sont les entiers de \\(0\\) à \\(n-1\\) et les arêtes sont les couples d’entiers \\((i,j)\\) avec \\(0\\leq i,j\\leq n-1\\).\nL’objectif de ce TP est d’implémenter les graphes en python par liste d’adjacence.\nOn considère ici que les graphes sont non orientés."
  },
  {
    "objectID": "arbresgraphes/tp_graphe_liste.html#implémentation-objet",
    "href": "arbresgraphes/tp_graphe_liste.html#implémentation-objet",
    "title": "TP - Implémentation des graphes par liste d’adjacence",
    "section": "1. Implémentation objet",
    "text": "1. Implémentation objet\nCréer une classe Graph qui permet de représenter un graphe par liste d’adjacence.\nLa classe Graph doit contenir les attributs suivants :\n\norder : le nombre de sommets du graphe\nliste : une liste de listes d’entiers représentant la liste d’adjacence du graphe\n\nLa classe Graph doit contenir les méthodes suivantes :\n\n__init__ : initialise un graphe vide de taille order\nadd_edge : ajoute l’arête \\((i,j)\\) au graphe\nremove_edge : supprime l’arête \\((i,j)\\) du graphe\nadd_vertex : ajoute un sommet au graphe\nremove_vertex : supprime le sommet i du graphe\nis_adjacent : retourne True si les sommets i et j sont adjacents, False sinon\nneighbors : retourne la liste des voisins du sommet i\ndegree : retourne le degré du sommet i\n__str__ : retourne une chaîne de caractères représentant le graphe (afficher sur chaque ligne le numéro du sommet suivi de la liste de ses voisins)\ndraw : dessine le graphe (s’inspirer du TP précédent !)\n\n\nimport networkx as nx\n\nclass Graph:\n\n    pass\n\n\n# Exemple d'utilisation\n\ng = Graph(5)\ng.add_edge(0, 3)\ng.add_edge(1, 2)\ng.add_edge(1, 4)\ng.add_edge(2, 3)\ng.add_edge(2, 4)\ng.add_edge(3, 4)\nprint(g)\ng.draw()"
  },
  {
    "objectID": "arbresgraphes/tp_graphe_liste.html#passage-dune-représentation-à-lautre",
    "href": "arbresgraphes/tp_graphe_liste.html#passage-dune-représentation-à-lautre",
    "title": "TP - Implémentation des graphes par liste d’adjacence",
    "section": "Passage d’une représentation à l’autre",
    "text": "Passage d’une représentation à l’autre\nOn considère un graphe \\(G\\) représenté par liste d’adjacence. On souhaite passer à une représentation par matrice d’adjacence.\nCompléter la fonction list_to_matrix qui prend en paramètre une liste d’adjacence d’un graphe G et retourne la matrice d’adjacence représentant le graphe.\n\ndef list_to_matrix(liste):\n    pass\n\n\n# Test de la fonction list_to_matrix\nmatrice = list_to_matrix(g.liste)\nassert matrice == [[0, 0, 0, 1, 0], [0, 0, 1, 0, 1], [0, 1, 0, 1, 1], [1, 0, 1, 0, 1], [0, 1, 1, 1, 0]]\nprint(\"Test réussi !\")\n\nOpération inverse : compléter la fonction matrix_to_list qui prend en paramètre une matrice d’adjacence d’un graphe G et retourne la liste d’adjacence représentant le graphe.\n\ndef matrix_to_list(matrice):\n    pass\n\n\n# Test de la fonction matrix_to_list\nliste = matrix_to_list(matrice)\nassert liste == [[3], [2, 4], [1, 3, 4], [0, 2, 4], [1, 2, 3]]\nprint(\"Test réussi !\")"
  },
  {
    "objectID": "arbresgraphes/tp_graphe_liste_capytale.html",
    "href": "arbresgraphes/tp_graphe_liste_capytale.html",
    "title": "TP - Implémentation des graphes par liste d’adjacence",
    "section": "",
    "text": "On considère un graphe \\(G\\) dont les sommets sont les entiers de \\(0\\) à \\(n-1\\) et les arêtes sont les couples d’entiers \\((i,j)\\) avec \\(0\\leq i,j\\leq n-1\\).\nL’objectif de ce TP est d’implémenter les graphes en python par liste d’adjacence.\nOn considère ici que les graphes sont non orientés."
  },
  {
    "objectID": "arbresgraphes/tp_graphe_liste_capytale.html#implémentation-objet",
    "href": "arbresgraphes/tp_graphe_liste_capytale.html#implémentation-objet",
    "title": "TP - Implémentation des graphes par liste d’adjacence",
    "section": "1. Implémentation objet",
    "text": "1. Implémentation objet\nCréer une classe Graph qui permet de représenter un graphe par liste d’adjacence.\nLa classe Graph doit contenir les attributs suivants :\n\norder : le nombre de sommets du graphe\nliste : une liste de listes d’entiers représentant la liste d’adjacence du graphe\n\nLa classe Graph doit contenir les méthodes suivantes :\n\n__init__ : initialise un graphe vide de taille order\nadd_edge : ajoute l’arête \\((i,j)\\) au graphe\nremove_edge : supprime l’arête \\((i,j)\\) du graphe\nadd_vertex : ajoute un sommet au graphe\nremove_vertex : supprime le sommet i du graphe\nis_adjacent : retourne True si les sommets i et j sont adjacents, False sinon\nneighbors : retourne la liste des voisins du sommet i\ndegree : retourne le degré du sommet i\n__str__ : retourne une chaîne de caractères représentant le graphe (afficher sur chaque ligne le numéro du sommet suivi de la liste de ses voisins)\ndraw : dessine le graphe (s’inspirer du TP précédent !)\n\n\nimport networkx as nx\n\nclass Graph:\n\n    pass\n\n\n# Exemple d'utilisation\n\ng = Graph(5)\ng.add_edge(0, 3)\ng.add_edge(1, 2)\ng.add_edge(1, 4)\ng.add_edge(2, 3)\ng.add_edge(2, 4)\ng.add_edge(3, 4)\nprint(g)\ng.draw()"
  },
  {
    "objectID": "arbresgraphes/tp_graphe_liste_capytale.html#passage-dune-représentation-à-lautre",
    "href": "arbresgraphes/tp_graphe_liste_capytale.html#passage-dune-représentation-à-lautre",
    "title": "TP - Implémentation des graphes par liste d’adjacence",
    "section": "Passage d’une représentation à l’autre",
    "text": "Passage d’une représentation à l’autre\nOn considère un graphe \\(G\\) représenté par liste d’adjacence. On souhaite passer à une représentation par matrice d’adjacence.\nCompléter la fonction list_to_matrix qui prend en paramètre une liste d’adjacence d’un graphe G et retourne la matrice d’adjacence représentant le graphe.\n\ndef list_to_matrix(liste):\n    pass\n\n\n# Test de la fonction list_to_matrix\nmatrice = list_to_matrix(g.liste)\nassert matrice == [[0, 0, 0, 1, 0], [0, 0, 1, 0, 1], [0, 1, 0, 1, 1], [1, 0, 1, 0, 1], [0, 1, 1, 1, 0]]\nprint(\"Test réussi !\")\n\nOpération inverse : compléter la fonction matrix_to_list qui prend en paramètre une matrice d’adjacence d’un graphe G et retourne la liste d’adjacence représentant le graphe.\n\ndef matrix_to_list(matrice):\n    pass\n\n\n# Test de la fonction matrix_to_list\nliste = matrix_to_list(matrice)\nassert liste == [[3], [2, 4], [1, 3, 4], [0, 2, 4], [1, 2, 3]]\nprint(\"Test réussi !\")"
  },
  {
    "objectID": "arbresgraphes/tp_graphe_liste_CORR.html",
    "href": "arbresgraphes/tp_graphe_liste_CORR.html",
    "title": "TP - Implémentation des graphes par liste d’adjacence",
    "section": "",
    "text": "On considère un graphe \\(G\\) dont les sommets sont les entiers de \\(0\\) à \\(n-1\\) et les arêtes sont les couples d’entiers \\((i,j)\\) avec \\(0\\leq i,j\\leq n-1\\).\nL’objectif de ce TP est d’implémenter les graphes en python par liste d’adjacence.\nOn considère ici que les graphes sont non orientés."
  },
  {
    "objectID": "arbresgraphes/tp_graphe_liste_CORR.html#implémentation-objet",
    "href": "arbresgraphes/tp_graphe_liste_CORR.html#implémentation-objet",
    "title": "TP - Implémentation des graphes par liste d’adjacence",
    "section": "1. Implémentation objet",
    "text": "1. Implémentation objet\nCréer une classe Graph qui permet de représenter un graphe par liste d’adjacence.\nLa classe Graph doit contenir les attributs suivants :\n\norder : le nombre de sommets du graphe\nliste : une liste de listes d’entiers représentant la liste d’adjacence du graphe\n\nLa classe Graph doit contenir les méthodes suivantes :\n\n__init__ : initialise un graphe vide de taille order\nadd_edge : ajoute l’arête \\((i,j)\\) au graphe\nremove_edge : supprime l’arête \\((i,j)\\) du graphe\nadd_vertex : ajoute un sommet au graphe\nremove_vertex : supprime le sommet i du graphe\nis_adjacent : retourne True si les sommets i et j sont adjacents, False sinon\nneighbors : retourne la liste des voisins du sommet i\ndegree : retourne le degré du sommet i\n__str__ : retourne une chaîne de caractères représentant le graphe (afficher sur chaque ligne le numéro du sommet suivi de la liste de ses voisins)\ndraw : dessine le graphe (s’inspirer du TP précédent !)\n\n\nimport networkx as nx\n\nclass Graph:\n\n    def __init__(self, n):\n        self.order = n\n        self.liste = [[] for i in range(n)]\n\n    def add_edge(self, u, v):\n        self.liste[u].append(v)\n        self.liste[v].append(u)\n    \n    def remove_edge(self, u, v):\n        self.liste[u].remove(v)\n        self.liste[v].remove(u)\n    \n    def add_vertex(self):\n        self.liste.append([])\n        self.order += 1\n    \n    def remove_vertex(self, u):\n        for v in self.liste[u]:\n            self.liste[v].remove(u)\n        self.liste.pop(u)\n        self.order -= 1\n    \n    def is_adjacent(self, u, v):\n        return v in self.liste[u]\n    \n    def neighbors(self, u):\n        return self.liste[u]\n    \n    def degree(self, u):\n        return len(self.liste[u])\n    \n    def __str__(self):\n        rep = \"\"\n        for i in range(self.order):\n            rep += str(i) + \" : \" + str(self.liste[i]) + \"\\n\"\n        return rep\n    \n    def draw(self):\n        G = nx.Graph()\n        G.add_nodes_from(range(self.order))\n        for i in range(self.order):\n            for j in self.liste[i]:\n                G.add_edge(i, j)\n        nx.draw(G, with_labels=True, node_color='white', font_size=18, edgecolors='black', node_size=500)\n\n\n# Exemple d'utilisation\n\ng = Graph(5)\ng.add_edge(0, 3)\ng.add_edge(1, 2)\ng.add_edge(1, 4)\ng.add_edge(2, 3)\ng.add_edge(2, 4)\ng.add_edge(3, 4)\nprint(g)\ng.draw()\n\n0 : [3]\n1 : [2, 4]\n2 : [1, 3, 4]\n3 : [0, 2, 4]\n4 : [1, 2, 3]"
  },
  {
    "objectID": "arbresgraphes/tp_graphe_liste_CORR.html#passage-dune-représentation-à-lautre",
    "href": "arbresgraphes/tp_graphe_liste_CORR.html#passage-dune-représentation-à-lautre",
    "title": "TP - Implémentation des graphes par liste d’adjacence",
    "section": "Passage d’une représentation à l’autre",
    "text": "Passage d’une représentation à l’autre\nOn considère un graphe \\(G\\) représenté par liste d’adjacence. On souhaite passer à une représentation par matrice d’adjacence.\nCompléter la fonction list_to_matrix qui prend en paramètre une liste d’adjacence d’un graphe G et retourne la matrice d’adjacence représentant le graphe.\n\ndef list_to_matrix(liste):\n    n = len(liste)\n    mat = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        for j in liste[i]:\n            mat[i][j] = 1\n            mat[j][i] = 1\n    return mat\n\n\n# Test de la fonction list_to_matrix\nmatrice = list_to_matrix(g.liste)\nassert matrice == [[0, 0, 0, 1, 0], [0, 0, 1, 0, 1], [0, 1, 0, 1, 1], [1, 0, 1, 0, 1], [0, 1, 1, 1, 0]]\nprint(\"Test réussi !\")\n\nTest réussi !\n\n\nOpération inverse : compléter la fonction matrix_to_list qui prend en paramètre une matrice d’adjacence d’un graphe G et retourne la liste d’adjacence représentant le graphe.\n\ndef matrix_to_list(matrice):\n    n = len(matrice)\n    liste = [[] for i in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if matrice[i][j] == 1:\n                liste[i].append(j)\n    return liste\n\n\n# Test de la fonction matrix_to_list\nliste = matrix_to_list(matrice)\nassert liste == [[3], [2, 4], [1, 3, 4], [0, 2, 4], [1, 2, 3]]\nprint(\"Test réussi !\")\n\nTest réussi !"
  },
  {
    "objectID": "arbresgraphes/tp_graphe_matrice.html",
    "href": "arbresgraphes/tp_graphe_matrice.html",
    "title": "TP - Implémentation des graphes par matrice d’adjacence",
    "section": "",
    "text": "Cliquer ici pour accéder à la version notebook de ce TP dans Capytale\nOn considère un graphe \\(G\\) dont les sommets sont les entiers de \\(0\\) à \\(n-1\\) et les arêtes sont les couples d’entiers \\((i,j)\\) avec \\(0\\leq i,j\\leq n-1\\).\nL’objectif de ce TP est d’implémenter les graphes en python par matrice d’adjacence.\nOn considère ici que les graphes sont non orientés."
  },
  {
    "objectID": "arbresgraphes/tp_graphe_matrice.html#implémentation-simple",
    "href": "arbresgraphes/tp_graphe_matrice.html#implémentation-simple",
    "title": "TP - Implémentation des graphes par matrice d’adjacence",
    "section": "Implémentation simple",
    "text": "Implémentation simple\nQuestion 1 : Fonction permettant de créer un graphe comportant \\(n\\) sommets et pas d’arêtes.\n\ndef make_graph(n: int) -&gt; list:\n    \"\"\"Crée la matrice d'adjacence d'un graphe de n sommets sans arêtes\"\"\"\n    g = []\n    # Compléter ci dessous\n    \n    return g\n\n\n# Test de la fonction make_graph\n\ng = make_graph(5)\nprint(g)\n\nQuestion 2 : Fonction permettant d’ajouter une arête entre les sommets \\(i\\) et \\(j\\).\n\ndef add_edge(g: list, i: int, j: int) -&gt; None:\n    \"\"\"Ajoute l'arête (i,j) au graphe g\"\"\"\n    pass\n\nQuestion 3 - Application : en utilisant les deux fonctions précédentes, créer une variable g représentant le graphe suivant :\n\n\n\ngraphe 1\n\n\n\n# Entrer votre code ici\n\n\n# Vérification\nassert g == [[1, 1, 1, 0, 0], [1, 0, 1, 1, 0], [1, 1, 0, 1, 1], [0, 1, 1, 0, 1], [0, 0, 1, 1, 0]]\nprint(\"Test réussi !\")\n\nQuestion 4 : Compléter la fonction remove_edge permettant de supprimer une arête entre les sommets \\(i\\) et \\(j\\).\n\ndef remove_edge(g: list, i: int, j: int) -&gt; None:\n    \"\"\"Supprime l'arête (i,j) du graphe g\"\"\"\n    pass\n\n\n# Test de la fonction remove_edge\nfrom copy import deepcopy\n\nh = deepcopy(g)\nremove_edge(h, 0, 1)\nassert h == [[1, 0, 1, 0, 0], [0, 0, 1, 1, 0], [1, 1, 0, 1, 1], [0, 1, 1, 0, 1], [0, 0, 1, 1, 0]]\nprint(\"Test réussi !\")\n\nQuestion 5 : Compléter les fonctions add_vertex et remove_vertex permettant d’ajouter un sommet et de supprimer un sommet dans un graphe. On rappelle que les sommets sont des entiers successifs. Par exemple, si on supprime le sommet \\(2\\), les sommets \\(3\\) et \\(4\\) deviennent les sommets \\(2\\) et \\(3\\). Par ailleurs, le sommet ajouté par la fonction add_vertex doit être le plus grand sommet du graphe.\n\ndef add_vertex(g: list) -&gt; None:\n    \"\"\"Ajoute un sommet à un graphe g\"\"\"\n    pass\n\ndef remove_vertex(g: list, i: int) -&gt; None:\n    \"\"\"Supprime le sommet i du graphe g\"\"\"\n    pass\n\n\n# Test de la fonction add_vertex\nh = deepcopy(g)\nadd_vertex(h)\nassert h == [[1, 1, 1, 0, 0, 0], [1, 0, 1, 1, 0, 0], [1, 1, 0, 1, 1, 0], [0, 1, 1, 0, 1, 0], [0, 0, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0]]\nprint(\"Test réussi !\")\n\n\n# Test de la fonction remove_vertex\nremove_vertex(h, 5)\nassert h == [[1, 1, 1, 0, 0], [1, 0, 1, 1, 0], [1, 1, 0, 1, 1], [0, 1, 1, 0, 1], [0, 0, 1, 1, 0]]\nprint(\"Test réussi !\")\n\nQuestion 6 : Compléter la fonction est_adjacent qui prend en paramètre un graphe g et deux sommets i et j et qui renvoie True si les sommets sont adjacents et False sinon.\n\ndef is_adjacent(g: list, i: int, j: int) -&gt; bool:\n    \"\"\"Renvoie True si les sommets i et j sont adjacents, False sinon\"\"\"\n    pass\n\n\n# Test de la fonction is_adjacent\nassert is_adjacent(g, 0, 1) == True\nassert is_adjacent(g, 0, 4) == False\nprint(\"Test réussi !\")\n\nQuestion 7 : Compléter la fonction neighbors qui prend en paramètre un graphe g et un sommet i et qui renvoie la liste des sommets adjacents au sommet i, puis la fonction degree qui prend en paramètre un graphe g et un sommet i et qui renvoie le degré du sommet i.\n\ndef neighbors(g: list, i: int) -&gt; list:\n    \"\"\"Renvoie la liste des sommets autres que i \n       adjacents au sommet i\"\"\"\n    pass\n\ndef degree(g: list, i: int) -&gt; int:\n    \"\"\"Renvoie le degré du sommet i\"\"\"\n    pass\n\n\n# Test de la fonction neighbors\nassert neighbors(g, 0) == [1, 2]\nassert neighbors(g, 1) == [0, 2, 3]\n\n# Test de la fonction degree\nassert degree(g, 0) == 2\nassert degree(g, 1) == 3\nprint(\"Test réussi !\")"
  },
  {
    "objectID": "arbresgraphes/tp_graphe_matrice.html#implémentation-objet",
    "href": "arbresgraphes/tp_graphe_matrice.html#implémentation-objet",
    "title": "TP - Implémentation des graphes par matrice d’adjacence",
    "section": "Implémentation objet",
    "text": "Implémentation objet\nQuestion 8 : Créer une classe Graph permettant de représenter un graphe sous la forme d’une matrice d’adjacence, en reformulant les fonctions définies dans la partie précédente. Cette classe doit contenir les attributs suivants :\n\norder : nombre de sommets du graphe\nmatrix : matrice d’adjacence du graphe\n\nCette classe doit contenir les méthodes suivantes :\n\n__init__ : constructeur de la classe\nadd_edge : ajoute une arête entre les sommets i et j\nremove_edge : supprime une arête entre les sommets i et j\nadd_vertex : ajoute un sommet au graphe\nremove_vertex : supprime un sommet du graphe\nis_adjacent : renvoie True si les sommets i et j sont adjacents et False sinon\nneighbors : renvoie la liste des sommets adjacents au sommet i\ndegree : renvoie le degré du sommet i\n__str__ : renvoie une chaîne de caractères représentant le graphe en affichant les lignes de la matrice d’adjacence l’une en dessous de l’autre.\n\n\nclass Graph:\n\n    pass\n\nQuestion 9 - Application : en utilisant la classe Graph, créer une variable g représentant le graphe suivant :\n\n\n\ngraphe 2\n\n\nDéterminer la liste des voisins du sommet \\(2\\).\n\n# Entrer votre code ici\n\nBonus : Implémenter une fonction draw_graph permettant de dessiner un graphe à partir de sa matrice d’adjacence.\nPour cela, on utilisera le module networkx qui est spécialisé dans l’analyse des graphes. Il s’agit donc de définir un graphe de type networkx à partir de la matrice d’adjacence du graphe et de le dessiner à l’aide de la fonction draw du module networkx.\n\n# Imports nécessaires\nimport networkx as nx\n\nQuelques commandes utiles :\n\ng = nx.Graph() : création d’un graphe vide\ng.add_node(i) : ajoute le sommet i au graphe g\ng.add_edge(i,j) : ajoute une arête entre les sommets i et j\nnx.draw(g) : dessine le graphe g\n\n\ndef draw_graph(g: Graph) -&gt; None:\n    \"\"\"Dessine le graphe g\"\"\"\n    # Création du graphe\n    G = nx.Graph()\n    # Compléter ci-dessous pour définir un graphe G au format nx correspondant à g\n\n    \n    # Dessin du graphe\n    nx.draw(G, with_labels=True, node_color='white', font_size=18, edgecolors='black', node_size=500)\n\n\n# Vérification de la fonction draw_graph\ndraw_graph(g)"
  },
  {
    "objectID": "arbresgraphes/tp_graphe_matrice_capytale.html",
    "href": "arbresgraphes/tp_graphe_matrice_capytale.html",
    "title": "TP - Implémentation des graphes par matrice d’adjacence",
    "section": "",
    "text": "On considère un graphe \\(G\\) dont les sommets sont les entiers de \\(0\\) à \\(n-1\\) et les arêtes sont les couples d’entiers \\((i,j)\\) avec \\(0\\leq i,j\\leq n-1\\).\nL’objectif de ce TP est d’implémenter les graphes en python par matrice d’adjacence.\nOn considère ici que les graphes sont non orientés."
  },
  {
    "objectID": "arbresgraphes/tp_graphe_matrice_capytale.html#implémentation-simple",
    "href": "arbresgraphes/tp_graphe_matrice_capytale.html#implémentation-simple",
    "title": "TP - Implémentation des graphes par matrice d’adjacence",
    "section": "Implémentation simple",
    "text": "Implémentation simple\nQuestion 1 : Fonction permettant de créer un graphe comportant \\(n\\) sommets et pas d’arêtes.\n\ndef make_graph(n: int) -&gt; list:\n    \"\"\"Crée la matrice d'adjacence d'un graphe de n sommets sans arêtes\"\"\"\n    g = []\n    # Compléter ci dessous\n    \n    return g\n\n\n# Test de la fonction make_graph\n\ng = make_graph(5)\nprint(g)\n\nQuestion 2 : Fonction permettant d’ajouter une arête entre les sommets \\(i\\) et \\(j\\).\n\ndef add_edge(g: list, i: int, j: int) -&gt; None:\n    \"\"\"Ajoute l'arête (i,j) au graphe g\"\"\"\n    pass\n\nQuestion 3 - Application : en utilisant les deux fonctions précédentes, créer une variable g représentant le graphe suivant :\n\n\n\ngraphe 1\n\n\n\n# Entrer votre code ici\n\n\n# Vérification\nassert g == [[1, 1, 1, 0, 0], [1, 0, 1, 1, 0], [1, 1, 0, 1, 1], [0, 1, 1, 0, 1], [0, 0, 1, 1, 0]]\nprint(\"Test réussi !\")\n\nQuestion 4 : Compléter la fonction remove_edge permettant de supprimer une arête entre les sommets \\(i\\) et \\(j\\).\n\ndef remove_edge(g: list, i: int, j: int) -&gt; None:\n    \"\"\"Supprime l'arête (i,j) du graphe g\"\"\"\n    pass\n\n\n# Test de la fonction remove_edge\nfrom copy import deepcopy\n\nh = deepcopy(g)\nremove_edge(h, 0, 1)\nassert h == [[1, 0, 1, 0, 0], [0, 0, 1, 1, 0], [1, 1, 0, 1, 1], [0, 1, 1, 0, 1], [0, 0, 1, 1, 0]]\nprint(\"Test réussi !\")\n\nQuestion 5 : Compléter les fonctions add_vertex et remove_vertex permettant d’ajouter un sommet et de supprimer un sommet dans un graphe. On rappelle que les sommets sont des entiers successifs. Par exemple, si on supprime le sommet \\(2\\), les sommets \\(3\\) et \\(4\\) deviennent les sommets \\(2\\) et \\(3\\). Par ailleurs, le sommet ajouté par la fonction add_vertex doit être le plus grand sommet du graphe.\n\ndef add_vertex(g: list) -&gt; None:\n    \"\"\"Ajoute un sommet à un graphe g\"\"\"\n    pass\n\ndef remove_vertex(g: list, i: int) -&gt; None:\n    \"\"\"Supprime le sommet i du graphe g\"\"\"\n    pass\n\n\n# Test de la fonction add_vertex\nh = deepcopy(g)\nadd_vertex(h)\nassert h == [[1, 1, 1, 0, 0, 0], [1, 0, 1, 1, 0, 0], [1, 1, 0, 1, 1, 0], [0, 1, 1, 0, 1, 0], [0, 0, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0]]\nprint(\"Test réussi !\")\n\n\n# Test de la fonction remove_vertex\nremove_vertex(h, 5)\nassert h == [[1, 1, 1, 0, 0], [1, 0, 1, 1, 0], [1, 1, 0, 1, 1], [0, 1, 1, 0, 1], [0, 0, 1, 1, 0]]\nprint(\"Test réussi !\")\n\nQuestion 6 : Compléter la fonction est_adjacent qui prend en paramètre un graphe g et deux sommets i et j et qui renvoie True si les sommets sont adjacents et False sinon.\n\ndef is_adjacent(g: list, i: int, j: int) -&gt; bool:\n    \"\"\"Renvoie True si les sommets i et j sont adjacents, False sinon\"\"\"\n    pass\n\n\n# Test de la fonction is_adjacent\nassert is_adjacent(g, 0, 1) == True\nassert is_adjacent(g, 0, 4) == False\nprint(\"Test réussi !\")\n\nQuestion 7 : Compléter la fonction neighbors qui prend en paramètre un graphe g et un sommet i et qui renvoie la liste des sommets adjacents au sommet i, puis la fonction degree qui prend en paramètre un graphe g et un sommet i et qui renvoie le degré du sommet i.\n\ndef neighbors(g: list, i: int) -&gt; list:\n    \"\"\"Renvoie la liste des sommets autres que i \n       adjacents au sommet i\"\"\"\n    pass\n\ndef degree(g: list, i: int) -&gt; int:\n    \"\"\"Renvoie le degré du sommet i\"\"\"\n    pass\n\n\n# Test de la fonction neighbors\nassert neighbors(g, 0) == [1, 2]\nassert neighbors(g, 1) == [0, 2, 3]\n\n# Test de la fonction degree\nassert degree(g, 0) == 2\nassert degree(g, 1) == 3\nprint(\"Test réussi !\")"
  },
  {
    "objectID": "arbresgraphes/tp_graphe_matrice_capytale.html#implémentation-objet",
    "href": "arbresgraphes/tp_graphe_matrice_capytale.html#implémentation-objet",
    "title": "TP - Implémentation des graphes par matrice d’adjacence",
    "section": "Implémentation objet",
    "text": "Implémentation objet\nQuestion 8 : Créer une classe Graph permettant de représenter un graphe sous la forme d’une matrice d’adjacence, en reformulant les fonctions définies dans la partie précédente. Cette classe doit contenir les attributs suivants :\n\norder : nombre de sommets du graphe\nmatrix : matrice d’adjacence du graphe\n\nCette classe doit contenir les méthodes suivantes :\n\n__init__ : constructeur de la classe\nadd_edge : ajoute une arête entre les sommets i et j\nremove_edge : supprime une arête entre les sommets i et j\nadd_vertex : ajoute un sommet au graphe\nremove_vertex : supprime un sommet du graphe\nis_adjacent : renvoie True si les sommets i et j sont adjacents et False sinon\nneighbors : renvoie la liste des sommets adjacents au sommet i\ndegree : renvoie le degré du sommet i\n__str__ : renvoie une chaîne de caractères représentant le graphe en affichant les lignes de la matrice d’adjacence l’une en dessous de l’autre.\n\n\nclass Graph:\n\n    pass\n\nQuestion 9 - Application : en utilisant la classe Graph, créer une variable g représentant le graphe suivant :\n\n\n\ngraphe 2\n\n\nDéterminer la liste des voisins du sommet \\(2\\).\n\n# Entrer votre code ici\n\nBonus : Implémenter une fonction draw_graph permettant de dessiner un graphe à partir de sa matrice d’adjacence.\nPour cela, on utilisera le module networkx qui est spécialisé dans l’analyse des graphes. Il s’agit donc de définir un graphe de type networkx à partir de la matrice d’adjacence du graphe et de le dessiner à l’aide de la fonction draw du module networkx.\n\n# Imports nécessaires\nimport networkx as nx\n\nQuelques commandes utiles :\n\ng = nx.Graph() : création d’un graphe vide\ng.add_node(i) : ajoute le sommet i au graphe g\ng.add_edge(i,j) : ajoute une arête entre les sommets i et j\nnx.draw(g) : dessine le graphe g\n\n\ndef draw_graph(g: Graph) -&gt; None:\n    \"\"\"Dessine le graphe g\"\"\"\n    # Création du graphe\n    G = nx.Graph()\n    # Compléter ci-dessous pour définir un graphe G au format nx correspondant à g\n\n    \n    # Dessin du graphe\n    nx.draw(G, with_labels=True, node_color='white', font_size=18, edgecolors='black', node_size=500)\n\n\n# Vérification de la fonction draw_graph\ndraw_graph(g)"
  },
  {
    "objectID": "arbresgraphes/tp_graphe_matrice_CORR.html",
    "href": "arbresgraphes/tp_graphe_matrice_CORR.html",
    "title": "TP - Implémentation des graphes par matrice d’adjacence",
    "section": "",
    "text": "On considère un graphe \\(G\\) dont les sommets sont les entiers de \\(0\\) à \\(n-1\\) et les arêtes sont les couples d’entiers \\((i,j)\\) avec \\(0\\leq i,j\\leq n-1\\).\nL’objectif de ce TP est d’implémenter les graphes en python par matrice d’adjacence.\nOn considère ici que les graphes sont non orientés."
  },
  {
    "objectID": "arbresgraphes/tp_graphe_matrice_CORR.html#implémentation-simple",
    "href": "arbresgraphes/tp_graphe_matrice_CORR.html#implémentation-simple",
    "title": "TP - Implémentation des graphes par matrice d’adjacence",
    "section": "Implémentation simple",
    "text": "Implémentation simple\nQuestion 1 : Fonction permettant de créer un graphe comportant \\(n\\) sommets et pas d’arêtes.\n\ndef make_graph(n: int) -&gt; list:\n    \"\"\"Crée la matrice d'adjacence d'un graphe de n sommets sans arêtes\"\"\"\n    g = []\n    for i in range(n):\n        line = [0 for j in range(n)]\n        g.append(line)\n    return g\n\n\n# Test de la fonction make_graph\n\ng = make_graph(5)\nprint(g)\n\n[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]\n\n\nQuestion 2 : Fonction permettant d’ajouter une arête entre les sommets \\(i\\) et \\(j\\).\n\ndef add_edge(g: list, i: int, j: int) -&gt; None:\n    \"\"\"Ajoute l'arête (i,j) au graphe g\"\"\"\n    g[i][j] = 1\n    g[j][i] = 1\n\nQuestion 3 - Application : en utilisant les deux fonctions précédentes, créer une variable g représentant le graphe suivant :\n\n\n\ngraphe 1\n\n\n\n# Entrer votre code ici\ng = make_graph(5)\nadd_edge(g, 0, 0)\nadd_edge(g, 0, 1)\nadd_edge(g, 0, 2)\nadd_edge(g, 1, 2)\nadd_edge(g, 1, 3)\nadd_edge(g, 2, 3)\nadd_edge(g, 2, 4)\nadd_edge(g, 3, 4)\nprint(g)\n\n[[1, 1, 1, 0, 0], [1, 0, 1, 1, 0], [1, 1, 0, 1, 1], [0, 1, 1, 0, 1], [0, 0, 1, 1, 0]]\n\n\n\n# Vérification\nassert g == [[1, 1, 1, 0, 0], [1, 0, 1, 1, 0], [1, 1, 0, 1, 1], [0, 1, 1, 0, 1], [0, 0, 1, 1, 0]]\nprint(\"Test réussi !\")\n\nTest réussi !\n\n\nQuestion 4 : Compléter la fonction remove_edge permettant de supprimer une arête entre les sommets \\(i\\) et \\(j\\).\n\ndef remove_edge(g: list, i: int, j: int) -&gt; None:\n    \"\"\"Supprime l'arête (i,j) du graphe g\"\"\"\n    g[i][j] = 0\n    g[j][i] = 0\n\n\n# Test de la fonction remove_edge\nfrom copy import deepcopy\n\nh = deepcopy(g)\nremove_edge(h, 0, 1)\nassert h == [[1, 0, 1, 0, 0], [0, 0, 1, 1, 0], [1, 1, 0, 1, 1], [0, 1, 1, 0, 1], [0, 0, 1, 1, 0]]\nprint(\"Test réussi !\")\n\nTest réussi !\n\n\nQuestion 5 : Compléter les fonctions add_vertex et remove_vertex permettant d’ajouter un sommet et de supprimer un sommet dans un graphe. On rappelle que les sommets sont des entiers successifs. Par exemple, si on supprime le sommet \\(2\\), les sommets \\(3\\) et \\(4\\) deviennent les sommets \\(2\\) et \\(3\\). Par ailleurs, le sommet ajouté par la fonction add_vertex doit être le plus grand sommet du graphe.\n\ndef add_vertex(g: list) -&gt; None:\n    \"\"\"Ajoute un sommet à un graphe g\"\"\"\n    n = len(g)\n    line = [0 for j in range(n+1)]\n    g.append(line)\n    for i in range(n):\n        g[i].append(0)\n\ndef remove_vertex(g: list, i: int) -&gt; None:\n    \"\"\"Supprime le sommet i du graphe g\"\"\"\n    n = len(g)\n    if i &lt; 0 or i &gt;= n:\n        raise IndexError\n    else:\n        for j in range(n):\n            g[j].pop(i)\n        g.pop(i)\n\n\n# Test de la fonction add_vertex\nh = deepcopy(g)\nadd_vertex(h)\nassert h == [[1, 1, 1, 0, 0, 0], [1, 0, 1, 1, 0, 0], [1, 1, 0, 1, 1, 0], [0, 1, 1, 0, 1, 0], [0, 0, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0]]\nprint(\"Test réussi !\")\n\nTest réussi !\n\n\n\n# Test de la fonction remove_vertex\nremove_vertex(h, 5)\nassert h == [[1, 1, 1, 0, 0], [1, 0, 1, 1, 0], [1, 1, 0, 1, 1], [0, 1, 1, 0, 1], [0, 0, 1, 1, 0]]\nprint(\"Test réussi !\")\n\nTest réussi !\n\n\nQuestion 6 : Compléter la fonction est_adjacent qui prend en paramètre un graphe g et deux sommets i et j et qui renvoie True si les sommets sont adjacents et False sinon.\n\ndef is_adjacent(g: list, i: int, j: int) -&gt; bool:\n    \"\"\"Renvoie True si les sommets i et j sont adjacents, False sinon\"\"\"\n    return g[i][j] == 1\n\n\n# Test de la fonction is_adjacent\nassert is_adjacent(g, 0, 1) == True\nassert is_adjacent(g, 0, 4) == False\nprint(\"Test réussi !\")\n\nTest réussi !\n\n\nQuestion 7 : Compléter la fonction neighbors qui prend en paramètre un graphe g et un sommet i et qui renvoie la liste des sommets adjacents au sommet i, puis la fonction degree qui prend en paramètre un graphe g et un sommet i et qui renvoie le degré du sommet i.\n\ndef neighbors(g: list, i: int) -&gt; list:\n    \"\"\"Renvoie la liste des sommets autres que i \n       adjacents au sommet i\"\"\"\n    n = []\n    for j in range(len(g)):\n        if is_adjacent(g, i, j) and i!=j :\n            n.append(j)\n    return n\n\ndef degree(g: list, i: int) -&gt; int:\n    \"\"\"Renvoie le degré du sommet i\"\"\"\n    return len(neighbors(g, i))\n\n\n# Test de la fonction neighbors\nassert neighbors(g, 0) == [1, 2]\nassert neighbors(g, 1) == [0, 2, 3]\n\n# Test de la fonction degree\nassert degree(g, 0) == 2\nassert degree(g, 1) == 3\nprint(\"Test réussi !\")\n\nTest réussi !"
  },
  {
    "objectID": "arbresgraphes/tp_graphe_matrice_CORR.html#implémentation-objet",
    "href": "arbresgraphes/tp_graphe_matrice_CORR.html#implémentation-objet",
    "title": "TP - Implémentation des graphes par matrice d’adjacence",
    "section": "Implémentation objet",
    "text": "Implémentation objet\nQuestion 8 : Créer une classe Graph permettant de représenter un graphe sous la forme d’une matrice d’adjacence, en reformulant les fonctions définies dans la partie précédente. Cette classe doit contenir les attributs suivants :\n\norder : nombre de sommets du graphe\nmatrix : matrice d’adjacence du graphe\n\nCette classe doit contenir les méthodes suivantes :\n\n__init__ : constructeur de la classe\nadd_edge : ajoute une arête entre les sommets i et j\nremove_edge : supprime une arête entre les sommets i et j\nadd_vertex : ajoute un sommet au graphe\nremove_vertex : supprime un sommet du graphe\nis_adjacent : renvoie True si les sommets i et j sont adjacents et False sinon\nneighbors : renvoie la liste des sommets adjacents au sommet i\ndegree : renvoie le degré du sommet i\n__str__ : renvoie une chaîne de caractères représentant le graphe en affichant les lignes de la matrice d’adjacence l’une en dessous de l’autre.\n\n\nclass Graph:\n\n    def __init__(self, n: int):\n        \"\"\"Crée un graphe de n sommets sans arêtes\"\"\"\n        self.order = n\n        self.matrix = make_graph(n)\n\n    def add_edge(self, i: int, j: int) -&gt; None:\n        \"\"\"Ajoute l'arête (i,j) au graphe\"\"\"\n        add_edge(self.matrix, i, j)\n\n    def remove_edge(self, i: int, j: int) -&gt; None:\n        \"\"\"Supprime l'arête (i,j) du graphe\"\"\"\n        remove_edge(self.matrix, i, j)\n\n    def add_vertex(self) -&gt; None:\n        \"\"\"Ajoute un sommet au graphe\"\"\"\n        add_vertex(self.matrix)\n\n    def remove_vertex(self, i: int) -&gt; None:\n        \"\"\"Supprime le sommet i du graphe\"\"\"\n        remove_vertex(self.matrix, i)\n\n    def is_adjacent(self, i: int, j: int) -&gt; bool:\n        \"\"\"Renvoie True si les sommets i et j sont adjacents, False sinon\"\"\"\n        return is_adjacent(self.matrix, i, j)\n\n    def neighbors(self, i: int) -&gt; list:\n        \"\"\"Renvoie la liste des sommets adjacents au sommet i\"\"\"\n        return neighbors(self.matrix, i)\n    \n    def degree(self, i: int) -&gt; int:\n        \"\"\"Renvoie le degré du sommet i\"\"\"\n        return degree(self.matrix, i)\n\n    def __str__(self):\n        \"\"\"Affiche le graphe\"\"\"\n        rep = \"\"\n        for line in self.matrix:\n            rep += str(line) + \"\\n\"\n        return rep\n\nQuestion 9 - Application : en utilisant la classe Graph, créer une variable g représentant le graphe suivant :\n\n\n\ngraphe 2\n\n\nDéterminer la liste des voisins du sommet \\(2\\).\n\n# Entrer votre code ici\ng = Graph(7)\ng.add_edge(0, 6)\ng.add_edge(1, 2)\ng.add_edge(1, 3)\ng.add_edge(1, 4)\ng.add_edge(2, 4)\ng.add_edge(2, 5)\ng.add_edge(3, 4)\n\ng.neighbors(2)\n\n[1, 4, 5]\n\n\nBonus : Implémenter une fonction draw_graph permettant de dessiner un graphe à partir de sa matrice d’adjacence.\nPour cela, on utilisera le module networkx qui est spécialisé dans l’analyse des graphes. Il s’agit donc de définir un graphe de type networkx à partir de la matrice d’adjacence du graphe et de le dessiner à l’aide de la fonction draw du module networkx.\n\n# Imports nécessaires\nimport networkx as nx\n\nQuelques commandes utiles :\n\ng = nx.Graph() : création d’un graphe vide\ng.add_node(i) : ajoute le sommet i au graphe g\ng.add_edge(i,j) : ajoute une arête entre les sommets i et j\nnx.draw(g) : dessine le graphe g\n\n\ndef draw_graph(g: Graph) -&gt; None:\n    \"\"\"Dessine le graphe g\"\"\"\n    # Création du graphe\n    G = nx.Graph()\n    for i in range(g.order):\n        G.add_node(i)\n    for i in range(g.order):\n        for j in range(i+1, g.order):\n            if g.is_adjacent(i, j):\n                G.add_edge(i, j)\n    # Dessin du graphe\n    nx.draw(G, with_labels=True, node_color='white', font_size=18, edgecolors='black', node_size=500)\n\n\n# Vérification de la fonction draw_graph\ndraw_graph(g)"
  },
  {
    "objectID": "bac/2023_CE_J1_corrige.html",
    "href": "bac/2023_CE_J1_corrige.html",
    "title": "Centres étrangers 2023 Jour 1",
    "section": "",
    "text": "Schéma relationnel de la relation description (la clé primaire est soulignée et la clé étrangère est précédée du symbole #):\ndescription(id_description : INT, resume : TEXT, duree : INT, #id_emission : INT)\n\nLa requête affiche le résultat suivant :\n\n\n\n\n\n\n\n\ntheme\nannee\n\n\n\n\nLe système d’enseignement supérieur français est-il juste et efficace ?\n2022\n\n\nTrois innovations pour la croissance future (1/3) : La révolution blockchain\n2021\n\n\n\n\nRequête permettant d’afficher les thèmes des podcasts de l’année 2019 :\n\nSELECT theme\nFROM podcast\nWHERE annee = 2019\n\nRequête permettant d’afficher la liste des thèmes et des années de diffusion des podcasts dans l’ordre chronologique des années :\n\nSELECT theme, annee\nFROM podcast\nORDER BY annee\n\nLa requête proposée affiche la liste de tous les thèmes de la relation podcast sans répétition.\nRequête SQL supprimant la ligne contenant l’id_podcast = 40 de la relation podcast :\n\nDELETE FROM podcast\nWHERE id_podcast = 40\n\nRequête SQL permettant de changer le nom de l’animateur de l’émission “Le Temps de débat” en “Emmanuel L”.\nUPDATE emission\nSET animateur = \"Emmanuel L\"\nWHERE nom = \"Le Temps de débat\"\nRequête SQL permettant d’ajouter l’émission “Hashtag” sur la radio “France inter” avec “Mathieu V.”, avec un id_emission égal à 12850.\nINSERT INTO emission (id_emission, nom, radio, animateur)\nVALUES (12850, \"Hashtag\", \"France inter\", \"Mathieu V.\")\n\nRequête permettant de lister les thèmes, le nom des émissions et le résumé des podcasts pour lesquels la durée est strictement inférieure à 5 minutes.\nSELECT podcast.theme, emission.nom, description.resume\nFROM podcast\nJOIN emission ON podcast.id_emission = emission.id_emission\nJOIN description ON emission.id_emission = description.id_emission\nWHERE description.duree &lt; 5\n\n\n\n\n\n\n\nImportant\n\n\n\nLa base de donnée telle que définie dans l’énoncé n’est bien construite. Chaque description est en-effet reliée à une émission unique à travers la clé étrangère id_emission, mais pas au podcast correspondant. Comme il existe plusieurs podcasts pour une émission, il n’y a pas moyen de savoir à quel podcast correspond quelle description."
  },
  {
    "objectID": "bac/2023_CE_J1_corrige.html#exercice-1",
    "href": "bac/2023_CE_J1_corrige.html#exercice-1",
    "title": "Centres étrangers 2023 Jour 1",
    "section": "",
    "text": "Schéma relationnel de la relation description (la clé primaire est soulignée et la clé étrangère est précédée du symbole #):\ndescription(id_description : INT, resume : TEXT, duree : INT, #id_emission : INT)\n\nLa requête affiche le résultat suivant :\n\n\n\n\n\n\n\n\ntheme\nannee\n\n\n\n\nLe système d’enseignement supérieur français est-il juste et efficace ?\n2022\n\n\nTrois innovations pour la croissance future (1/3) : La révolution blockchain\n2021\n\n\n\n\nRequête permettant d’afficher les thèmes des podcasts de l’année 2019 :\n\nSELECT theme\nFROM podcast\nWHERE annee = 2019\n\nRequête permettant d’afficher la liste des thèmes et des années de diffusion des podcasts dans l’ordre chronologique des années :\n\nSELECT theme, annee\nFROM podcast\nORDER BY annee\n\nLa requête proposée affiche la liste de tous les thèmes de la relation podcast sans répétition.\nRequête SQL supprimant la ligne contenant l’id_podcast = 40 de la relation podcast :\n\nDELETE FROM podcast\nWHERE id_podcast = 40\n\nRequête SQL permettant de changer le nom de l’animateur de l’émission “Le Temps de débat” en “Emmanuel L”.\nUPDATE emission\nSET animateur = \"Emmanuel L\"\nWHERE nom = \"Le Temps de débat\"\nRequête SQL permettant d’ajouter l’émission “Hashtag” sur la radio “France inter” avec “Mathieu V.”, avec un id_emission égal à 12850.\nINSERT INTO emission (id_emission, nom, radio, animateur)\nVALUES (12850, \"Hashtag\", \"France inter\", \"Mathieu V.\")\n\nRequête permettant de lister les thèmes, le nom des émissions et le résumé des podcasts pour lesquels la durée est strictement inférieure à 5 minutes.\nSELECT podcast.theme, emission.nom, description.resume\nFROM podcast\nJOIN emission ON podcast.id_emission = emission.id_emission\nJOIN description ON emission.id_emission = description.id_emission\nWHERE description.duree &lt; 5\n\n\n\n\n\n\n\nImportant\n\n\n\nLa base de donnée telle que définie dans l’énoncé n’est bien construite. Chaque description est en-effet reliée à une émission unique à travers la clé étrangère id_emission, mais pas au podcast correspondant. Comme il existe plusieurs podcasts pour une émission, il n’y a pas moyen de savoir à quel podcast correspond quelle description."
  },
  {
    "objectID": "bac/2023_CE_J1_corrige.html#exercice-2",
    "href": "bac/2023_CE_J1_corrige.html#exercice-2",
    "title": "Centres étrangers 2023 Jour 1",
    "section": "Exercice 2",
    "text": "Exercice 2\n\n\nOn convertit les entiers 2 et 13 en binaire sur 8 bits :\n\n\n\n\n2\n13\n\n\n\n\n00000010\n00001101\n\n\n\nL’adresse IP 164.178.2.13 est donc représentée par la chaîne de caractères :\n10100100.10110010.00000010.00001101\n\nL’adresse IP indique que les 24 premiers bits sont réservés à l’identifiant du réseau et les 8 derniers bits sont réservés à l’identifiant de l’hôte. La machine appartient donc au réseau dont l’adresse est 164.178.2.0\n\nPour un paquet émis par A à destination de G, les chemins optimaux en suivant le protocole RIP sont ceux qui minimisent le nombre se sauts :\n\n\n\nChemin\nNombre de sauts\n\n\n\n\nA -&gt; B -&gt; C -&gt; H -&gt; G\n4\n\n\nA -&gt; B -&gt; E -&gt; G\n3\n\n\nA -&gt; D -&gt; E -&gt; G\n3\n\n\nA -&gt; D -&gt; F -&gt; G\n3\n\n\n\nLes chemins optimaux sont donc A -&gt; B -&gt; E -&gt; G, A -&gt; D -&gt; E -&gt; G et A -&gt; D -&gt; F -&gt; G.\n\nLe coût d’une liaison Ethernet est \\(\\frac{10^9}{10^8}=10\\), celui d’une liaison Fast-Ethernet est \\(\\frac{10^9}{10^9}=1\\) et celui d’une liaison fibre est \\(\\frac{10^9}{10^{10}}=0.1\\)\n\n\n\nNous pouvons déterminer le chemin de parcours en utilisant l’algorithme de Dijkstra.\n\n\n\nA\nB\nC\nD\nE\nF\nG\nH\nchoix\n\n\n\n\n0-A\n-\n-\n-\n-\n-\n-\n-\nA(0)\n\n\nX\n1-A\n-\n10-A\n-\n-\n-\n-\nB(1)\n\n\nX\nX\n11-B\n10-A\n11-B\n-\n-\n-\nD(10)\n\n\nX\nX\n11-B\nX\n10.1-D\n11-D\n-\n-\nE(10.1)\n\n\nX\nX\n11-B\nX\nX\n11-D\n20.1-E\n-\nC(11) ou F(11)\n\n\nX\nX\nX\nX\nX\nX\n12-F\n11.1-C\nH(11.1)\n\n\nX\nX\nX\nX\nX\nX\n12-F\nX\nG(12)\n\n\n\nLe chemin optimal est donc A -&gt; D -&gt; F -&gt; G de coût total 12.\nLe routeur F est en panne. Nous appliquons l’algorithme de Dijkstra en supprimant le routeur F\n\n\n\nA\nB\nC\nD\nE\nG\nH\nchoix\n\n\n\n\n0-A\n-\n-\n-\n-\n-\n-\nA(0)\n\n\nX\n1-A\n-\n10-A\n-\n-\n-\nB(1)\n\n\nX\nX\n11-B\n10-A\n11-B\n-\n-\nD(10)\n\n\nX\nX\n11-B\nX\n10.1-D\n-\n-\nE(10.1)\n\n\nX\nX\n11-B\nX\nX\n20.1-E\n-\nC(11)\n\n\nX\nX\nX\nX\nX\n20.1-E\n11.1-C\nH(11.1)\n\n\nX\nX\nX\nX\nX\n12.1-H\nX\nG(12.1)\n\n\n\nLe chemin optimal est donc A -&gt; B -&gt; C -&gt; H -&gt; G de coût total 12.1."
  },
  {
    "objectID": "bac/2023_CE_J1_corrige.html#exercice-3",
    "href": "bac/2023_CE_J1_corrige.html#exercice-3",
    "title": "Centres étrangers 2023 Jour 1",
    "section": "Exercice 3",
    "text": "Exercice 3\n\nFonction permettant l’ajout d’une couleur aléatoire dans la file f :\ndef ajout(f):\n    couleurs = (\"bleu\", \"rouge\", \"jaune\", \"vert\")\n    indice = randint(0, 3)\n    enfiler(f, couleurs[indice])\n    return f\nFonction permettant de vider la séquence f :\ndef vider(f):\n    while not est_vide(f):\n        defiler(f)\nFonction affich_seq complétée :\ndef affich_seq(sequence):\n    stock = creer_file_vide()\n    ajout(sequence)\n    while not est_vide(sequence):\n        c = defiler(sequence)\n        affichage(c)\n        time.sleep(0.5)\n        enfiler(stock, c)\n    while not est_vide(stock):\n        enfiler(sequence, defiler(stock))\n\nFonction tour_de_jeu complétée :\n\ndef tour_de_jeu(sequence):\n    affich_seq(sequence) # zone A\n    stock = creer_file_vide()\n    while not est_vide(sequence):\n        c_joueur = saisie_joueur()\n        c_seq = defiler(sequence) # zone B\n        if c_joueur == c_seq:\n            enfiler(stock, c_seq) # zone C\n        else:\n            vider(sequence) # zone D\n    while not est_vide(stock): # zone E\n        enfiler(sequence, defiler(stock)) # zone F\n\nFonction modifiée :\n\n\ndef tour_de_jeu(sequence):\n    affich_seq(sequence) # zone A\n    stock = creer_file_vide()\n    gagne = True\n    while not est_vide(sequence):\n        c_joueur = saisie_joueur()\n        c_seq = defiler(sequence) # zone B\n        if c_joueur == c_seq:\n            enfiler(stock, c_seq) # zone C\n        else:\n            vider(sequence) # zone D\n            gagne = False\n    while not est_vide(stock): # zone E\n        enfiler(sequence, defiler(stock)) # zone F\n    if gagne:\n        tour_de_jeu(sequence)\n    else:\n        vider(sequence)\n        ajout(sequence)\n        tour_de_jeu(sequence)"
  },
  {
    "objectID": "bac/2023_CE_J2_corrige.html",
    "href": "bac/2023_CE_J2_corrige.html",
    "title": "Centres étrangers 2023 Jour 2",
    "section": "",
    "text": "Toute adresse IP du type 192.168.5.XYZ avec XYZ différente de 000, 255 et 003 est valide pour le routeur F. En effet, l’adresse 192.168.5.0 est celle du réseau lui-même, l’adresse 192.168.5.255 correspond en général à l’adresse de diffusion et l’adresse 192.168.5.3 est déjà utilisée par une machine. On peut donc par exemple affecter l’adresse 192.168.5.1 au routeur F.\nEn tenant compte des remarques précédentes, XYZ peut prendre les valeurs de 1 à 254. Il y a donc 254 adresses IP valides pour le réseau F.\n\n\nLe masque de sous-réseau du réseau B est 255.255.240.0.\nUne des machine du réseau B a pour adresse IP 192.168.2.2. Pour déterminer le masque de sous-réseau, on convertit ces adresses en binaire. On obtient alors 11000000.10101000.00000010.00000010 pour la machine et 11111111.11111111.11110000.00000000 pour le masque. En effectuant un ET logique bit à bit, on obtient 11000000.10101000.00000000.00000000 qui correspond à l’adresse du réseau B. On peut donc conclure que le masque de sous-réseau du réseau B est 192.168.0.0.\nL’interconnexion entre les routeurs A, B, E et F permet, en cas de défaillance de l’un d’entre eux, de maintenir la liaison entre toutes les machines représentées sur le schéma.\n\n\n\n\n\n\n\nIl existe un chemin de longueur 2 entre le routeur A et le routeur E : A - B - E. Il s’agit du plus cours chemin possible en terme de nombre de sauts. Pour aller de F vers B, il existe plusieurs chemins optimaux en termes de nombre de sauts. Ce sont tous les chemins de longueur 3 : F - D - A - B, F - H - G - B et F - H - E - B.\n\nTable de routage du routeur E\n\n\nDestination\nRouteur suivant\nDistance\n\n\n\n\nA\nB\n2\n\n\nB\nB\n1\n\n\nC\nH\n2\n\n\nD\nG\n2\n\n\nE\nE\n0\n\n\nF\nH\n2\n\n\nG\nG\n1\n\n\nH\nH\n1\n\n\n\n\nTable de routage du routeur G\n\n\nDestination\nRouteur suivant\nDistance\n\n\n\n\nA\nB\n2\n\n\nB\nB\n1\n\n\nC\nD\n1\n\n\nD\nD\n1\n\n\nE\nE\n1\n\n\nF\nD\n2\n\n\nG\nG\n0\n\n\nH\nH\n1\n\n\n\n\n\n\nTable de routage du routeur F\n\n\nDestination\nRouteur suivant\nCoût total\n\n\n\n\nA\nD\n1.1\n\n\nB\nH\n10.11\n\n\nC\nD\n1.1\n\n\nD\nD\n0.1\n\n\nE\nH\n10.1\n\n\nG\nD\n1.1\n\n\nH\nH\n0.1\n\n\n\nEntre le routeur E et le routeur D, le chemin optimal est E - H - F - D, dont le coût total est de 10.2."
  },
  {
    "objectID": "bac/2023_CE_J2_corrige.html#exercice-1",
    "href": "bac/2023_CE_J2_corrige.html#exercice-1",
    "title": "Centres étrangers 2023 Jour 2",
    "section": "",
    "text": "Toute adresse IP du type 192.168.5.XYZ avec XYZ différente de 000, 255 et 003 est valide pour le routeur F. En effet, l’adresse 192.168.5.0 est celle du réseau lui-même, l’adresse 192.168.5.255 correspond en général à l’adresse de diffusion et l’adresse 192.168.5.3 est déjà utilisée par une machine. On peut donc par exemple affecter l’adresse 192.168.5.1 au routeur F.\nEn tenant compte des remarques précédentes, XYZ peut prendre les valeurs de 1 à 254. Il y a donc 254 adresses IP valides pour le réseau F.\n\n\nLe masque de sous-réseau du réseau B est 255.255.240.0.\nUne des machine du réseau B a pour adresse IP 192.168.2.2. Pour déterminer le masque de sous-réseau, on convertit ces adresses en binaire. On obtient alors 11000000.10101000.00000010.00000010 pour la machine et 11111111.11111111.11110000.00000000 pour le masque. En effectuant un ET logique bit à bit, on obtient 11000000.10101000.00000000.00000000 qui correspond à l’adresse du réseau B. On peut donc conclure que le masque de sous-réseau du réseau B est 192.168.0.0.\nL’interconnexion entre les routeurs A, B, E et F permet, en cas de défaillance de l’un d’entre eux, de maintenir la liaison entre toutes les machines représentées sur le schéma.\n\n\n\n\n\n\n\nIl existe un chemin de longueur 2 entre le routeur A et le routeur E : A - B - E. Il s’agit du plus cours chemin possible en terme de nombre de sauts. Pour aller de F vers B, il existe plusieurs chemins optimaux en termes de nombre de sauts. Ce sont tous les chemins de longueur 3 : F - D - A - B, F - H - G - B et F - H - E - B.\n\nTable de routage du routeur E\n\n\nDestination\nRouteur suivant\nDistance\n\n\n\n\nA\nB\n2\n\n\nB\nB\n1\n\n\nC\nH\n2\n\n\nD\nG\n2\n\n\nE\nE\n0\n\n\nF\nH\n2\n\n\nG\nG\n1\n\n\nH\nH\n1\n\n\n\n\nTable de routage du routeur G\n\n\nDestination\nRouteur suivant\nDistance\n\n\n\n\nA\nB\n2\n\n\nB\nB\n1\n\n\nC\nD\n1\n\n\nD\nD\n1\n\n\nE\nE\n1\n\n\nF\nD\n2\n\n\nG\nG\n0\n\n\nH\nH\n1\n\n\n\n\n\n\nTable de routage du routeur F\n\n\nDestination\nRouteur suivant\nCoût total\n\n\n\n\nA\nD\n1.1\n\n\nB\nH\n10.11\n\n\nC\nD\n1.1\n\n\nD\nD\n0.1\n\n\nE\nH\n10.1\n\n\nG\nD\n1.1\n\n\nH\nH\n0.1\n\n\n\nEntre le routeur E et le routeur D, le chemin optimal est E - H - F - D, dont le coût total est de 10.2."
  },
  {
    "objectID": "bac/2023_CE_J2_corrige.html#exercice-2",
    "href": "bac/2023_CE_J2_corrige.html#exercice-2",
    "title": "Centres étrangers 2023 Jour 2",
    "section": "Exercice 2",
    "text": "Exercice 2\n\n\nLe résultat de la requête est le suivant :\n\n\n\n\nage\ntaille\npoids\n\n\n\n\n6\n1.70\n100\n\n\n\n\nLa requête est la suivante :\n\nSELECT nom, age \nFROM animal\nWHERE nom_espece = 'bonobo'\nORDER BY age\n\nL’attribut nom_espece peut vraisemblablement servir de clé primaire pour la relation espece car deux espèces différentes doivent avoir des noms différents. L’attribut num_enclos est une clé étrangère relative à la clé primaire num_enclos de la relation enclos.\nSchéma relationnel de la base de données :\n\nanimal(id_animal : INT, nom : VARCHAR, age : INT, taille : FLOAT, poids : INT, #nom_espece : VARCHAR)\nenclos(num_enclos : INT, ecosysteme : VARCHAR, surface : INT, struct : VARCHAR, date_entretien : DATE)\nespece(nom_espece : VARCHAR, classe : VARCHAR, alimentation : VARCHAR, #num_enclos : INT)\n\n\n\nLa requête suivante corrige l’erreur signalée :\n\nUPDATE espece\nSET classe='mammifères'\nWHERE nom_espece='ornithorynque'\n\nLa requête suivante permet d’intégrer le nouveau venu dans la base de données :\n\nINSERT INTO animal VALUES (179, 'Serge', 0, 0.8, 30, 'lama')\n\nRequête permettant de recenser le nom et l’espèce de tous les animaux carnivores vivant en vivarium dans le zoo :\n\nSELECT nom, nom_espece\nFROM animal\nJOIN espece ON animal.nom_espece = espece.nom_espece\nJOIN enclos ON espece.num_enclos = enclos.num_enclos\nWHERE enclos.struct = 'vivarium' and espece.alimentation = 'carnivore'\n\nRequête permettant de connaître le nombre d’oiseaux dans tout le zoo :\n\nSELECT COUNT(*)\nFROM animal\nJOIN espece ON animal.nom_espece = espece.nom_espece\nWHERE espece.classe = 'oiseau'"
  },
  {
    "objectID": "bac/2023_CE_J2_corrige.html#exercice-3",
    "href": "bac/2023_CE_J2_corrige.html#exercice-3",
    "title": "Centres étrangers 2023 Jour 2",
    "section": "Exercice 3",
    "text": "Exercice 3\n\n\nLa fonction retourne : Bonjour Alan !.\nx et y sont deux variable booléennes. x est la valeur de vérité de la comparaison entre les caractères n et j, elle prend donc la valeur False. y est la valeur de vérité de la comparaison entre les caractères o et o, elle prend donc la valeur True.\nLa fonction suivante prend en paramètre une chaîne une_chaine et une lettre une_lettre et retourne le nombre de fois où la lettre une_lettre apparaît dans la chaîne une_chaine :\n\ndef occurrences_lettre(une_chaine, une_lettre):\n    \"\"\"Retourne le nombre d'occurrences de la lettre une_lettre dans la chaîne une_chaine.\"\"\"\n    compteur = 0\n    for lettre in une_chaine:\n        if lettre == une_lettre:\n            compteur += 1\n    return compteur\n\nPour obtenir un arbre binaire de hauteur minimale, on range les mots dans l’ordre alphabétique et on place le mot du milieu à la racine. On répète l’opération sur les deux sous-arbres de gauche et de droite.\nListe dans l’ordre alphabétique : ['chameau', 'gnou', 'pingouin', 'python', 'renard'].\nOn obtient l’arbre :\n\nPour obtenir un arbre de hauteur maximale, on peut placer à la racine le premier mot de la liste classée dans l’ordre alphabétique, puis placer le mot suivant en sous-arbre droit et chaque mot suivant en sous-arbre droit du précédent. On obtient un arbre filiforme.\n\n\n\nmystere(abr_mots_francais) retourne 336 531. Cette fonction calcule en effet de façon récursive le nombre d’éléments de l’arbre binaire donné en paramètre, égal à un (on compte la racine, si l’arbre n’est pas vide) plus le nombre d’éléments de l’arbre binaire de gauche plus le nombre d’éléments de l’arbre binaire de droite.\nFonction permettant de calculer la hauteur d’un arbre binaire :\n\ndef hauteur(un_abr):\n    \"\"\"Retourne la hauteur de l'arbre binaire un_abr.\"\"\"\n    if un_abr.est_vide():\n        return 0\n    else:\n        return 1 + max(hauteur(un_abr.sous_arbre_gauche), hauteur(un_abr.sous_arbre_droit))\n\nCode de la fonction complétée :\n\ndef chercher_mots(liste_mots, longueur, lettre, position):\n    res = []\n    for i in range(len(liste_mots)):\n        if len(liste_mots[i]) == longueur and liste_mots[i][position] == lettre:\n            res.append(liste_mots[i])\n    return res\n\nLa commande chercher_mots(liste_mots_francais, 3, 'x', 2) retourne la liste des mots français de longueur 3 contenant la lettre x à la troisième position. La commande chercher_mots(chercher_mots(liste_mots_francais, 3, 'x', 2), 3, 'a', 1) retourne, parmi ceux-ci, les mots qui possèdent un ‘a’ à la deuxième position, soit à partir de l’exemple donné dans l’énoncé : [‘fax’, ‘max’].\nCode permettant de trouver les mots de 5 lettres qui se terminent par ‘ter’ :\n\nchercher_mots(chercher_mots(chercher_mots(liste_mots_francais, 5, 't', 2), 5, 'e', 3), 5, 'r', 4)"
  },
  {
    "objectID": "bac/annales.html",
    "href": "bac/annales.html",
    "title": "Annales du bac de NSI",
    "section": "",
    "text": "Centres étrangers 2023, jour 1 : Sujet PDF, Corrigé.\nCentres étrangers 2023, jour 2 : Sujet PDF, corrigé.\nPolynésie 2023, jour 1 : Sujet PDF.\nPolynésie 2023, jour 2 : Sujet PDF."
  },
  {
    "objectID": "bac/annales.html#sujets-2023",
    "href": "bac/annales.html#sujets-2023",
    "title": "Annales du bac de NSI",
    "section": "",
    "text": "Centres étrangers 2023, jour 1 : Sujet PDF, Corrigé.\nCentres étrangers 2023, jour 2 : Sujet PDF, corrigé.\nPolynésie 2023, jour 1 : Sujet PDF.\nPolynésie 2023, jour 2 : Sujet PDF."
  },
  {
    "objectID": "bac/index.html",
    "href": "bac/index.html",
    "title": "Épreuve de NSI au bac en Terminale",
    "section": "",
    "text": "Fichier à télécharger…"
  },
  {
    "objectID": "bac/index.html#programme-officiel",
    "href": "bac/index.html#programme-officiel",
    "title": "Épreuve de NSI au bac en Terminale",
    "section": "",
    "text": "Fichier à télécharger…"
  },
  {
    "objectID": "bac/index.html#nature-de-lépreuve-de-nsi-au-bac-en-terminale",
    "href": "bac/index.html#nature-de-lépreuve-de-nsi-au-bac-en-terminale",
    "title": "Épreuve de NSI au bac en Terminale",
    "section": "Nature de l’épreuve de NSI au bac en Terminale",
    "text": "Nature de l’épreuve de NSI au bac en Terminale\nD’après le Bulletin Officiel n°36 du 30 septembre 2022 :\n\nDurée : 3 heures 30 + 1 heure\nCoefficient : 16\nFormat : L’épreuve terminale obligatoire de spécialité est composée de deux parties :\n\nune partie écrite, comptant pour 12 points sur 20,\nune partie pratique comptant pour 8 points sur 20.\n\n\nPartie écrite de l’épreuve de NSI au bac en terminale\n\nDurée : 3 heures 30\nModalités : La partie écrite consiste en la résolution de trois exercices permettant d’évaluer les connaissances et les capacités attendues conformément aux programmes de première et de terminale de la spécialité.\nChaque exercice est noté sur 4 points.\nLe sujet comporte trois exercices indépendants les uns des autres, qui permettent d’évaluer les connaissances et compétences des candidats.\n\n\nPoints du programme évaluables lors de l’épreuve écrite\nRéférence : Bulletin officiel n°36 du 30 septembre 2022\n\nThème 2 – Structures de données\n\nStructures de données, interface et implémentation.\nVocabulaire de la programmation objet : classes, attributs, méthodes, objets.\nListes, piles, files : structures linéaires. Dictionnaires, index et clé.\nArbres : structures hiérarchiques. Arbres binaires : nœuds, racines, feuilles, sous-arbres gauches, sous-arbres droits.\n\nThème 3 – Bases de données\n\nModèle relationnel : relation, attribut, domaine, clef primaire, clef étrangère, schéma relationnel.\nBase de données relationnelle.\nLangage SQL : requêtes d’interrogation et de mise à jour d’une base de données.\n\nThème 4 – Architectures matérielles, systèmes d’exploitation et réseaux\n\nGestion des processus et des ressources par un système d’exploitation.\nProtocoles de routage.\n\nThème 5 – Langages et programmation\n\nRécursivité.\nModularité.\nMise au point des programmes. Gestion des bugs.\n\nThème 6 – Algorithmique\n\nAlgorithmes sur les arbres binaires et sur les arbres binaires de recherche.\nMéthode « diviser pour régner »\n\n\n\n\nPoints du programme non évalués à l’écrit\n\nThème 1 – Histoire de l’informatique\nThème 2 – Structures de données\n\nGraphes : structures relationnelles. Sommets, arcs, arêtes, graphes orientés ou non orientés.\n\nThème 3 – Bases de données\n\nSystème de gestion de bases de données relationnelles.\n\nThème 4 – Architectures matérielles, systèmes d’exploitation et réseaux\n\nComposants intégrés d’un système sur puce.\nSécurisation des communications.\n\nThème 5 – Langages et programmation\n\nNotion de programme en tant que donnée. Calculabilité, décidabilité.\nParadigmes de programmation\n\nThème 6 – Algorithmique\n\nAlgorithmes sur les graphes.\nProgrammation dynamique.\nRecherche textuelle."
  },
  {
    "objectID": "bac/index.html#partie-pratique-de-lépreuve-de-nsi-au-bac-en-terminale",
    "href": "bac/index.html#partie-pratique-de-lépreuve-de-nsi-au-bac-en-terminale",
    "title": "Épreuve de NSI au bac en Terminale",
    "section": "Partie pratique de l’épreuve de NSI au bac en terminale",
    "text": "Partie pratique de l’épreuve de NSI au bac en terminale\n\nDurée : 1 heure\nModalités : La partie pratique consiste en la résolution de deux exercices sur ordinateur, chacun étant noté sur 4 points.\nLe candidat est évalué sur la base d’un dialogue avec un professeur-examinateur.\nUn examinateur évalue au maximum quatre élèves. L’examinateur ne peut pas évaluer un élève qu’il a eu en classe durant l’année en cours.\nL’évaluation de cette partie se déroule au cours du deuxième trimestre pendant la période de l’épreuve écrite de spécialité.\n\nPremier exercice\nLe premier exercice consiste à programmer un algorithme figurant explicitement au programme, ne présentant pas de difficulté particulière, dont on fournit une spécification.\nIl s’agit donc de restituer un algorithme rencontré et travaillé à plusieurs reprises en cours de formation.\nLe sujet peut proposer un jeu de test avec les réponses attendues pour permettre au candidat de vérifier son travail.\nDeuxième exercice\nPour le second exercice, un programme est fourni au candidat.\nCet exercice ne demande pas l’écriture complète d’un programme, mais permet de valider des compétences de programmation suivant des modalités variées : le candidat doit, par exemple, compléter un programme « à trous » afin de répondre à une spécification donnée, ou encore compléter un programme pour le documenter, ou encore compléter un programme en ajoutant des assertions, etc."
  },
  {
    "objectID": "BDD/exercices.html",
    "href": "BDD/exercices.html",
    "title": "Bases de données (Exercices)",
    "section": "",
    "text": "Les exercices précédés du symbole  sont à faire sur machine, en sauvegardant le fichier si nécessaire.\nLes exercices précédés du symbole  doivent être résolus par écrit."
  },
  {
    "objectID": "BDD/exercices.html#fa-solid-pencil-alt-exercice-1",
    "href": "BDD/exercices.html#fa-solid-pencil-alt-exercice-1",
    "title": "Bases de données (Exercices)",
    "section": " Exercice 1",
    "text": "Exercice 1\nVoici un extrait d’une relation référençant des films :\n\n\n\nid\ntitre\nrealisateur\nann_sortie\nnote_sur_10\n\n\n\n\n1\nAlien, le huitième passager\nScott\n1979\n10\n\n\n2\nDune\nLynch\n1985\n5\n\n\n3\n2001 : l’odyssée de l’espace\nKubrick\n1968\n9\n\n\n4\nBlade Runner\nScott\n1982\n10\n\n\n\nListez les différents attributs de cette relation. Donnez le domaine de chaque attribut.\nPour chaque attribut dire si cet attribut peut jouer le rôle de clé primaire, vous n’oublierez pas de justifier vos réponses."
  },
  {
    "objectID": "BDD/exercices.html#fa-solid-pencil-alt-exercice-2",
    "href": "BDD/exercices.html#fa-solid-pencil-alt-exercice-2",
    "title": "Bases de données (Exercices)",
    "section": " Exercice 2",
    "text": "Exercice 2\nUn ski-club utilise une base de données constituée de 2 tables :\n\nune table ADHERENTS\nune table STATIONS\n\nDans la table ADHERENTS on trouve un attribut “ref_station” qui permet de connaître les stations de ski préférées des adhérents.\nTable ADHERENTS\n\n\n\nnum_licence\nnom\nprenom\nannee_naissance\nref_station\n\n\n\n\n12558\nDoe\nJohn\n1988\n5\n\n\n13668\nVect\nAlice\n1974\n6\n\n\n1777\nDect\nBob\n1967\n3\n\n\n13447\nBeau\nTristan\n1999\n4\n\n\n1141\nPabeau\nJohn\n1975\n3\n\n\n\ntable STATIONS\n\n\n\nref\nnom\naltitude_max\n\n\n\n\n3\nLe grand Bornand\n2050\n\n\n4\nLa clusaz\n2616\n\n\n5\nFlaine\n2510\n\n\n6\nAvoriaz\n2466\n\n\n\n\nComment appelle-t-on l’attribut ref_station de la table ADHERENTS ?\nÉcrire la requête SQL permettant d’obtenir le nom des stations ayant une altitude maxi strictement supérieure à 2500 m.\nÉcrire une requête SQL permettant d’obtenir le numéro de licence des adhérents nés après 1980 et ayant pour prénom John.\nDonnez le résultat de la requête SQL suivante :\n\nSELECT nom \nFROM ADHERENTS \nWHERE num_licence &gt; 2000 OR  ref_station = 3\n\nDonnez le résultat de la requête SQL suivante :\n\nSELECT STATIONS.nom\nFROM STATIONS\nINNER JOIN ADHERENTS ON ADHERENTS.ref_station = STATIONS.ref\nWHERE annee_naissance &gt; 1975"
  },
  {
    "objectID": "BDD/exercices.html#fa-solid-pencil-alt-exercice-3-exercices-tirés-des-annales",
    "href": "BDD/exercices.html#fa-solid-pencil-alt-exercice-3-exercices-tirés-des-annales",
    "title": "Bases de données (Exercices)",
    "section": " Exercice 3 : Exercices tirés des annales",
    "text": "Exercice 3 : Exercices tirés des annales\n\nMétropole 2022 Jour 1 : Exercice 2.\nMétropole 2022 Jour 2 : Exercice 4.\nAmérique du Nord 2022 Jour 1 : Exercice 1.\nAmérique du Nord 2022 Jour 2 : Exercice 3.\nCentres étrangers 2022 Jour 1 : Exercice 4.\nCentres étrangers 2022 Jour 2 : Exercice 3."
  },
  {
    "objectID": "BDD/exercices.html#fa-desktop-exercice-4",
    "href": "BDD/exercices.html#fa-desktop-exercice-4",
    "title": "Bases de données (Exercices)",
    "section": " Exercice 4",
    "text": "Exercice 4\nLe CNAM (Conservatoire National des Arts et Métiers) propose en ligne des travaux pratiques sur une base de données concernant les films de cinéma. À titre d’entraînement, ouvrir cet exerciseur (cliquer sur l’image ci-dessous) et essayer de formuler les requêtes correspondant aux suggestions de la colonne de droite. Les réponses sont disponibles sur le site, mais prenez le temps de chercher, d’essayer, et de vous corriger."
  },
  {
    "objectID": "BDD/exercices.html#fa-desktop-problème",
    "href": "BDD/exercices.html#fa-desktop-problème",
    "title": "Bases de données (Exercices)",
    "section": " Problème",
    "text": "Problème\nSerious game : meurtre à SQL City …"
  },
  {
    "objectID": "BDD/exercices.html#fa-desktop-pour-les-plus-rapides",
    "href": "BDD/exercices.html#fa-desktop-pour-les-plus-rapides",
    "title": "Bases de données (Exercices)",
    "section": " Pour les plus rapides",
    "text": "Pour les plus rapides\nSerious game : SQL Island …"
  },
  {
    "objectID": "BDD/index.html",
    "href": "BDD/index.html",
    "title": "Programme",
    "section": "",
    "text": "Le développement des traitements informatiques nécessite la manipulation de données de plus en plus nombreuses. Leur organisation et leur stockage constituent un enjeu essentiel de performance.\nLe recours aux bases de données relationnelles est aujourd’hui une solution très répandue. Ces bases de données permettent d’organiser, de stocker, de mettre à jour et d’interroger des données structurées volumineuses utilisées simultanément par différents programmes ou différents utilisateurs. Cela est impossible avec les représentations tabulaires étudiées en classe de première.\nDes systèmes de gestion de bases de données (SGBD) de très grande taille (de l’ordre du pétaoctet) sont au centre de nombreux dispositifs de collecte, de stockage et de production d’informations.\nL’accès aux données d’une base de données relationnelle s’effectue grâce à des requêtes d’interrogation et de mise à jour qui peuvent par exemple être rédigées dans le langage SQL (Structured Query Language). Les traitements peuvent conjuguer le recours au langage SQL et à un langage de programmation.\nIl convient de sensibiliser les élèves à un usage critique et responsable des données.\n\n\n\n\n\n\n\n\nContenus\nCapacités attendues\nCommentaires\n\n\n\n\nModèle relationnel : relation, attribut, domaine, clef primaire, clef étrangère, schéma relationnel.\nIdentifier les concepts définissant le modèle relationnel.\nCes concepts permettent d’exprimer les contraintes d’intégrité (domaine, relation et référence).\n\n\nBase de données relationnelle.\nSavoir distinguer la structure d’une base de données de son contenu. Repérer des anomalies dans le schéma d’une base de données.\nLa structure est un ensemble de schémas relationnels qui respecte les contraintes du modèle relationnel. Les anomalies peuvent être des redondances de données ou des anomalies d’insertion, de suppression, de mise à jour. On privilégie la manipulation de données nombreuses et réalistes.\n\n\nSystème de gestion de bases de données relationnelles.\nIdentifier les services rendus par un système de gestion de bases de données relationnelles : persistance des données, gestion des accès concurrents, efficacité de traitement des requêtes, sécurisation des accès.\nIl s’agit de comprendre le rôle et les enjeux des différents services sans en détailler le fonctionnement.\\"
  },
  {
    "objectID": "BDD/partie1.html",
    "href": "BDD/partie1.html",
    "title": "Le modèle relationnel (Cours - Partie 1)",
    "section": "",
    "text": "Une donnée est valeur numérisée décrivant de manière élémentaire un fait, une mesure, une réalité\nExemple : le nom de l’auteur, l’âge du capitaine, le titre du livre …\nLes données décrivent des entités du monde réel, elles-mêmes associées les unes aux autres.\nExemple : Nicolas Bouvier est un écrivain suisse auteur de récit de voyage culte “l’usage du monde” paru en 1963 : deux entités, liées par la notion d’auteur.\nUne base de données est un ensemble (potentiellement volumineux, mais pas forcément) de telles informations conformes à une structure prédéfinie au moment de la conception, avec, de plus, une caractéristique essentielle : on souhaite les mémoriser de manière persistante. La persistance désigne la capacité d’une base à exister indépendamment des applications qui la manipulent, ou du système qui l’héberge. On peut arrêter toutes les machines un soir et retrouver la base de données le lendemain. Cela implique qu’une base est toujours stockée sur un support comme les disques magnétiques qui préservent leur contenu même en l’absence d’alimentation électrique.\nOn arrive donc à la définition suivante :\n\n\n\n\n\n\nDéfinition\n\n\n\nUne base de données est ensemble d’informations structurées mémorisées sur un support persistant.\n\n\nUn fichier de base de données a nécessairement une structure qui permet d’une part de distinguer les données les unes des autres, et d’autre part de représenter leurs liens.\nPrenons l’exemple des fichiers CSV, l’une des structures les plus simples et les plus répandues, sur lesquels nous avons travaillé en première. Dans un fichier CSV, les données élémentaires sont représentées par des « champs » délimités par des virgules ou des points-virgule. Les champs sont associés les uns aux autres par le simple fait d’être placés dans une même ligne. Les lignes en revanche sont indépendantes les unes des autres. On peut placer autant de lignes que l’on veut dans un fichier, et même changer leur ordre sans que cela modifie en quoi que ce soit l’information représentée.\nVoici l’exemple de nos données, représentées en CSV.\n\"Bouvier\" ; \"Nicolas\"; \"L'usage du monde\" ; 1963\nOn comprend bien que le premier champ est le nom, le second le prénom, etc. Il paraît donc cohérent d’ajouter de nouvelles lignes comme:\n\"Bouvier\"   ; \"Nicolas\"; \"L'usage du monde\" ; 1963\n\"Stevenson\" ; \"Robert-Louis\"  ; \"Voyage dans les Cévennes avec un âne\" ; 1879\nOn a donné une structure régulière à nos informations, ce qui va permettre de les interroger et de les manipuler avec précision. On les stocke dans un fichier sur disque, et nous sommes donc en cours de constitution d’une véritable base de données. On peut en fait généraliser ce constat : une base de données est toujours un ensemble de fichiers, stockés sur une mémoire externe comme un disque, dont le contenu obéit à certaines règles de structuration.\nPeut-on se satisfaire de cette solution et imaginer que nous pouvons construire des applications en nous appuyant directement sur des fichiers structurés, par exemple des fichiers CSV ? C’est la méthode illustrée par la figure ci-dessous. Dans une telle situation, chaque utilisateur applique des programmes au fichier, pour en extraire des données, pour les modifier, pour les créer.\n\n\n\n\n\nCette approche soulève de nombreuses difficultés, parmi lesquelles :\n\nLourdeur d’accès aux données. En pratique, pour chaque accès, même le plus simple, il faudrait écrire un programme adapté à la structure du fichier. La production et la maintenance de tels programmes seraient extrêmement coûteuses.\nRisques élevés pour l’intégrité et la sécurité. Si tout programmeur peut accéder directement aux fichiers, il est impossible de garantir la sécurité et l’intégrité des données. Quelqu’un peut très bien par exemple, en toute bonne foi, faire une fausse manœuvre qui rend le fichier illisible.\nPas de contrôle de concurrence. Dans un environnement où plusieurs utilisateurs accèdent aux mêmes fichiers, comme sur la Fig. 1, des problèmes de concurrence d’accès se posent, notamment pour les mises à jour. Comment gérer par exemple la situation où deux utilisateurs souhaitent en même temps ajouter une ligne au fichier ?\nPerformances. Tant qu’un fichier ne contient que quelques centaines de lignes, on peut supposer que les performances ne posent pas de problème, mais que faire quand on atteint les Gigaoctets (1,000 Mégaoctets), ou même le Téraoctet (1,000 Gigaoctets) ? Maintenir des performances acceptables suppose la mise en œuvre d’algorithmes ou de structures de données demandant des compétences très avancées, probablement hors de portée du développeur d’application qui a, de toute façon, mieux à faire.\n\nPour surmonter ces problèmes des systèmes complexes capables d’offrir à la fois un accès simple, sécurisé, performant au contenu d’une base, et d’accomplir le tour de force de satisfaire de tels accès pour des dizaines, centaines ou même milliers d’utilisateurs simultanés, le tout en garantissant l’intégrité de la base même en cas de panne sont mis en place. De tels systèmes sont appelés Systèmes de Gestion de Bases de Données, SGBD en bref.\n\n\n\n\n\n\nDéfinition\n\n\n\nUn Système de Gestion de Bases de Données (SGBD) est un système informatique qui assure la gestion de l’ensemble des informations stockées dans une base de données. Il prend en charge, notamment, les deux grandes fonctionnalités suivantes :\n\nAccès aux fichiers de la base, garantissant leur intégrité, contrôlant les opérations concurrentes, optimisant les recherches et mises à jour.\nInteractions avec les applications et utilisateurs, grâce à des langages d’interrogation et de manipulation à haut niveau d’abstraction.\n\n\n\nAvec un SGBD, les applications n’ont plus jamais accès directement aux fichiers, et ne savent d’ailleurs même pas qu’ils existent, quelle est leur structure et où ils sont situés. L’architecture classique est celle illustrée par la figure ci-dessous. Le SGBD apparaît sous la forme d’un serveur, c’est-à-dire d’un processus informatique prêt à communiquer avec d’autres (les « clients ») via le réseau. Ce serveur est hébergé sur une machine (la « machine serveur ») et est le seul à pouvoir accéder aux fichiers contenant les données, ces fichiers étant le plus souvent stockés sur le disque de la machine serveur.\n\n\n\n\n\nLes applications utilisateurs, maintenant, accèdent à la base via le programme serveur auquel elles sont connectés. Elles transmettent des commandes (d’où le nom « d’applications clientes ») que le serveur se charge d’appliquer. Ces applications bénéficient donc des puissants algorithmes implantés par le SGBD dans son serveur, comme la capacité à gérer les accès concurrents, où à satisfaire avec efficacité des recherches portant sur de très grosses bases.\nCette architecture est à peu près universellement adoptée par tous les SGBD. Les notions suivantes et le vocabulaire associé, sont donc très importantes à retenir.\n\n\n\n\n\n\nDéfinitions\n\n\n\nProgramme serveur. Un SGBD est instancié sur une machine sous la forme d’un programme serveur qui gère une ou plusieurs bases de données, chacune constituée de fichiers stockés sur disque. Le programme serveur est seul responsable de tous les accès à une base, et de l’utilisation des ressources (mémoire, disques) qui servent de support à ces accès.\nClients (programmes). Les programmes (ou applications) clients se connectent au programme serveur via le réseau, lui transmettent des requêtes et reçoivent des données en retour. Ils ne disposent d’aucune information directe sur la base.\n\n\nLe fait que le serveur de données s’interpose entre les fichiers et les programmes clients a une conséquence extrêmement importante : ces clients, n’ayant pas accès aux fichiers, ne voient les données que sous la forme que veut bien leur présenter le serveur. Ce dernier peut donc choisir le mode de représentation qui lui semble le plus approprié : pour nous, ce sera sous forme de tables et nous parlerons alors de modèle relationnel.\nUne des propriétés les plus importantes des SGBD est donc la distinction entre plusieurs niveaux d’abstraction pour la représentation des données : le niveau logique et le niveau physique.\n\n\n\n\n\n\nDéfinition\n\n\n\n\nLe niveau physique est celui du codage des données dans des fichiers stockés sur disque.\nLe niveau logique est celui de la représentation les données dans des structures abstraites, proposées aux applications clientes, obtenues par conversion du niveau physique (pour nous ce sont des structures en tables)\n\n\n\nLa figure ci-dessous illustre les niveaux d’abstraction dans l’architecture d’un système de gestion de données. Les programmes clients ne voient que le niveau logique, c’est-à-dire des tables. Le serveur est chargé du niveau physique, de la conversion des données vers le niveau logique, et de toute la machinerie qui permet de faire fonctionner le système : mémoire, disques, algorithmes et structures de données. Tout cela est, encore une fois, invisible (et c’est tant mieux) pour les programmes clients qui peuvent se concentrer sur l’accès à des données présentées le plus simplement possible.\n\n\n\n\n\nPrécisions que les niveaux sont en grande partie indépendants, dans le sens où l’on peut modifier complètement l’organisation du niveau physique sans avoir besoin de changer qui que ce soit aux applications qui accèdent à la base. Cette indépendance logique-physique est très précieuse pour l’administration des bases de données.\nUn langage est nécessaire pour interagir avec les données (insérer, modifier, détruire, déplacer, protéger, etc.). Le langage permet de construire les commandes transmises au serveur.\nLe modèle relationnel s’est construit sur des bases formelles (mathématiques) rigoureuses, ce qui explique en grande partie sa robustesse et sa stabilité depuis l’essentiel des travaux qui l’ont élaboré, dans les années 70-80.\nLe langage SQL est utilisé depuis les années 1970 dans tous les systèmes relationnels.\nLe terme SQL désigne plus qu’un langage d’interrogation, même s’il s’agit de son principal aspect. La norme couvre également les mises à jour, la définition des tables, les contraintes portant sur les données, les droits d’accès. SQL est donc le langage à connaître pour interagir avec un système relationnel."
  },
  {
    "objectID": "BDD/partie1.html#introduction",
    "href": "BDD/partie1.html#introduction",
    "title": "Le modèle relationnel (Cours - Partie 1)",
    "section": "",
    "text": "Une donnée est valeur numérisée décrivant de manière élémentaire un fait, une mesure, une réalité\nExemple : le nom de l’auteur, l’âge du capitaine, le titre du livre …\nLes données décrivent des entités du monde réel, elles-mêmes associées les unes aux autres.\nExemple : Nicolas Bouvier est un écrivain suisse auteur de récit de voyage culte “l’usage du monde” paru en 1963 : deux entités, liées par la notion d’auteur.\nUne base de données est un ensemble (potentiellement volumineux, mais pas forcément) de telles informations conformes à une structure prédéfinie au moment de la conception, avec, de plus, une caractéristique essentielle : on souhaite les mémoriser de manière persistante. La persistance désigne la capacité d’une base à exister indépendamment des applications qui la manipulent, ou du système qui l’héberge. On peut arrêter toutes les machines un soir et retrouver la base de données le lendemain. Cela implique qu’une base est toujours stockée sur un support comme les disques magnétiques qui préservent leur contenu même en l’absence d’alimentation électrique.\nOn arrive donc à la définition suivante :\n\n\n\n\n\n\nDéfinition\n\n\n\nUne base de données est ensemble d’informations structurées mémorisées sur un support persistant.\n\n\nUn fichier de base de données a nécessairement une structure qui permet d’une part de distinguer les données les unes des autres, et d’autre part de représenter leurs liens.\nPrenons l’exemple des fichiers CSV, l’une des structures les plus simples et les plus répandues, sur lesquels nous avons travaillé en première. Dans un fichier CSV, les données élémentaires sont représentées par des « champs » délimités par des virgules ou des points-virgule. Les champs sont associés les uns aux autres par le simple fait d’être placés dans une même ligne. Les lignes en revanche sont indépendantes les unes des autres. On peut placer autant de lignes que l’on veut dans un fichier, et même changer leur ordre sans que cela modifie en quoi que ce soit l’information représentée.\nVoici l’exemple de nos données, représentées en CSV.\n\"Bouvier\" ; \"Nicolas\"; \"L'usage du monde\" ; 1963\nOn comprend bien que le premier champ est le nom, le second le prénom, etc. Il paraît donc cohérent d’ajouter de nouvelles lignes comme:\n\"Bouvier\"   ; \"Nicolas\"; \"L'usage du monde\" ; 1963\n\"Stevenson\" ; \"Robert-Louis\"  ; \"Voyage dans les Cévennes avec un âne\" ; 1879\nOn a donné une structure régulière à nos informations, ce qui va permettre de les interroger et de les manipuler avec précision. On les stocke dans un fichier sur disque, et nous sommes donc en cours de constitution d’une véritable base de données. On peut en fait généraliser ce constat : une base de données est toujours un ensemble de fichiers, stockés sur une mémoire externe comme un disque, dont le contenu obéit à certaines règles de structuration.\nPeut-on se satisfaire de cette solution et imaginer que nous pouvons construire des applications en nous appuyant directement sur des fichiers structurés, par exemple des fichiers CSV ? C’est la méthode illustrée par la figure ci-dessous. Dans une telle situation, chaque utilisateur applique des programmes au fichier, pour en extraire des données, pour les modifier, pour les créer.\n\n\n\n\n\nCette approche soulève de nombreuses difficultés, parmi lesquelles :\n\nLourdeur d’accès aux données. En pratique, pour chaque accès, même le plus simple, il faudrait écrire un programme adapté à la structure du fichier. La production et la maintenance de tels programmes seraient extrêmement coûteuses.\nRisques élevés pour l’intégrité et la sécurité. Si tout programmeur peut accéder directement aux fichiers, il est impossible de garantir la sécurité et l’intégrité des données. Quelqu’un peut très bien par exemple, en toute bonne foi, faire une fausse manœuvre qui rend le fichier illisible.\nPas de contrôle de concurrence. Dans un environnement où plusieurs utilisateurs accèdent aux mêmes fichiers, comme sur la Fig. 1, des problèmes de concurrence d’accès se posent, notamment pour les mises à jour. Comment gérer par exemple la situation où deux utilisateurs souhaitent en même temps ajouter une ligne au fichier ?\nPerformances. Tant qu’un fichier ne contient que quelques centaines de lignes, on peut supposer que les performances ne posent pas de problème, mais que faire quand on atteint les Gigaoctets (1,000 Mégaoctets), ou même le Téraoctet (1,000 Gigaoctets) ? Maintenir des performances acceptables suppose la mise en œuvre d’algorithmes ou de structures de données demandant des compétences très avancées, probablement hors de portée du développeur d’application qui a, de toute façon, mieux à faire.\n\nPour surmonter ces problèmes des systèmes complexes capables d’offrir à la fois un accès simple, sécurisé, performant au contenu d’une base, et d’accomplir le tour de force de satisfaire de tels accès pour des dizaines, centaines ou même milliers d’utilisateurs simultanés, le tout en garantissant l’intégrité de la base même en cas de panne sont mis en place. De tels systèmes sont appelés Systèmes de Gestion de Bases de Données, SGBD en bref.\n\n\n\n\n\n\nDéfinition\n\n\n\nUn Système de Gestion de Bases de Données (SGBD) est un système informatique qui assure la gestion de l’ensemble des informations stockées dans une base de données. Il prend en charge, notamment, les deux grandes fonctionnalités suivantes :\n\nAccès aux fichiers de la base, garantissant leur intégrité, contrôlant les opérations concurrentes, optimisant les recherches et mises à jour.\nInteractions avec les applications et utilisateurs, grâce à des langages d’interrogation et de manipulation à haut niveau d’abstraction.\n\n\n\nAvec un SGBD, les applications n’ont plus jamais accès directement aux fichiers, et ne savent d’ailleurs même pas qu’ils existent, quelle est leur structure et où ils sont situés. L’architecture classique est celle illustrée par la figure ci-dessous. Le SGBD apparaît sous la forme d’un serveur, c’est-à-dire d’un processus informatique prêt à communiquer avec d’autres (les « clients ») via le réseau. Ce serveur est hébergé sur une machine (la « machine serveur ») et est le seul à pouvoir accéder aux fichiers contenant les données, ces fichiers étant le plus souvent stockés sur le disque de la machine serveur.\n\n\n\n\n\nLes applications utilisateurs, maintenant, accèdent à la base via le programme serveur auquel elles sont connectés. Elles transmettent des commandes (d’où le nom « d’applications clientes ») que le serveur se charge d’appliquer. Ces applications bénéficient donc des puissants algorithmes implantés par le SGBD dans son serveur, comme la capacité à gérer les accès concurrents, où à satisfaire avec efficacité des recherches portant sur de très grosses bases.\nCette architecture est à peu près universellement adoptée par tous les SGBD. Les notions suivantes et le vocabulaire associé, sont donc très importantes à retenir.\n\n\n\n\n\n\nDéfinitions\n\n\n\nProgramme serveur. Un SGBD est instancié sur une machine sous la forme d’un programme serveur qui gère une ou plusieurs bases de données, chacune constituée de fichiers stockés sur disque. Le programme serveur est seul responsable de tous les accès à une base, et de l’utilisation des ressources (mémoire, disques) qui servent de support à ces accès.\nClients (programmes). Les programmes (ou applications) clients se connectent au programme serveur via le réseau, lui transmettent des requêtes et reçoivent des données en retour. Ils ne disposent d’aucune information directe sur la base.\n\n\nLe fait que le serveur de données s’interpose entre les fichiers et les programmes clients a une conséquence extrêmement importante : ces clients, n’ayant pas accès aux fichiers, ne voient les données que sous la forme que veut bien leur présenter le serveur. Ce dernier peut donc choisir le mode de représentation qui lui semble le plus approprié : pour nous, ce sera sous forme de tables et nous parlerons alors de modèle relationnel.\nUne des propriétés les plus importantes des SGBD est donc la distinction entre plusieurs niveaux d’abstraction pour la représentation des données : le niveau logique et le niveau physique.\n\n\n\n\n\n\nDéfinition\n\n\n\n\nLe niveau physique est celui du codage des données dans des fichiers stockés sur disque.\nLe niveau logique est celui de la représentation les données dans des structures abstraites, proposées aux applications clientes, obtenues par conversion du niveau physique (pour nous ce sont des structures en tables)\n\n\n\nLa figure ci-dessous illustre les niveaux d’abstraction dans l’architecture d’un système de gestion de données. Les programmes clients ne voient que le niveau logique, c’est-à-dire des tables. Le serveur est chargé du niveau physique, de la conversion des données vers le niveau logique, et de toute la machinerie qui permet de faire fonctionner le système : mémoire, disques, algorithmes et structures de données. Tout cela est, encore une fois, invisible (et c’est tant mieux) pour les programmes clients qui peuvent se concentrer sur l’accès à des données présentées le plus simplement possible.\n\n\n\n\n\nPrécisions que les niveaux sont en grande partie indépendants, dans le sens où l’on peut modifier complètement l’organisation du niveau physique sans avoir besoin de changer qui que ce soit aux applications qui accèdent à la base. Cette indépendance logique-physique est très précieuse pour l’administration des bases de données.\nUn langage est nécessaire pour interagir avec les données (insérer, modifier, détruire, déplacer, protéger, etc.). Le langage permet de construire les commandes transmises au serveur.\nLe modèle relationnel s’est construit sur des bases formelles (mathématiques) rigoureuses, ce qui explique en grande partie sa robustesse et sa stabilité depuis l’essentiel des travaux qui l’ont élaboré, dans les années 70-80.\nLe langage SQL est utilisé depuis les années 1970 dans tous les systèmes relationnels.\nLe terme SQL désigne plus qu’un langage d’interrogation, même s’il s’agit de son principal aspect. La norme couvre également les mises à jour, la définition des tables, les contraintes portant sur les données, les droits d’accès. SQL est donc le langage à connaître pour interagir avec un système relationnel."
  },
  {
    "objectID": "BDD/partie2.html",
    "href": "BDD/partie2.html",
    "title": "Le modèle relationnel (Cours - Partie 2)",
    "section": "",
    "text": "Définition\n\n\n\nLe modèle relationnel est une manière de modéliser les relations existantes entre plusieurs informations, et de les ordonner entre elles"
  },
  {
    "objectID": "BDD/partie2.html#relation-attributs-et-domaines",
    "href": "BDD/partie2.html#relation-attributs-et-domaines",
    "title": "Le modèle relationnel (Cours - Partie 2)",
    "section": "1. Relation, attributs et domaines",
    "text": "1. Relation, attributs et domaines\nUne relation peut être vue comme un tableau composé d’une en-tête (première ligne) et d’un corps.\nChaque ligne de la relation est un p-uplet et chaque colonne est un attribut (l’en-tête contient les intitulés des attributs).\n\n\n\n\n\nPour la relation ci-dessus, on retrouve les données concernant les établissements scolaires du second degré dans le Cantal.\nPour chaque attribut d’une relation, il est nécessaire de définir un domaine : Le domaine d’un attribut donné correspond à un ensemble fini ou infini de valeurs admissibles.\nPar exemple, le domaine de l’attribut “statut” correspond à l’ensemble des deux chaînes {“Public”, “Privé”}. L’attribut “nom” a pour domaine l’ensemble des chaînes de caractères (noté TEXT). L’attribut “codepostal” a pour domaine l’ensemble des entiers (noté INT).\nAu moment de la création d’une relation, il est nécessaire de renseigner le domaine de chaque attribut. Le SGBD s’assure qu’un élément ajouté à une relation respecte bien le domaine de l’attribut correspondant : si par exemple vous essayez d’ajouter un code postal non entier (par exemple 8.5), le SGBD signalera cette erreur et n’autorisera pas l’écriture de cette nouvelle donnée.\n\n\n\n\n\n\nRègles à respecter\n\n\n\nDans une relation, il est nécessaire de respecter les deux règles ci-dessous :\n\nles valeurs des attributs doivent être atomiques, c’est-à-dire d’un type simple et non d’un type construit (pas de listes, de tableaux, de p-uplets, …) ;\nil n’y a pas de doublons : les p-uplets sont tous différents.\n\n\n\nPour s’assurer qu’il n’y a pas de doublons dans une relation on ajoute en pratique un critère d’unicité sur l’un des attributs, la clef."
  },
  {
    "objectID": "BDD/partie2.html#clef-primaire-clef-étrangère",
    "href": "BDD/partie2.html#clef-primaire-clef-étrangère",
    "title": "Le modèle relationnel (Cours - Partie 2)",
    "section": "2. Clef primaire, clef étrangère",
    "text": "2. Clef primaire, clef étrangère\n\n\n\n\n\n\nDéfinition\n\n\n\nDans une relation, une clef primaire est un attribut (ou un groupes d’attributs) qui définit de manière unique chacun de p-uplets.\n\n\nEn d’autres termes, il s’agit d’un attribut tel que deux p-uplets sont égaux si, et seulement si, ils ont la même clef primaire.\nPar exemple, dans la table des établissements scolaires du Cantal, l’attribut “code” peut être choisi comme clef primaire, car il identifie de façon unique chaque établissement. L’attribut “commune” ne peut pas être choisi comme clef primaire, car plusieurs établissements existent dans une même commune.\nOn pourrait naïvement penser qu’il suffit de créer une unique relation et de tout mettre dedans pour avoir une base de données. En fait, une telle approche est inapplicable et il est indispensable de créer plusieurs relations, associées les unes aux autres.\nPrenons l’exemple des établissements scolaires, un parcours de la table nous montre que certaines informations sont répétées plusieurs fois, comme notamment le nom de la commune :\n\n\n\n\n\nCette duplication de l’information n’est pas souhaitable dans une base de donnée. La solution pour éviter cela est de travailler avec deux relations (deux tables) au lieu d’une, chacune des relations étant munie d’une clef primaire.\nNous allons pour cela considérer la table des communes du Cantal qui contient un attribut nommé “Code commune” qui peut être choisi comme clef primaire. Dans la relation des établissements, nous remplaçons le nom de la commune par la valeur du Code commune correspondante (attribut id_commune). Voici un extrait des deux relations obtenues :\n\n\n\n\n\n\n\n\n\n\nL’attribut id_commune permet de lier les deux relations : les communes sont représentées dans la relation des établissements par leur code dans la relation des communes. On dit que l’attribut id_commune est une clef étrangère.\n\n\n\n\n\n\nDéfinition\n\n\n\nSoient deux relations \\(R\\) et \\(S\\) de clefs primaires respectives \\(c_R\\) et \\(c_S\\).\nUne clef étrangère de \\(S\\) dans \\(R\\) est un attribut \\(ce\\) de \\(R\\) dont la valeur est toujours égale exactement à une des valeurs de \\(c_S\\).\nAutrement dit, \\(ce\\) correspond à un et un seul p-uplet de \\(S\\).\n\n\nDans notre exemple, l’attribut id_commune est une clef étrangère de la relation des communes dans la relation des établissements car c’est un attribut de la relation des établissements dont la valeur est toujours égale à une des valeurs de la clef primaire Code commune de la relation des communes.\nDeux contraintes doivent toujours être vérifiées avec les clefs :\n\n\n\n\n\n\nContraintes liées aux clefs\n\n\n\n\nContrainte d’unicité: une valeur de clef ne peut apparaître qu’une fois dans une relation.\nContrainte d’intégrité référentielle : la valeur d’une clef étrangère doit toujours être également une des valeurs de la clef référencée.\n\n\n\nCes deux contraintes garantissent l’absence totale de redondances et d’incohérences."
  },
  {
    "objectID": "BDD/partie2.html#schéma-relationnel",
    "href": "BDD/partie2.html#schéma-relationnel",
    "title": "Le modèle relationnel (Cours - Partie 2)",
    "section": "3. Schéma relationnel",
    "text": "3. Schéma relationnel\nLe schéma d’une base de données est constitué d’un ensemble de relations : on parle de schéma relationnel.\nLe schéma relationnel d’une base de données contient les informations suivantes :\n\nLes noms des différentes relations ;\npour chaque relation, la liste des attributs avec leur domaine respectif ;\npour chaque relation, la clef primaire et éventuellement les clefs étrangères\n\nNommons ETABLISSEMENTS et COMMUNES les deux relations utilisées ci-dessus. Le schéma relationnel peut s’écrire :\n\nETABLISSEMENTS(code: TEXT, nom: TEXT, statut: TEXT, codepostal: INT, #id_commune: INT, latitude: FLOAT, longitude: FLOAT)\nCOMMUNES(Code commune: INT, Nom de la commune: TEXT, Population totale: INT)\n\nLes attributs soulignés sont des clefs primaires, le # signifie que l’on a une clef étrangère.\nLe schéma relationnel peut être représenté sous forme graphique (image obtenue ici avec le logiciel DbSchema à partir de la base précédente légèrement modifiée : l’attribut Codepostal a été déplacé dans la relation COMMUNES) :"
  },
  {
    "objectID": "BDD/quiz.html#question-2",
    "href": "BDD/quiz.html#question-2",
    "title": "Quiz - Le modèle relationnel, SGBD",
    "section": "Question 2",
    "text": "Question 2"
  },
  {
    "objectID": "BDD/quiz.html#question-3",
    "href": "BDD/quiz.html#question-3",
    "title": "Quiz - Le modèle relationnel, SGBD",
    "section": "Question 3",
    "text": "Question 3"
  },
  {
    "objectID": "BDD/quiz.html#question-4",
    "href": "BDD/quiz.html#question-4",
    "title": "Quiz - Le modèle relationnel, SGBD",
    "section": "Question 4",
    "text": "Question 4"
  },
  {
    "objectID": "BDD/quiz.html#question-5",
    "href": "BDD/quiz.html#question-5",
    "title": "Quiz - Le modèle relationnel, SGBD",
    "section": "Question 5",
    "text": "Question 5"
  },
  {
    "objectID": "BDD/quiz.html#question-6",
    "href": "BDD/quiz.html#question-6",
    "title": "Quiz - Le modèle relationnel, SGBD",
    "section": "Question 6",
    "text": "Question 6"
  },
  {
    "objectID": "BDD/quiz.html#question-7",
    "href": "BDD/quiz.html#question-7",
    "title": "Quiz - Le modèle relationnel, SGBD",
    "section": "Question 7",
    "text": "Question 7"
  },
  {
    "objectID": "BDD/quiz.html#question-8",
    "href": "BDD/quiz.html#question-8",
    "title": "Quiz - Le modèle relationnel, SGBD",
    "section": "Question 8",
    "text": "Question 8"
  },
  {
    "objectID": "BDD/quiz.html#question-9",
    "href": "BDD/quiz.html#question-9",
    "title": "Quiz - Le modèle relationnel, SGBD",
    "section": "Question 9",
    "text": "Question 9"
  },
  {
    "objectID": "BDD/sql_cours.html",
    "href": "BDD/sql_cours.html",
    "title": "2. Le langage SQL (Cours)",
    "section": "",
    "text": "Version Notebook de ce cours\nNous avons étudié la structure d’une base de données relationnelle, nous allons maintenant apprendre à réaliser des requêtes, c’est-à-dire que nous allons apprendre à créer une base des données, créer des attributs, ajouter des données, modifier des données et enfin, nous allons surtout apprendre à interroger une base de données afin d’obtenir des informations.\nPour réaliser toutes ces requêtes, nous allons devoir apprendre un langage de requêtes : SQL (Structured Query Language). SQL est propre aux bases de données relationnelles.\nDans ce cours nous allons travailler avec SQLite. SQLite est un système de gestion de base de données relationnelle très répandu. Noter qu’il existe d’autres systèmes de gestion de base de données relationnelle comme MySQL ou PostgreSQL. Dans tous les cas, le langage de requête utilisé est le SQL (même si parfois on peut noter quelques petites différences). Ce qui sera vu ici avec SQLite pourra, à quelques petites modifications près, être utilisé avec, par exemple, MySQL.\nNous allons illustrer chacune des instructions SQL du programme avec la base de donnée Cantal.db contenant les deux tables “etablissements” et “communes” déjà rencontrées dans la partie précédente, dont voici un extrait (les noms des attributs ont été un peu modifiés (pas d’espaces) ; la copie d’écran est faite à partir de DB Browser for SqLite). De plus, nous avons déplacé l’attribut “Codepostal” de la table “etablissement” vers la table “communes”, ce qui est plus cohérent.\nSchéma relationnel :\nPour se connecter à cette base de donnée, vous pouvez utiliser le logiciel DB Browser (SqLite) ou bien Edupython (qui propose une version portable du même logiciel)"
  },
  {
    "objectID": "BDD/sql_cours.html#requêtes-dinterrogation",
    "href": "BDD/sql_cours.html#requêtes-dinterrogation",
    "title": "2. Le langage SQL (Cours)",
    "section": "1. Requêtes d’interrogation",
    "text": "1. Requêtes d’interrogation\n\nRequêtes simples\nQuand on désire extraire des informations d’une table, on effectue une requête d’interrogation à l’aide du mot clé SELECT. Voici un exemple de requête d’interrogation :\nSELECT Nomdelacommune, Populationtotale\nFROM communes\nCette requête va nous permettre d’obtenir le nom de la commune et sa population pour toutes les communes présentes dans la table “communes”.\nVoici le résultat de cette requête dans le logiciel DB Browser for SqLite :\n\n\n\n\n\nD’une façon générale, le mot clé SELECT est suivi par les attributs que l’on désire obtenir. Le mot clé FROM est suivi par la table concernée.\nNoter qu’il est possible d’obtenir tous les attributs sans être obligé de tous les noter grâce au caractère étoile * :\nSELECT *\nFROM communes\nest équivalent à :\nSELECT  Codecommune, Nomdelacommune, Populationtotale, Codepostal\nFROM communes\n\n\nRequêtes conditionnelles\nLa clause WHERE permet d’imposer une (ou des) condition(s) permettant de sélectionner uniquement certaines lignes.\nLa condition doit suivre le mot-clé WHERE.\nSELECT Nomdelacommune\nFROM communes\nWHERE Populationtotale &gt; 2500\nLa requête ci-dessus permettra d’afficher le nom des communes dont la population est strictement supérieure à 2500 habitants.\n\n\n\n\n\nIl est possible de combiner les conditions à l’aide d’un OR ou d’un AND :\nSELECT Nomdelacommune\nFROM communes\nWHERE Populationtotale &gt; 2500 AND Populationtotale &lt; 10000\nCette requête permet d’obtenir le nom des communes dont la population est comprise entre 2500 et 10000 habitants.\n\n\n\n\n\nLa requête ci-dessous permet d’afficher le nom des communes dont la population est supérieure à 5000 habitants OU dont le nom contient la lettre “Z” (noter le symbole “%” qui remplace n’importe quelle séquence de caractères en SQL).\nSELECT Nomdelacommune\nFROM communes\nWHERE Populationtotale &gt; 5000 OR Nomdelacommune LIKE \"%Z%\"\n\n\n\n\n\n\n\nOrdonner les résultats\nLa clause ORDER BY permet d’ordonner les résultats dans l’ordre croissant.\nSELECT Nomdelacommune, Populationtotale\nFROM communes\nWHERE Populationtotale &gt; 5000 ORDER BY Populationtotale\nCette requête affiche le nom et la population des communes de plus de 5000 habitants dans l’ordre croissant de leur population.\n\n\n\n\n\nPour ordonner les résultats dans l’ordre décroissant, on ajoute DESC.\nSi la clause ORDER BY porte sur un attribut de type TEXT, on aura un rangement dans l’ordre alphabétique.\nSELECT Nomdelacommune, Populationtotale\nFROM communes\nWHERE Populationtotale &gt; 5000 ORDER BY Nomdelacommune DESC\nCette requête affiche le nom et la population des communes de plus de 5000 habitants dans l’ordre inverse de l’ordre alphabétique de leur nom.\n\n\n\n\n\n\n\nÉviter les doublons\nPour éviter les doublons dans les résultats d’une requête, on peut ajouter la clause DISTINCT juste après SELECT.\nConsidérons par exemple la relation “communes”, la requête suivante a pour objectif d’afficher, dans l’ordre croissant, la liste des codes postaux des communes du Cantal :\nSELECT codepostal\nFROM communes\nORDER BY codepostal\n\n\n\n\n\nNous voyons que les codes postaux sont répétés autant de fois qu’il y a de communes desservies par ce code postal.\nLa requête suivante, avec la clause DISTINCT, permet de n’afficher qu’une fois chacun des codes postaux considérés :\nSELECT DISTINCT codepostal\nFROM communes\nORDER BY codepostal\n\n\n\n\n\n\n\nLes jointures\nUne requête dans une base de donnée peut nécessiter de regrouper des données provenant de différentes tables.\n\n\n\n\n\n\nDéfinition\n\n\n\nUne requête combinant les données de plusieurs relations (tables) est appelée une jointure.\n\n\nPoursuivons avec l’exemple de la base de données des établissements scolaires du Cantal qui comporte deux tables, dont on rappelle ci-dessous le schéma relationnel :\n\ncommunes(Codecommune: INT, Nomdelacommune: TEXT, Populationtotale: INT, Codepostal: INT)\netablissements(code: TEXT, nom: TEXT, statut: TEXT, #id_commune: INT, latitude: FLOAT, longitude: FLOAT)\n\n\n\n\n\n\nLa requête suivante permet d’obtenir la table des noms d’établissements suivis du nom de leur commune. Il faut pour cela joindre les informations de la table “etablissements” (pour le nom de l’établissement) avec celles de la table “communes” (pour le nom de la commune). L’élément qui permet cette jointure est la clef étrangère “id_commune” de la table “etablissements” qui fait référence à la clef primaire “Codecommune” de la table “communes”.\nSELECT etablissements.nom, communes.Nomdelacommune \nFROM etablissements JOIN communes \nON etablissements.id_commune = communes.Codecommune\nRésultat :\n\n\n\n\n\n\n\n\n\n\n\nRemarque\n\n\n\nLorsqu’on effectue une jointure, plusieurs tables sont en jeu. Pour davantage de clarté, il est recommandé de préfixer chaque attribut par le nom de la table dont il provient. On utilise pour cela un point : “etablissements.nom” est l’attribut nommé “nom” de la relation “etablissements”.\n\n\nIl est possible d’ajouter à la suite de la jointure une clause WHERE afin de ne sélectionner que quelques lignes de la table obtenue :\nSELECT etablissements.nom, communes.Nomdelacommune \nFROM etablissements JOIN communes \nON etablissements.id_commune = communes.Codecommune\nWHERE etablissements.nom LIKE \"Collège%\"\nRésultat la table de tous les collèges avec leur commune :"
  },
  {
    "objectID": "BDD/sql_cours.html#requêtes-de-mise-à-jour",
    "href": "BDD/sql_cours.html#requêtes-de-mise-à-jour",
    "title": "2. Le langage SQL (Cours)",
    "section": "2.2. Requêtes de mise à jour",
    "text": "2.2. Requêtes de mise à jour\n\nAjouter une entrée\nPour ajouter une entrée, nous utilisons la clause INSERT.\nSupposons par exemple qu’un nouvel établissement soit ouvert à Labrousse (code 85): il s’agit d’un lycée hôtelier public. La requête suivante permet de créer cette nouvelle entrée. Attention, l’ordre des valeurs données doit être strictement le même que l’ordre des attributs cités.\nINSERT INTO etablissements\n(code, nom, statut, id_commune, latitude, longitude)\nVALUES\n(\"0159999Z\", \"Lycée hôtelier du Cantal\", \"Public\", 85, 44.8572222, 2.5427778)\n\n\nModifier une entrée existante\nPour modifier un ou plusieurs attributs d’un p-uplet existant, on utilise la clause UPDATE.\nSupposons par exemple que le nouveau lycée soit en fait un lycée Privé et que son code soit “0158888Z” :\nUPDATE etablissements\nSET code=\"0158888Z\", statut=\"Privé\"\nWHERE code=\"0159999Z\"\nLa clause WHERE permet de spécifier le ou les p-uplets à modifier.\n\n\nSupprimer une entrée\nPour supprimer un p-uplet, on utilise la clause DELETE.\nFinalement, le projet de lycée hôtelier est abandonné :\nDELETE FROM etablissements\nWHERE code=\"0158888Z\"\n\n\n\n\n\n\nAttention !\n\n\n\nLa requête DELETE, sans clause WHERE, supprimera tous les p-uplets de la relation !"
  },
  {
    "objectID": "BDD/sql_cours.html#quelques-compléments",
    "href": "BDD/sql_cours.html#quelques-compléments",
    "title": "2. Le langage SQL (Cours)",
    "section": "2.3. Quelques compléments",
    "text": "2.3. Quelques compléments\nLe langage SQL propose aussi des fonctions d’agrégation permettant de faire quelques calculs à partir des données d’une table. En voici quelques exemples.\n\nCalculer une somme\nPar exemple, la somme des populations de toutes les communes du Cantal :\nSELECT SUM(Populationtotale)\nFROM communes\nRésultat : 149 664.\n\n\nCalculer une moyenne\nPar exemple, la population moyenne des communes du Cantal dont le code postal est 15250 (AVG = average):\nSELECT AVG(Populationtotale)\nFROM communes\nwhere Codepostal=15250\nRésultat : 1 099, 67\n\n\nCalculer un minimum ou un maximum\nLes fonctions MIN et MAX fonctionnent de la même façon.\nQuel est le nom et la population de la commune du Cantal la moins peuplée ?\nSELECT Nomdelacommune, Populationtotale\nFROM communes\nWHERE Populationtotale = (SELECT MIN(Populationtotale) FROM communes)\nRésultat : VALJOUZE, 23 habitants.\n\n\n\n\n\n\nRemarque\n\n\n\nCe dernier exemple est un peu plus compliqué que les précédents : on a en effet imbriqué deux requêtes l’une dans l’autre : on parle de requêtes composées. La requête “SELECT MIN(Populationtotale) FROM communes” située entre parenthèses retourne la valeur minimale des populations de toutes les communes. On demande ensuite le nom de la ou des communes dont la population est cette valeur minimale. Prenez le temps de bien comprendre cet exemple.\n\n\n\n\nCompter des données\nLa fonction COUNT permet de compter des données.\nCombien y a-t-il d’établissements scolaires dans le Cantal ?\nSELECT COUNT(*)\nFROM etablissements\nRésultat : 203\nCombien de communes possèdent le code postal 15250 ?\nSELECT COUNT(*)\nFROM communes\nWHERE Codepostal=15250\nRésultat : 9\nCombien de noms d’établissements différents parmi les établissements scolaires ?\nSELECT COUNT(DISTINCT nom)\nFROM etablissements\nRésultat : 88\nÀ quelle question répond la requête suivante ?\nSELECT COUNT(*)\nFROM etablissements JOIN communes \nON etablissements.id_commune=communes.Codecommune\nWHERE (etablissements.nom LIKE \"Collège%\") AND communes.Nomdelacommune=\"AURILLAC\"\n\n\n\n\n\n\nRéponse\n\n\n\n\n\nCombien y a-t-il de collèges à Aurillac ? Réponse : 5.\n\n\n\n\n\n\n\n\n\nPour compléter …\n\n\n\n\nExcellentes vidéos sur Lumni :\n\nQu’est-ce qu’une base de données relationnelle ?\nInterrogation d’une base de données relationnelle"
  },
  {
    "objectID": "BDD/TP1.html",
    "href": "BDD/TP1.html",
    "title": "TP 1 - Créer une base de données",
    "section": "",
    "text": "Objectifs\n\n\n\nUtiliser le logiciel “DB Browser for SqLite” et le langage SQL pour :\n\n créer une base de données ;\n ajouter des données dans une table ;\n écrire et tester différentes requêtes."
  },
  {
    "objectID": "BDD/TP1.html#création-dune-bdd-et-insertion-de-valeurs",
    "href": "BDD/TP1.html#création-dune-bdd-et-insertion-de-valeurs",
    "title": "TP 1 - Créer une base de données",
    "section": "1. Création d’une BDD et insertion de valeurs",
    "text": "1. Création d’une BDD et insertion de valeurs\nPour créer une base de données et effectuer des requêtes sur cette dernière, nous allons utiliser le logiciel “DB Browser for SQLite” : https://sqlitebrowser.org/. Ce logiciel est intégré dans EduPython.\n\nOuvrez le logiciel, puis cliquez sur “Nouvelle base de données”. Après avoir choisi un nom pour votre base de données (par exemple “db_livres.db”), vous devriez avoir la fenêtre suivante :\n\n\n\n\n\nCliquez alors sur “Annuler”.\nUne nouvelle base de donnée a bien été créée, mais elle ne contient encore aucune table.\n\n\n\n\n\nPour créer une table, cliquez sur l’onglet “Exécuter le SQL”. On obtient alors :\n\n\n\n\n\nCopiez-collez le texte ci-dessous dans la fenêtre “SQL 1” :\nCREATE TABLE LIVRES\n    (id INT, titre TEXT, auteur TEXT, ann_publi INT, note INT, PRIMARY KEY (id));\nCliquez ensuite sur le petit triangle situé au-dessus de la fenêtre SQL 1 (ou appuyez sur F5), vous devriez avoir ceci :\n\n\n\n\n\nComme indiqué dans la fenêtre, “Requête exécutée avec succès” !\nQuelques explications : la commande CREATE TABLE LIVRES permet de créer une nouvelle table nommée “LIVRES”. Elle est suivie d’un p-uplet définissant les noms et les domaines des attributs de la nouvelle table :\n\nid est un entier ;\ntitre est une chaîne de caractères ;\nauteur est une chaîne de caractères ;\nann_pulbi est un entier ;\nnote est un entier ;\n\nL’attribut “id” va jouer le rôle de clé primaire, nous avons donc ajouté dans la requête la mention (PRIMARY KEY (id)). Le système de gestion de base de données nous avertira si l’on tente d’attribuer 2 fois la même valeur à l’attribut “id”.\nNous allons maintenant ajouter des données à la table LIVRES.\nToujours dans l’onglet “Exécuter le SQL”, après avoir effacé la fenêtre SQL 1, copiez-collez dans cette même fenêtre la requête ci-dessous :\nINSERT INTO LIVRES\n    (id,titre,auteur,ann_publi,note)\n    VALUES\n    (1,\"1984\",\"Orwell\",1949,10),\n    (2,\"Dune\",\"Herbert\",1965,8),\n    (3,\"Fondation\",\"Asimov\",1951,9),\n    (4,\"Le meilleur des mondes\",\"Huxley\",1931,7),\n    (5,\"Fahrenheit 451\",\"Bradbury\",1953,7),\n    (6,\"Ubik\",\"K.Dick\",1969,9),\n    (7,\"Chroniques martiennes\",\"Bradbury\",1950,8),\n    (8,\"La nuit des temps\",\"Barjavel\",1968,7),\n    (9,\"Blade Runner\",\"K.Dick\",1968,8),\n    (10,\"Les Robots\",\"Asimov\",1950,9),\n    (11,\"La Planète des singes\",\"Boulle\",1963,8),\n    (12,\"Ravage\",\"Barjavel\",1943,8),\n    (13,\"Le Maître du Haut Château\",\"K.Dick\",1962,8),\n    (14,\"Le monde des Ā\",\"Van Vogt\",1945,7),\n    (15,\"La Fin de l'éternité\",\"Asimov\",1955,8),\n    (16,\"De la Terre à la Lune\",\"Verne\",1865,10);\nUn message devrait vous préciser que votre requête a été exécutée avec succès :\n\n\n\n\n\nLa table LIVRES contient maintenant les données souhaitées (onglet “Parcourir les données”) :\n\n\n\n\n\nSaisissez et exécutez la requête SQL suivante :\nSELECT id, titre, auteur, ann_publi, note\nFROM LIVRES\nAprès un temps plus ou moins long, vous devriez voir s’afficher ceci :\n\n\n\n\n\nEffectuez une requête qui permettra d’obtenir le titre et l’auteur de tous les livres présents dans la table LIVRES.\nSaisissez et testez la requête SQL suivante :\nSELECT titre, ann_publi\nFROM LIVRES\nWHERE auteur='Asimov'\nÀ quelle question répond-elle ?\nÉcrivez et testez une requête permettant d’obtenir uniquement les titres des livres écrits par Philip K.Dick.\nSaisissez et testez la requête SQL suivante :\nSELECT titre, ann_publi\nFROM LIVRES\nWHERE auteur='Asimov' AND ann_publi&gt;1953\nÀ quelle question répond-elle ?\nÉcrivez une requête permettant d’obtenir les titres des livres publiés après 1945 qui ont une note supérieure ou égale à 9.\nÉcrivez une requête SQL permettant d’obtenir les titres et les années de publication des livres de K.Dick classés du plus ancien ou plus récent."
  },
  {
    "objectID": "BDD/TP1.html#avec-deux-tables",
    "href": "BDD/TP1.html#avec-deux-tables",
    "title": "TP 1 - Créer une base de données",
    "section": "2. Avec deux tables",
    "text": "2. Avec deux tables\nDans la première partie, nous avons une redondance d’information dans l’attribut auteur, un même auteur étant répété plusieurs fois. Pour remédier à cela, nous allons maintenant créer une nouvelle base avec deux tables AUTEURS et LIVRES reliées par une clef étrangère.\n\n\n\n\n\n\nCréez une nouvelle base de données que vous nommerez par exemple db_livres_auteurs.db, puis créez une table AUTEURS à l’aide de la requête SQL suivante :\nCREATE TABLE AUTEURS\n(id INT, nom TEXT, prenom TEXT, ann_naissance INT, langue_ecriture TEXT, PRIMARY KEY (id));\nCréez ensuite une deuxième table (LIVRES) :\nCREATE TABLE LIVRES\n(id INT, titre TEXT, id_auteur INT, ann_publi INT, note INT, PRIMARY KEY (id), FOREIGN KEY (id_auteur) REFERENCES AUTEURS(id));\nDans la création de la table LIVRES, nous avons précisé que l’attribut “id_auteur” jouera le rôle de clé étrangère : liaison entre “id_auteur” de la table LIVRES et “id” de la table AUTEURS (FOREIGN KEY (id_auteur) REFERENCES AUTEURS(id)).\nAjoutez des données à la table AUTEURS à l’aide de la requête SQL suivante :\nINSERT INTO AUTEURS\n(id,nom,prenom,ann_naissance,langue_ecriture)\nVALUES\n(1,\"Orwell\",\"George\",1903,\"anglais\"),\n(2,\"Herbert\",\"Frank\",1920,\"anglais\"),\n(3,\"Asimov\",\"Isaac\",1920,\"anglais\"),\n(4,\"Huxley\",\"Aldous\",1894,\"anglais\"),\n(5,\"Bradbury\",\"Ray\",1920,\"anglais\"),\n(6,\"K.Dick\",\"Philip\",1928,\"anglais\"),\n(7,\"Barjavel\",\"René\",1911,\"français\"),\n(8,\"Boulle\",\"Pierre\",1912,\"français\"),\n(9,\"Van Vogt\",\"Alfred Elton\",1912,\"anglais\"),\n(10,\"Verne\",\"Jules\",1828,\"français\");\nAjoutez des données à la table LIVRES à l’aide de la requête SQL suivante :\nINSERT INTO LIVRES\n(id,titre,id_auteur,ann_publi,note)\nVALUES\n(1,\"1984\",1,1949,10),\n(2,\"Dune\",2,1965,8),\n(3,\"Fondation\",3,1951,9),\n(4,\"Le meilleur des mondes\",4,1931,7),\n(5,\"Fahrenheit 451\",5,1953,7),\n(6,\"Ubik\",6,1969,9),\n(7,\"Chroniques martiennes\",5,1950,8),\n(8,\"La nuit des temps\",7,1968,7),\n(9,\"Blade Runner\",6,1968,8),\n(10,\"Les Robots\",3,1950,9),\n(11,\"La Planète des singes\",8,1963,8),\n(12,\"Ravage\",7,1943,8),\n(13,\"Le Maître du Haut Château\",6,1962,8),\n(14,\"Le monde des Ā\",9,1945,7),\n(15,\"La Fin de l'éternité\",3,1955,8),\n(16,\"De la Terre à la Lune\",10,1865,10);\nSaisissez et testez la requête SQL suivante :\nSELECT titre,nom, prenom\nFROM LIVRES JOIN AUTEURS \nON LIVRES.id_auteur = AUTEURS.id\nRemarque : attention, si un même nom d’attribut est présent dans les 2 tables (par exemple ici l’attribut id), il est nécessaire d’ajouter le nom de la table devant afin de pouvoir les distinguer (AUTEURS.id et LIVRES.id).\nÉcrivez une requête SQL permettant d’obtenir les titres des livres publiés après 1945 ainsi que le nom de leurs auteurs.\nOn souhaite ajouter à la base le livre de Arthur C.Clarke intitulé 2001 : L’Odyssée de l’espace publié en 1968 et noté 7. Arthur C.Clarke est un écrivain britannique né en 1917 et mort en 2008.\nÉcrivez les requêtes nécessaires à cet ajout. Vous n’oublierez pas de définir les clefs primaires pour chacune des nouvelles entrées.\nÉcrivez et testez une requête permettant d’attribuer la note de 10 à tous les livres écrits par Asimov publiés après 1950.\nÉcrivez une requête permettant de supprimer les livres publiés avant 1945. Testez cette requête."
  },
  {
    "objectID": "BDD/TP2.html",
    "href": "BDD/TP2.html",
    "title": "TP 2 - Le supermarché",
    "section": "",
    "text": "Objectifs\n\n\n\n\n écrire un schéma relationnel ;\n manipuler des requêtes SQL ;\n utiliser un SGBD."
  },
  {
    "objectID": "BDD/TP2.html#première-partie-travail-débranché",
    "href": "BDD/TP2.html#première-partie-travail-débranché",
    "title": "TP 2 - Le supermarché",
    "section": "Première partie : travail débranché",
    "text": "Première partie : travail débranché\nSans utiliser l’ordinateur, répondre aux questions de la fiche ci-dessous."
  },
  {
    "objectID": "BDD/TP2.html#vérifications-avec-db-browser-sqlite-et-compléments",
    "href": "BDD/TP2.html#vérifications-avec-db-browser-sqlite-et-compléments",
    "title": "TP 2 - Le supermarché",
    "section": "Vérifications avec DB Browser SqLite et compléments",
    "text": "Vérifications avec DB Browser SqLite et compléments\n\nOuvrir dans le logiciel la table ExerciceSupermarche.db.\nVérifier les requêtes écrites dans la première partie.\nInsérer dans la base de données un nouveau client en utilisant vos propres informations personnelles.\nModifier vos données en vous donnant le prénom “Toto”.\nSupprimer votre enregistrement de la table “Clients”."
  },
  {
    "objectID": "BDD/TP3.html",
    "href": "BDD/TP3.html",
    "title": "TP 3 - BDD et Python",
    "section": "",
    "text": "Dans ce TP (source : LASSUS (2021)), nous allons créer et interroger une base de données sqlite avec le module sqlite3 de Python."
  },
  {
    "objectID": "BDD/TP3.html#création-dune-table",
    "href": "BDD/TP3.html#création-dune-table",
    "title": "TP 3 - BDD et Python",
    "section": "Création d’une table",
    "text": "Création d’une table\nimport sqlite3\n\n#Connexion\nconnexion = sqlite3.connect('mynewbase.db')\n\n#Récupération d'un curseur\nc = connexion.cursor()\n\n# ---- début des instructions SQL\n\n#Création de la table\nc.execute(\"\"\"\n    CREATE TABLE IF NOT EXISTS bulletin(\n    Nom TEXT,\n    Prénom TEXT,\n    Note INT);\n    \"\"\")\n\n# ---- fin des instructions SQL\n\n#Validation\nconnexion.commit()\n\n\n#Déconnexion\nconnexion.close()\n\nLe fichier mynewbase.db sera créé dans le même répertoire que le fichier source Python. Si le fichier existe déjà, il est ouvert et peut être modifié.\nIF NOT EXISTS assure de ne pas écraser une table existante qui porterait le même nom. Si une telle table existe, elle n’est alors pas modifiée.\nLa nouvelle table peut être ouverte avec DB Browser pour vérifier sa structure et ses données."
  },
  {
    "objectID": "BDD/TP3.html#insertion-denregistrements-dans-la-table",
    "href": "BDD/TP3.html#insertion-denregistrements-dans-la-table",
    "title": "TP 3 - BDD et Python",
    "section": "Insertion d’enregistrements dans la table",
    "text": "Insertion d’enregistrements dans la table\nLes morceaux de code ci-dessous sont à positionner entre les balises # ---- début des instructions SQL et # ---- fin des instructions SQL.\n\nInsertion d’un enregistrement unique\nc.execute('''INSERT INTO bulletin VALUES ('Simpson', 'Bart', 17)''')\nPensez à vérifier avec DB Browser si les modifications sont effectives.\n\n\nInsertion d’un enregistrement unique avec variable\ndata = ('Simpson', 'Maggie', 2)\nc.execute('''INSERT INTO bulletin VALUES (?,?,?)''', data)\n\n\nInsertion de multiples enregistrements\nlst_notes = [ ('Simpson', 'Lisa', 19), ('Muntz', 'Nelson', 4), ('Van Houten', 'Milhouse', 12) ]\n\nc.executemany('''INSERT INTO bulletin VALUES (?, ?, ?)''', lst_notes)\nLes différentes valeurs sont stockées au préalable dans une liste de tuples.\n\n\nMini-projet 1\nCréer un programme qui demande à l’utilisateur un nom et une note, en boucle. Les résultats sont stockés au fur et à mesure dans une base de données. Si le nom est égal à «Q» ou «q», le programme s’arrête.\n\n\nExemple d’injection SQL\nL’injection SQL est une technique consistant à écrire du code SQL à un endroit qui n’est pas censé en recevoir.\n\nCréez un fichier contenant le code suivant :\n\nimport sqlite3\n\n#Connexion\nconnexion = sqlite3.connect('mabasecobaye.db')\n\n#Récupération d'un curseur\nc = connexion.cursor()\n\nc.execute(\"\"\"\n    CREATE TABLE IF NOT EXISTS notes(\n    Nom TEXT,\n    Note INT);\n    \"\"\")\n\nwhile True :\n    nom = input('Nom ? ')\n    if nom in ['Q','q'] :\n        break\n    note = input('Note ? ')\n    data = (nom, note)\n    p = \"INSERT INTO notes VALUES ('\" + nom + \"','\" + note + \"')\"\n\n    c.executescript(p)\n\n#Validation\nconnexion.commit()\n\n#Déconnexion\nconnexion.close()\n\nExécutez ce fichier, rentrez quelques valeurs, quittez et ouvrez dans DB Browser la table notes pour bien vérifier que vos valeurs ont bien été stockées.\nLancez à nouveau le fichier, en donnant ensuite comme nom la chaîne de caractères suivante : g','3'); DROP TABLE notes;--\nDonnez une note quelconque (par exemple 12), quittez le programme… et allez observer l’état de la base de données. La table notes n’existe plus !\n\nExplication :\nLa requête qui a été formulée est INSERT INTO notes VALUES ('g','3'); DROP TABLE notes;--','12')\nDans un premier temps, le couple ('g','3') a été inséré.\nPuis l’ordre a été donné de détruire la table notes.\nLe reste du code (qui n’est pas correct) est ignoré car -- est le symbole du commentaire en SQL (l’équivalent du # de Python).\nRemarques : Évidemment, ce code a été fait spécifiquement pour être vulnérable à l’injection SQL. Il suffit d’ailleurs de remplacer le c.executescript(p) par c.execute(p) pour que le code reste fonctionnel, mais refuse l’injection SQL. Ceci dit, de nombreux serveurs sont encore attaqués par cette technique, au prix de manipulations bien sûr plus complexes que celles que nous venons de voir.\nRappelons enfin que ce genre de pratiques est interdit sur un serveur qui ne vous appartient pas."
  },
  {
    "objectID": "BDD/TP3.html#lecture-des-enregistrements",
    "href": "BDD/TP3.html#lecture-des-enregistrements",
    "title": "TP 3 - BDD et Python",
    "section": "Lecture des enregistrements",
    "text": "Lecture des enregistrements\nimport sqlite3\n\n#Connexion\nconnexion = sqlite3.connect('mynewbase.db')\n\n#Récupération d'un curseur\nc = connexion.cursor()\n\ndata = ('Simpson', )\n\nc.execute(\"SELECT Prénom FROM Bulletin WHERE Nom = ?\", data)\nprint(c.fetchall())  \n\n\n#Déconnexion\nconnexion.close()\nCe code renvoie [('Homer',), ('Lisa',), ('Maggie',)], ou une liste vide s’il n’y a pas de résultat à la requête.\n\nMini-projet 2\nReprendre le mini-projet précédent, en rendant possible à l’utilisateur de rentrer des notes ou bien de les consulter.\nExemple :"
  },
  {
    "objectID": "GrandOral/grandOral.html",
    "href": "GrandOral/grandOral.html",
    "title": "NSI - Terminale",
    "section": "",
    "text": "Le grand oral est une épreuve orale qui se dérouler en juin. Son coefficient est de 10 (sur un total de 100). Vous devez préparer en première et surtout en terminale deux questions en rapport avec vos spécialités de terminale. Page de présentation officielle du grand oral Article du bulletin officiel (BO) définissant le grand oral."
  },
  {
    "objectID": "GrandOral/grandOral.html#présentation",
    "href": "GrandOral/grandOral.html#présentation",
    "title": "NSI - Terminale",
    "section": "",
    "text": "Le grand oral est une épreuve orale qui se dérouler en juin. Son coefficient est de 10 (sur un total de 100). Vous devez préparer en première et surtout en terminale deux questions en rapport avec vos spécialités de terminale. Page de présentation officielle du grand oral Article du bulletin officiel (BO) définissant le grand oral."
  },
  {
    "objectID": "GrandOral/grandOral.html#les-deux-questions",
    "href": "GrandOral/grandOral.html#les-deux-questions",
    "title": "NSI - Terminale",
    "section": "Les deux questions",
    "text": "Les deux questions\n\nRépartition des spécialités\nLe BO dit : “ces questions portent sur les deux enseignements de spécialité soit pris isolément, soit abordés de manière transversale”. On comprend qu’il est nécessaire d’aborder les deux enseignements de spécialité, et qu’il est possible de les mélanger. Néanmoins il semblerait qu’il soit nécessaire (pour des raisons d’organisation, voir plus bas) d’avoir une spécialité majeure différente dans chaque question. Voici donc le schéma des répartitions possibles des spécialités (A et B) dans les deux questions (1 et 2) :\n\n\n\nQuestion 1\nQuestion 2\n\n\n\n\nA\nB\n\n\nA\nmajeure B et mineure A\n\n\nmajeure A et mineure B\nB\n\n\nmajeure A et mineure B\nmajeure B et mineure A\n\n\n\nBien sûr, le caractère majeur ou mineur d’une spécialité dans une question peut être sujet à discussion. Cela donne néanmoins un cadre de réflexion.\n\n\nSujet des questions\nEncore une fois le BO est assez concis : Elles mettent en lumière un des grands enjeux du ou des programmes de ces enseignements [de spécialité]. Elles sont adossées à tout ou partie du programme du cycle terminal. Les questions doivent donc avoir un lien avec le programme de terminale ou éventuellement de première. La question de NSI (ou de majeure NSI) doit donc s’inscrire dans les thèmes suivants :\nPour la terminale :\n\nhistoire de l’informatique ;\nstructures de données ;\nbases de données ;\narchitectures matérielles, systèmes d’exploitation et réseaux ;\nlangages et programmation\nalgorithmique\n\nPour la première :\n\nhistoire de l’informatique ;\nreprésentation des données: types et valeurs de base ;\nreprésentation des données: types construits ;\ntraitement de données en tables ;\ninteractions entre l’homme et la machine sur le Web\narchitectures matérielles et systèmes d’exploitation\nlangages et programmation\nalgorithmique\n\nDans ce document offiicel, on peut lire :\n\nL’entrée choisie par l’élève peut être variée : le choix du champ disciplinaire dans un parcours d’orientation ; des exemples de notions mathématiques qui ont changé son regard ou lui ont apporté des clés de lecture ; des obstacles didactiques auxquels il a été confronté ; une notion du programme ; un point de l’histoire des sciences ; une démonstration ; un lien avec une autre spécialité, une attention portée à une notion pour ses enjeux sociétaux ou dans un parcours d’orientation comme l’éducation à la santé, au développement durable, aux médias et à l’information, aux problèmes bioéthiques.\n\nSi la question rentre dans ces critères, elle peut donc être valide.\n\n\nDéroulement\n\nChoix de la question\nVous serez évalué par un jury composé d’un professeur d’une de vos spécialités et d’un professeur d’une autre matière (votre autre spécialité ou non). Le jury choisira donc la question pour laquelle il est compétent.\n\n\n20 minutes de préparation\nUne fois que vous connaissez la question choisie par le jury, vous avez 20 minutes pour mettre vos idées au clair. Vous avez la possibilité de réaliser un support sur ue feuille fournie. Vous pouvez donner ce support au jury au début de l’entretien.\n\n\n20 minutes d’entretien\nL’entretien se déroule en trois temps. Tout l’entretien se fait sans notes et sans support excepté, éventuellement, celui que vous avez créé pendant votre préparation.\n\n\n\n\n\n\nPrécisions au sujet du support papier\n\n\n\nCe support est une aide pour la parole du candidat ; il n’a pas vocation à être donné à lire au jury. Il s’agit de notes, d’un plan d’exposé, de trame de prise de parole, de mots-clefs ou d’idées directrices. Ces notes peuvent aussi servir de document d’appui à l’argumentation (schéma, courbe, diagramme, tableau, formule mathématique…).\nSource : Eduscol\n\n\n\n5 minutes de présentation\nVous disposez de 5 minutes pour :\n\nexpliquer pourquoi vous avez choisi cette question ;\ndévelopper le question ;\ny répondre.\n\nLe jury ne vous interrompt pas sauf si vous dépassez du temps imparti. Tout cela se fait sans notes et sans support.\n\n\n10 minutes d’échange avec le jury\nPendant ce temps, le jury vous interroge sur votre question, il demande des précisions. Il peut élargir les questions au thème abordé puis à tout le programme de terminale et première.\n\n\n5 minutes d’échange sur votre projet d’orientation\nIl est conseillé de faire un lien entre la question traitée et votre projet d’orientation. Vous devez expliquer les étapes de la maturation de votre projet d’orientation et détailler votre projet après le bac.\n\n\n\n\nÉvaluation\nLors de votre présentation, le jury évalue les capacités argumentatives et les qualités oratoires du candidat. Vous n’êtes pas évalué ici sur le fond, mais plutôt sur la forme (je rappelle qu’il y aura vraisemblablement un membre du jury qui n’aura rien compris à ce que vous avez dit).\nLors de l’échange avec le jury, il évalue la solidité des connaissances et les capacités argumentatives du candidat. Vous êtes donc évalué ici sur vos connaissances.\nLors de l’échange sur votre projet d’orientation, le jury mesure la capacité du candidat à conduire et exprimer une réflexion personnelle témoignant de sa curiosité intellectuelle et de son aptitude à exprimer ses motivations. Il n’évalue surtout pas votre projet d’orientation en lui-même."
  },
  {
    "objectID": "GrandOral/grandOral.html#exemples-de-sujets",
    "href": "GrandOral/grandOral.html#exemples-de-sujets",
    "title": "NSI - Terminale",
    "section": "Exemples de sujets",
    "text": "Exemples de sujets\n\nExemples issus du document officiel\n\nL’histoire de l’informatique\n\nFemmes et numérique : quelle histoire ? quel avenir ?\nAda Lovelace, pionnière du langage informatique.\nAlan Turing, et l’informatique fut.\nQuelle est la différence entre le web 1.0 et le web 2.0 ?\n\n\n\nLangages et programmation\n\nP = NP, un problème à un million de dollars ?\nTours de Hanoï : plus qu’un jeu d’enfants ?\nLes fractales : informatique et mathématiques imitent-elles la nature ?\nDe la récurrence à la récursivité.\nLes bugs : bête noire des développeurs ?\nComment rendre l’informatique plus sûre ?\n\n\n\nDonnées structurées et structures de données\n\nL’informatisation des métros : progrès ou outil de surveillance ?\nMusique et informatique : une alliance possible de l’art et de la science ?\n\n\n\nAlgorithmique\n\nComment créer une machine intelligente ?\nComment lutter contre les biais algorithmiques ?\nQuels sont les enjeux de la reconnaissance faciale (notamment éthiques) ?\nQuels sont les enjeux de l’intelligence artificielle ?\nTransformation d’images : Deep Fakes, une arme de désinformation massive ? La fin de la preuve par l’image ?\nQu’apporte la récursivité dans un algorithme ?\nQuel est l’impact de la complexité d’un algorithme sur son efficacité ?\n\n\n\nBases de données\n\nDonnées personnelles : la vie privée en voie d’extinction ?\nComment optimiser les données ?\n\n\n\nArchitectures matérielles, systèmes d’exploitation et réseaux\n\nL’ordinateur quantique : nouvelle révolution informatique ?\nLa course à l’infiniment petit : jusqu’où ?\nPeut-on vraiment sécuriser les communications ?\nQuelle est l’utilité des protocoles pour l’internet ?\nCyberguerre : la 3e guerre mondiale ?\n\n\n\nInterfaces Hommes-Machines (IHM)\n\nSmart cities, smart control ?\nLa réalité virtuelle : un nouveau monde ?\nLa voiture autonome, quels enjeux ?\n\n\n\nImpact sociétal et éthique de l’informatique\n\nComment protéger les données numériques sur les réseaux sociaux ?\nQuelle est l’empreinte carbone du numérique en termes de consommation ?\nPourquoi chiffrer ses communications ?\nLes réseaux sociaux sont-ils compatibles avec la politique ?\nLes réseaux sociaux sont-ils compatibles avec le journalisme ?\nLes réseaux sociaux permettent-ils de lutter contre les infox ?\nL’informatique va-t-elle révolutionner le dessin animé ?\nL’informatique va-t-elle révolutionner la composition musicale ?\nL’informatique va-t-elle révolutionner l’art ?\nL’informatique va-t-elle révolutionner le cinéma ?\nL’informatique va-t-elle révolutionner la médecine ?\nL’informatique va-t-elle révolutionner la physique ?\nL’informatique va-t-elle révolutionner l’entreprise ?\nLe numérique : facteur de démocratisation ou de fractures sociales ?\nInformatique : quel impact sur le climat ?\n\n\n\n\nExemples issus des sujets choisis les années précédentes\n\nPourquoi Javascript est-il devenu le langage le plus utilisé au monde ?\nPourquoi chiffrer les communications ?\nL’informatique va-t-elle révolutionner le dessin animé ?\nComment l’informatique a-t-elle révolutionné la vie des gens dans le domaine du divertissement au fil des années ?\nComment fonctionnent les bases de données distribuées ?\nNos informations personnelles sont-elles en sécurité dans les bases de données ?\nComment l’informatique s’inspire du vivant ?\nEnigma et décryptage. En quoi l’informatique a-t-elle fait évoluer les maths ?\nComment évolue la cyber-sécurité ?\nModélisation 3D et graphes.\nL’art algorithmique est-il vraiment un art ?\nComment protéger les données numériques sur les réseaux\nQuels sont les enjeux des cyberguerres ?\nFractales, l’info et les maths imitent-elles la nature ?\nLes réseaux sociaux sont-ils compatibles avec la politique ?\nAvenir de la réalité virtuelle ?\nLes réseaux sociaux sont-ils compatibles avec le journalisme ?\nEn quoi la cryptologie a-t-elle permis de raccourcir la deuxième guerre mondiale ?\nComment fonctionne Tor ?\nComment flash est-il passé du statu d’utilisable à mort en 2021 ?\nPourquoi Python a-t-il été inventé ?\nComment l’automate cellulaire peut-il imiter les êtres vivants par de simples règles informatiques ?\nComment HTML 5 a révolutionné le développement web ?\nQuelles ont été les évolutions de l’utilisation d’internet ?\n(Maths/Info) Quel est l’impact de la complexité d’un algorithme sur son efficacité ?\nComment optimiser le traitement des données ?\nLa machine de Turing est-elle obsolète ?\n(Maths/Info) De la récurrence à la récursivité.\n(Maths/Info) La course à l’infiniment petit, jusqu’où ?\n(Info/Phy?) En quoi l’ordinateur quantique est-il révolutionnaire ?\nQu’apporte la récursivité dans un algorithme ?\nPeut-on vraiment sécuriser les communications ?\nQuels sont les enjeux de l’intelligence artificielle ?\n(Maths/info) P=NP, un problème à un million de dollars.\nComment rendre l’informatique plus sûre ?\n(Info/ Maths) En quoi la machine Enigma a t-elle révolutionnée l’informatique ?\n(Info/ Maths) Un ordinateur peut-il écrire une démonstration mathématique ?\n\n\nSources\n\nhttps://kxs.fr/cours/grand-oral/exemples\nhttps://bfourlegnie.com/Tnsi_2020/cours/Gd_oral/grand_oral_NSI.pdf"
  },
  {
    "objectID": "GrandOral/index.html",
    "href": "GrandOral/index.html",
    "title": "Grand Oral et NSI",
    "section": "",
    "text": "Le grand oral est une épreuve orale qui se dérouler en juin. Son coefficient est de 10 (sur un total de 100). Vous devez préparer en première et surtout en terminale deux questions en rapport avec vos spécialités de terminale. Page de présentation officielle du grand oral Article du bulletin officiel (BO) définissant le grand oral."
  },
  {
    "objectID": "GrandOral/index.html#présentation",
    "href": "GrandOral/index.html#présentation",
    "title": "Grand Oral et NSI",
    "section": "",
    "text": "Le grand oral est une épreuve orale qui se dérouler en juin. Son coefficient est de 10 (sur un total de 100). Vous devez préparer en première et surtout en terminale deux questions en rapport avec vos spécialités de terminale. Page de présentation officielle du grand oral Article du bulletin officiel (BO) définissant le grand oral."
  },
  {
    "objectID": "GrandOral/index.html#les-deux-questions",
    "href": "GrandOral/index.html#les-deux-questions",
    "title": "Grand Oral et NSI",
    "section": "Les deux questions",
    "text": "Les deux questions\n\nRépartition des spécialités\nLe BO dit : “ces questions portent sur les deux enseignements de spécialité soit pris isolément, soit abordés de manière transversale”. On comprend qu’il est nécessaire d’aborder les deux enseignements de spécialité, et qu’il est possible de les mélanger. Néanmoins il semblerait qu’il soit nécessaire (pour des raisons d’organisation, voir plus bas) d’avoir une spécialité majeure différente dans chaque question. Voici donc le schéma des répartitions possibles des spécialités (A et B) dans les deux questions (1 et 2) :\n\n\n\nQuestion 1\nQuestion 2\n\n\n\n\nA\nB\n\n\nA\nmajeure B et mineure A\n\n\nmajeure A et mineure B\nB\n\n\nmajeure A et mineure B\nmajeure B et mineure A\n\n\n\nBien sûr, le caractère majeur ou mineur d’une spécialité dans une question peut être sujet à discussion. Cela donne néanmoins un cadre de réflexion.\n\n\nSujet des questions\nEncore une fois le BO est assez concis : Elles mettent en lumière un des grands enjeux du ou des programmes de ces enseignements [de spécialité]. Elles sont adossées à tout ou partie du programme du cycle terminal. Les questions doivent donc avoir un lien avec le programme de terminale ou éventuellement de première. La question de NSI (ou de majeure NSI) doit donc s’inscrire dans les thèmes suivants :\nPour la terminale :\n\nhistoire de l’informatique ;\nstructures de données ;\nbases de données ;\narchitectures matérielles, systèmes d’exploitation et réseaux ;\nlangages et programmation\nalgorithmique\n\nPour la première :\n\nhistoire de l’informatique ;\nreprésentation des données: types et valeurs de base ;\nreprésentation des données: types construits ;\ntraitement de données en tables ;\ninteractions entre l’homme et la machine sur le Web\narchitectures matérielles et systèmes d’exploitation\nlangages et programmation\nalgorithmique\n\nDans ce document offiicel, on peut lire :\n\nL’entrée choisie par l’élève peut être variée : le choix du champ disciplinaire dans un parcours d’orientation ; des exemples de notions mathématiques qui ont changé son regard ou lui ont apporté des clés de lecture ; des obstacles didactiques auxquels il a été confronté ; une notion du programme ; un point de l’histoire des sciences ; une démonstration ; un lien avec une autre spécialité, une attention portée à une notion pour ses enjeux sociétaux ou dans un parcours d’orientation comme l’éducation à la santé, au développement durable, aux médias et à l’information, aux problèmes bioéthiques.\n\nSi la question rentre dans ces critères, elle peut donc être valide.\n\n\nDéroulement\n\nChoix de la question\nVous serez évalué par un jury composé d’un professeur d’une de vos spécialités et d’un professeur d’une autre matière (votre autre spécialité ou non). Le jury choisira donc la question pour laquelle il est compétent.\n\n\n20 minutes de préparation\nUne fois que vous connaissez la question choisie par le jury, vous avez 20 minutes pour mettre vos idées au clair. Vous avez la possibilité de réaliser un support sur ue feuille fournie. Vous pouvez donner ce support au jury au début de l’entretien.\n\n\n20 minutes d’entretien\nL’entretien se déroule en trois temps. Tout l’entretien se fait sans notes et sans support excepté, éventuellement, celui que vous avez créé pendant votre préparation.\n\n\n\n\n\n\nPrécisions au sujet du support papier\n\n\n\nCe support est une aide pour la parole du candidat ; il n’a pas vocation à être donné à lire au jury. Il s’agit de notes, d’un plan d’exposé, de trame de prise de parole, de mots-clefs ou d’idées directrices. Ces notes peuvent aussi servir de document d’appui à l’argumentation (schéma, courbe, diagramme, tableau, formule mathématique…).\nSource : Eduscol\n\n\n\n5 minutes de présentation\nVous disposez de 5 minutes pour :\n\nexpliquer pourquoi vous avez choisi cette question ;\ndévelopper le question ;\ny répondre.\n\nLe jury ne vous interrompt pas sauf si vous dépassez du temps imparti. Tout cela se fait sans notes et sans support.\n\n\n10 minutes d’échange avec le jury\nPendant ce temps, le jury vous interroge sur votre question, il demande des précisions. Il peut élargir les questions au thème abordé puis à tout le programme de terminale et première.\n\n\n5 minutes d’échange sur votre projet d’orientation\nIl est conseillé de faire un lien entre la question traitée et votre projet d’orientation. Vous devez expliquer les étapes de la maturation de votre projet d’orientation et détailler votre projet après le bac.\n\n\n\n\nÉvaluation\nLors de votre présentation, le jury évalue les capacités argumentatives et les qualités oratoires du candidat. Vous n’êtes pas évalué ici sur le fond, mais plutôt sur la forme (je rappelle qu’il y aura vraisemblablement un membre du jury qui n’aura rien compris à ce que vous avez dit).\nLors de l’échange avec le jury, il évalue la solidité des connaissances et les capacités argumentatives du candidat. Vous êtes donc évalué ici sur vos connaissances.\nLors de l’échange sur votre projet d’orientation, le jury mesure la capacité du candidat à conduire et exprimer une réflexion personnelle témoignant de sa curiosité intellectuelle et de son aptitude à exprimer ses motivations. Il n’évalue surtout pas votre projet d’orientation en lui-même."
  },
  {
    "objectID": "GrandOral/index.html#exemples-de-sujets",
    "href": "GrandOral/index.html#exemples-de-sujets",
    "title": "Grand Oral et NSI",
    "section": "Exemples de sujets",
    "text": "Exemples de sujets\n\nExemples issus du document officiel\n\nL’histoire de l’informatique\n\nFemmes et numérique : quelle histoire ? quel avenir ?\nAda Lovelace, pionnière du langage informatique.\nAlan Turing, et l’informatique fut.\nQuelle est la différence entre le web 1.0 et le web 2.0 ?\n\n\n\nLangages et programmation\n\nP = NP, un problème à un million de dollars ?\nTours de Hanoï : plus qu’un jeu d’enfants ?\nLes fractales : informatique et mathématiques imitent-elles la nature ?\nDe la récurrence à la récursivité.\nLes bugs : bête noire des développeurs ?\nComment rendre l’informatique plus sûre ?\n\n\n\nDonnées structurées et structures de données\n\nL’informatisation des métros : progrès ou outil de surveillance ?\nMusique et informatique : une alliance possible de l’art et de la science ?\n\n\n\nAlgorithmique\n\nComment créer une machine intelligente ?\nComment lutter contre les biais algorithmiques ?\nQuels sont les enjeux de la reconnaissance faciale (notamment éthiques) ?\nQuels sont les enjeux de l’intelligence artificielle ?\nTransformation d’images : Deep Fakes, une arme de désinformation massive ? La fin de la preuve par l’image ?\nQu’apporte la récursivité dans un algorithme ?\nQuel est l’impact de la complexité d’un algorithme sur son efficacité ?\n\n\n\nBases de données\n\nDonnées personnelles : la vie privée en voie d’extinction ?\nComment optimiser les données ?\n\n\n\nArchitectures matérielles, systèmes d’exploitation et réseaux\n\nL’ordinateur quantique : nouvelle révolution informatique ?\nLa course à l’infiniment petit : jusqu’où ?\nPeut-on vraiment sécuriser les communications ?\nQuelle est l’utilité des protocoles pour l’internet ?\nCyberguerre : la 3e guerre mondiale ?\n\n\n\nInterfaces Hommes-Machines (IHM)\n\nSmart cities, smart control ?\nLa réalité virtuelle : un nouveau monde ?\nLa voiture autonome, quels enjeux ?\n\n\n\nImpact sociétal et éthique de l’informatique\n\nComment protéger les données numériques sur les réseaux sociaux ?\nQuelle est l’empreinte carbone du numérique en termes de consommation ?\nPourquoi chiffrer ses communications ?\nLes réseaux sociaux sont-ils compatibles avec la politique ?\nLes réseaux sociaux sont-ils compatibles avec le journalisme ?\nLes réseaux sociaux permettent-ils de lutter contre les infox ?\nL’informatique va-t-elle révolutionner le dessin animé ?\nL’informatique va-t-elle révolutionner la composition musicale ?\nL’informatique va-t-elle révolutionner l’art ?\nL’informatique va-t-elle révolutionner le cinéma ?\nL’informatique va-t-elle révolutionner la médecine ?\nL’informatique va-t-elle révolutionner la physique ?\nL’informatique va-t-elle révolutionner l’entreprise ?\nLe numérique : facteur de démocratisation ou de fractures sociales ?\nInformatique : quel impact sur le climat ?\n\n\n\n\nExemples issus des sujets choisis les années précédentes\n\nPourquoi Javascript est-il devenu le langage le plus utilisé au monde ?\nPourquoi chiffrer les communications ?\nL’informatique va-t-elle révolutionner le dessin animé ?\nComment l’informatique a-t-elle révolutionné la vie des gens dans le domaine du divertissement au fil des années ?\nComment fonctionnent les bases de données distribuées ?\nNos informations personnelles sont-elles en sécurité dans les bases de données ?\nComment l’informatique s’inspire du vivant ?\nEnigma et décryptage. En quoi l’informatique a-t-elle fait évoluer les maths ?\nComment évolue la cyber-sécurité ?\nModélisation 3D et graphes.\nL’art algorithmique est-il vraiment un art ?\nComment protéger les données numériques sur les réseaux\nQuels sont les enjeux des cyberguerres ?\nFractales, l’info et les maths imitent-elles la nature ?\nLes réseaux sociaux sont-ils compatibles avec la politique ?\nAvenir de la réalité virtuelle ?\nLes réseaux sociaux sont-ils compatibles avec le journalisme ?\nEn quoi la cryptologie a-t-elle permis de raccourcir la deuxième guerre mondiale ?\nComment fonctionne Tor ?\nComment flash est-il passé du statu d’utilisable à mort en 2021 ?\nPourquoi Python a-t-il été inventé ?\nComment l’automate cellulaire peut-il imiter les êtres vivants par de simples règles informatiques ?\nComment HTML 5 a révolutionné le développement web ?\nQuelles ont été les évolutions de l’utilisation d’internet ?\n(Maths/Info) Quel est l’impact de la complexité d’un algorithme sur son efficacité ?\nComment optimiser le traitement des données ?\nLa machine de Turing est-elle obsolète ?\n(Maths/Info) De la récurrence à la récursivité.\n(Maths/Info) La course à l’infiniment petit, jusqu’où ?\n(Info/Phy?) En quoi l’ordinateur quantique est-il révolutionnaire ?\nQu’apporte la récursivité dans un algorithme ?\nPeut-on vraiment sécuriser les communications ?\nQuels sont les enjeux de l’intelligence artificielle ?\n(Maths/info) P=NP, un problème à un million de dollars.\nComment rendre l’informatique plus sûre ?\n(Info/ Maths) En quoi la machine Enigma a t-elle révolutionnée l’informatique ?\n(Info/ Maths) Un ordinateur peut-il écrire une démonstration mathématique ?\n\n\nSources\n\nhttps://kxs.fr/cours/grand-oral/exemples\nhttps://bfourlegnie.com/Tnsi_2020/cours/Gd_oral/grand_oral_NSI.pdf"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Spécialité NSI - Terminale",
    "section": "",
    "text": "Bienvenue !\nCe site est destiné à regrouper les cours et les exercices concernant l’enseignement de spécialité NSI de terminale du lycée Emile Duclaux d’Aurillac.\nLien vers l’ENT du lycée : https://cas.ent.auvergnerhonealpes.fr/login"
  },
  {
    "objectID": "langagesProgr/index.html",
    "href": "langagesProgr/index.html",
    "title": "Programme",
    "section": "",
    "text": "Points du programme traités dans cette séquence :\n\n\n\n\n\n\n\n\nContenus\nCapacités attendues\nCommentaires\n\n\n\n\nRécursivité.\nÉcrire un programme récursif. Analyser le fonctionnement d’un programme récursif.\nDes exemples relevant de domaines variés sont à privilégier.\n\n\nParadigmes de programmation.\nDistinguer sur des exemples les paradigmes impératif, fonctionnel et objet. Choisir le paradigme de programmation selon le champ d’application d’un programme.\nAvec un même langage de programmation, on peut utiliser des paradigmes différents. Dans un même programme, on peut utiliser des paradigmes différents.\n\n\nVocabulaire de la programmation objet : classes, attributs, méthodes, objets.\nÉcrire la définition d’une classe. Accéder aux attributs et méthodes d’une classe.\nOn n’aborde pas ici tous les aspects de la programmation objet comme le polymorphisme et l’héritage."
  },
  {
    "objectID": "langagesProgr/index.html#programme-de-la-séquence",
    "href": "langagesProgr/index.html#programme-de-la-séquence",
    "title": "Programme",
    "section": "",
    "text": "Points du programme traités dans cette séquence :\n\n\n\n\n\n\n\n\nContenus\nCapacités attendues\nCommentaires\n\n\n\n\nRécursivité.\nÉcrire un programme récursif. Analyser le fonctionnement d’un programme récursif.\nDes exemples relevant de domaines variés sont à privilégier.\n\n\nParadigmes de programmation.\nDistinguer sur des exemples les paradigmes impératif, fonctionnel et objet. Choisir le paradigme de programmation selon le champ d’application d’un programme.\nAvec un même langage de programmation, on peut utiliser des paradigmes différents. Dans un même programme, on peut utiliser des paradigmes différents.\n\n\nVocabulaire de la programmation objet : classes, attributs, méthodes, objets.\nÉcrire la définition d’une classe. Accéder aux attributs et méthodes d’une classe.\nOn n’aborde pas ici tous les aspects de la programmation objet comme le polymorphisme et l’héritage."
  },
  {
    "objectID": "langagesProgr/paradigmes_cours.html",
    "href": "langagesProgr/paradigmes_cours.html",
    "title": "Paradigmes de programmation (Cours)",
    "section": "",
    "text": "Tout d’abord, nous pouvons nous demander ce que signifie le mot paradigme. Parmi les trois définitions fournies par le dictionnaire Le Robert, celle qui nous intéresse est la suivante :\n\n\n\n\n\n\nDéfinition\n\n\n\n\nParadigme\n\nModèle de pensée.\n\n\n\n\nEn programmation, un paradigme est donc une manière de penser un programme, une méthode de programmation.\nUn programme est un texte, avec ses conventions d’écriture. Il s’agit bien d’un langage écrit, au sens commun, mais il doit toujours avoir un sens univoque et non contextuel.\nIl faut que la formulation textuelle d’un programme soit :\n\nsuffisamment proche d’un code réel, conforme à une famille d’ordinateurs particuliers ;\nstandardisée et générale pour permettre une adaptation immédiate et automatique — on parle de « portabilité » — à d’autres contextes similaires ;\nparfaitement univoque, non ambiguë, puisque destinée à un traitement automatique ;\nintelligible par un être humain.\n\nVu le grand nombre de langages existants, une classification s’est fait jour. On regroupe en général les langages en « familles » selon le paradigme de programmation auquel ils sont (le mieux) adaptés.\nConformément au programme, nous allons définir les paradigmes impératif, fonctionnel et objet.\nNotons tout d’abord que la plupart des langages de programmation modernes sont multiparadigmes : ils permettent de programmer aussi bien de façon impérative, fonctionnelle qu’avec des objets."
  },
  {
    "objectID": "langagesProgr/paradigmes_cours.html#introduction-et-définition",
    "href": "langagesProgr/paradigmes_cours.html#introduction-et-définition",
    "title": "Paradigmes de programmation (Cours)",
    "section": "",
    "text": "Tout d’abord, nous pouvons nous demander ce que signifie le mot paradigme. Parmi les trois définitions fournies par le dictionnaire Le Robert, celle qui nous intéresse est la suivante :\n\n\n\n\n\n\nDéfinition\n\n\n\n\nParadigme\n\nModèle de pensée.\n\n\n\n\nEn programmation, un paradigme est donc une manière de penser un programme, une méthode de programmation.\nUn programme est un texte, avec ses conventions d’écriture. Il s’agit bien d’un langage écrit, au sens commun, mais il doit toujours avoir un sens univoque et non contextuel.\nIl faut que la formulation textuelle d’un programme soit :\n\nsuffisamment proche d’un code réel, conforme à une famille d’ordinateurs particuliers ;\nstandardisée et générale pour permettre une adaptation immédiate et automatique — on parle de « portabilité » — à d’autres contextes similaires ;\nparfaitement univoque, non ambiguë, puisque destinée à un traitement automatique ;\nintelligible par un être humain.\n\nVu le grand nombre de langages existants, une classification s’est fait jour. On regroupe en général les langages en « familles » selon le paradigme de programmation auquel ils sont (le mieux) adaptés.\nConformément au programme, nous allons définir les paradigmes impératif, fonctionnel et objet.\nNotons tout d’abord que la plupart des langages de programmation modernes sont multiparadigmes : ils permettent de programmer aussi bien de façon impérative, fonctionnelle qu’avec des objets."
  },
  {
    "objectID": "langagesProgr/paradigmes_cours.html#paradigme-impératif",
    "href": "langagesProgr/paradigmes_cours.html#paradigme-impératif",
    "title": "Paradigmes de programmation (Cours)",
    "section": "Paradigme impératif",
    "text": "Paradigme impératif\nLa programmation impérative est la méthode de programmation que vous avez le plus couramment utilisée jusqu’à présent.\nIl s’agit d’un paradigme de programmation qui décrit les opérations en séquences d’instructions exécutées par l’ordinateur pour modifier l’état du programme.\nLa programmation impérative se concentre sur la description du fonctionnement d’un programme.\nLa plupart des langages de haut niveau comporte cinq types d’instructions principales :\n\nla séquence d’instructions\nl’assignation ou affectation\nl’instruction conditionnelle (if, else)\nla boucle (for, while)\nles branchements.\n\nCe type de programmation est le plus ancien et utilisé, il est facile à comprendre, souvent efficace, car proche des instructions réalisées par les processeurs. Par contre, il est assez difficile à tester, car l’état du programme ne cesse de changer et il est difficile de tester une petite partie du programme au milieu de son exécution par exemple, car elle nécessite que toutes les instructions précédentes aient déjà été appliquées correctement.\nLes langages C, C++, Java, JavaScript, Python et beaucoup d’autres permettent la programmation impérative."
  },
  {
    "objectID": "langagesProgr/paradigmes_cours.html#paradigme-fonctionnel",
    "href": "langagesProgr/paradigmes_cours.html#paradigme-fonctionnel",
    "title": "Paradigmes de programmation (Cours)",
    "section": "Paradigme fonctionnel",
    "text": "Paradigme fonctionnel\n\nIntroduction\nLe paradigme fonctionnel est un paradigme de programmation qui reprend les principes du lambda-calcul introduit par Alonzo Church dans les années 1930.\nL’idée fondamentale du lambda-calcul est de considérer que les fonctions sont des données comme les autres. Ainsi, elles peuvent être par exemple passées en paramètre à d’autres fonctions.\nD’autres principes découlent également de la thèse de Church :\n\nles fonctions sont des fonctions au sens mathématique du terme : elles se contentent de renvoyer une valeur en fonction de leurs arguments ;\nil n’y a pas de notion « d’état », ni à l’extérieur des fonctions, ni dans les fonctions. Un programme n’est donc qu’une composition de fonctions.\n\nLe paradigme fonctionnel a d’abord été implanté au sein de langages dédiés, plus ou moins « purement fonctionnel ». Parmi les langages dits fonctionnels, on peut citer :\n\nLISP (List Processing) : 1958 ;\nSML (Standard Meta Language) : 1983 ;\nCAML (Categorical Abstract Machine Language) : 1987, puis son extension objet OCAML ;\nHaskell : 1990 ;\nClojure : 2007.\n\nMais certains aspects du paradigme fonctionnel ont fini par être intégrés dans des langages impératifs, car ils présentent certains avantages :\n\nfonctions pures ;\nfonctions d’ordre supérieur ;\nlambda-expressions ;\névaluation paresseuse.\n\nEn programmation fonctionnelle, les variables sont toujours constantes : une fois qu’elles ont été affectées, leur valeur ne doit plus changer ; de plus les boucles sont remplacées par des appels récursifs.\n\n\nMise en œuvre en Python\n\nFonctions pures\nUne fonction pure est une fonction qui ne modifie rien ; elle ne fait que renvoyer des valeurs en fonction de ses paramètres. Et les valeurs renvoyées ne doivent dépendre que de ses paramètres, et pas de variables extérieures à la fonction.\nLes modifications qu’une fonction peut effectuer sur l’état du système sont appelées effets de bord. Un affichage à l’écran est un exemple d’effet de bord.\nEn Python, rien n’impose d’implémenter des fonctions pures. Notamment, étant donné la façon dont les arguments sont passés à une fonction en Python (utilisation d’une copie de la référence initiale), rien n’interdit qu’une fonction modifie l’objet référencé par l’un de ses paramètres.\nVoici un tel exemple :\ndef retirer_dernier(liste) :\n    liste.pop()\nOn utilise cette fonction ainsi :\n&gt;&gt;&gt; ma_liste = [1, 2, 3]\n&gt;&gt;&gt; retirer_dernier(ma_liste)\nL’inconvénient de ce type de fonction est qu’elle modifie la variable ma_liste qui, à l’issue de l’exécution des deux lignes précédentes contient [1, 2]. Cela peut rendre le code plus difficile à comprendre et générer des comportements inattendus. Une fonction pure, au contraire, doit renvoyer la valeur calculée sans modifier ses paramètres. Ainsi, on peut réécrire le traitement précédent de la façon suivante :\ndef retirer_dernier_pure(liste) :\n    retour = liste[:]\n    retour.pop()\n    return retour\nCette fonction s’utilise ainsi :\n&gt;&gt;&gt; l1 = [1, 2, 3]\n&gt;&gt;&gt; l2 = retirer_dernier_pure(l1)\nDans ce dernier cas, le fait que l’appel à retirer_dernier_pure ne modifie par l1 est bien plus intuitif.\n\n\n\n\n\n\nÀ retenir\n\n\n\nPour faciliter l’écriture de fonctions pures en Python, on peut :\n\nutiliser au maximum des données non mutables (tuples plutôt que listes par exemple) ;\ncopier systématiquement au début des fonctions les paramètres référençant des données mutables et utiliser ces copies dans la fonction.\non veille à ne pas modifier de valeur existante, mais plutôt à créer une nouvelle valeur à partir de la valeur existante.\n\n\n\nEssayer de n’écrire que des fonctions pures permet de limiter les risques de bugs et facilite la relecture des programmes. Il s’agit donc d’un style de programmation à privilégier.\n\n\n\nFonctions d’ordre supérieur\nLes fonctions étant considérées comme des données comme les autres, il est possible de définir des fonctions dont les arguments sont d’autres fonctions. On parle alors de fonctions d’ordre supérieur.\nPython fournit des fonctions d’ordre supérieur dans sa bibliothèque standard. Voyons par exemple la fonction map qui permet d’appliquer une fonction à tous les éléments d’une liste. Quelques remarques et explications s’imposent :\n\nmap peut s’appliquer à tout objet itérable, donc aux chaînes de caractères, aux tuples, aux listes.\nmap retourne un objet itérable : les valeurs résultat ne sont pas toutes calculées par avance, elles le seront à la demande. Cet itérable peut être transformé en liste en tapant list(map(...)) ou être utilisé dans une boucle for item in map(...):. Ce calcul des valeurs à la demande est une mise en œuvre du principe de l’évaluation paresseuse caractéristique de la programmation fonctionnelle.\n\nConsidérons le programme suivant :\ndef carre(x):\n    return x**2\n\n\ndef capit(ch):\n    return ch.capitalize()\n\n\nma_str = \"azerty\"\nmon_tuple = (1, 2, 3, 4, 5)\nma_liste = [1, 2, 3, 4, 5]\n\niter1 = map(capit, ma_str)\niter2 = map(carre, mon_tuple)\niter3 = map(carre, ma_liste)\n\nfor car in iter1:\n    print(car, end=\"\")\nprint()\nprint(tuple(iter2))\nprint(list(iter3))\nOn obtient en sortie :\nAZERTY\n(1, 4, 9, 16, 25)\n[1, 4, 9, 16, 25]\n\n\n\n\n\n\nRemarque\n\n\n\nLe programme ci-dessus est donné pour illustrer l’idée de fonction d’ordre supérieur, mais il n’est pas rédigé, notamment sa partie itérative, dans l’esprit de la programmation fonctionnelle !\n\n\nLes langages OCamL, Haskell, F#, Rust par exemple sont des langages fonctionnels."
  },
  {
    "objectID": "langagesProgr/paradigmes_cours.html#paradigme-objet",
    "href": "langagesProgr/paradigmes_cours.html#paradigme-objet",
    "title": "Paradigmes de programmation (Cours)",
    "section": "Paradigme objet",
    "text": "Paradigme objet\nLa POO consiste en la définition et l’interaction de briques logicielles appelées objets; un objet représente un concept, une idée ou toute entité du monde physique, comme une voiture, une personne ou encore une page d’un livre.\nUn objet possède:\n\ndes données: ses attributs et\ndes fonctions: ses méthodes\n\nLes différents principes de la conception orientée objet aident à la réutilisation du code, au masquage des données, etc. Les bases de la POO sont détaillées dans le cours précédent, avec ses compléments."
  },
  {
    "objectID": "langagesProgr/paradigmes_cours.html#à-quel-paradigme-se-vouer",
    "href": "langagesProgr/paradigmes_cours.html#à-quel-paradigme-se-vouer",
    "title": "Paradigmes de programmation (Cours)",
    "section": "À quel paradigme se vouer ?",
    "text": "À quel paradigme se vouer ?\nComment choisir entre les différents paradigmes existants ?\nIl est important de bien comprendre qu’un programmeur doit maitriser plusieurs paradigmes de programmation (impératif, objet ou encore fonctionnelle). En effet, il sera plus facile d’utiliser le paradigme objet dans certains cas alors que dans d’autres situations, l’utilisation du paradigme fonctionnel sera préférable. Être capable de choisir le “bon” paradigme en fonction des situations fait partie du bagage de tout bon programmeur.\nIl est aussi important de bien comprendre que la frontière entre ces différents paradigmes est parfois floue, par exemple on utilise très souvent de l’impératif en programmation orientée objet.\nDans l’article Perceiving Python programming paradigms du site opensource.com/, les conseils suivants sont donnés :\n\nPour simplifier, si votre problème implique une série de manipulations séquentielles simples, suivre le paradigme de programmation impérative de la vieille école serait le moins cher en termes de temps et d’efforts et vous donnerait potentiellement les meilleures performances.\nDans le cas de problèmes nécessitant des transformations mathématiques des valeurs, le filtrage des informations, le mappage (transformer une liste en une autre) et les réductions (transformer une liste en une valeur), la programmation fonctionnelle pourrait être adaptée.\nSi le problème est structuré comme un tas d’objets interdépendants avec certains attributs qui peuvent changer avec le temps, en fonction de certaines conditions, la programmation orientée objet sera certainement la plus naturelle.\n\nBien sûr, il n’y a pas de règle simple, car le choix du paradigme de programmation dépend également fortement du type de données à traiter, des connaissances des programmeurs et de diverses autres choses comme l’évolutivité.\nNotons pour finir que cette courte présentation ne recouvre pas tous les paradigmes de programmation existants. On rencontrera notamment l’idée de programmation événementielle lors du développement d’interfaces graphiques."
  },
  {
    "objectID": "langagesProgr/paradigmes_exercices.html",
    "href": "langagesProgr/paradigmes_exercices.html",
    "title": "Paradigmes de programmation (Exercices)",
    "section": "",
    "text": "Les exercices précédés du symbole  sont à faire sur machine, en sauvegardant le fichier si nécessaire.\nLes exercices précédés du symbole  doivent être résolus par écrit."
  },
  {
    "objectID": "langagesProgr/paradigmes_exercices.html#fa-solid-pencil-alt-exercice-1",
    "href": "langagesProgr/paradigmes_exercices.html#fa-solid-pencil-alt-exercice-1",
    "title": "Paradigmes de programmation (Exercices)",
    "section": " Exercice 1",
    "text": "Exercice 1\nVoici différents algorithmiques permettant l’affichage des 10 chiffres entiers dans l’ordre décroissant.\nPréciser pour chacun des algorithme le type de paradigme auquel il correspond.\nAlgorithme 1 :\ndef decompter(n:int)-&gt;None:\n    if n&gt;=0: \n        print(n)\n        decompter(n-1)\ndecompter(9)\nAlgorithme 2 :\nfor i in range(10):\n    print(9-i)\nAlgorithme 3 :\nclass Nombres():\n\n    def __init__(self,valeur):\n        self.valeur = valeur\n\n    def diminuer(self):\n        self.valeur -= 1\n\n    def __str__(self):\n        return str(self.valeur)\n\nn = Nombres(9)\nwhile n.valeur &gt;= 0 :\n    print(n)\n    n.diminuer()"
  },
  {
    "objectID": "langagesProgr/paradigmes_exercices.html#fa-solid-pencil-alt-exercice-2",
    "href": "langagesProgr/paradigmes_exercices.html#fa-solid-pencil-alt-exercice-2",
    "title": "Paradigmes de programmation (Exercices)",
    "section": " Exercice 2",
    "text": "Exercice 2\nVoici deux versions d’une fonction teste_ordre_liste dont l’objectif est de savoir si une liste est ordonnée par ordre croissant. Indiquer quel paradigme est utilisé dans chacune des deux versions et expliquer votre réponse.\nVersion 1\n# -*- coding: utf-8 -*-\n\ndef test_ordre(a,b) :\n    if a &lt; b :\n        return True\n    else :\n        return False\n\ndef test_ordre_liste(liste) :\n    if len(liste) &lt; 2 :\n        return True\n    return test_ordre(liste[0],liste[1]) and test_ordre_liste(liste[1:])\n\ntest_ordre_liste([2,3,2])\nVersion 2\n# -*- coding: utf-8 -*-\n\ndef test_ordre(a,b) :\n    if a &lt; b :\n        return True\n    else :\n        return False\n\ndef test_ordre_liste(liste) :\n    if len(liste) &lt; 2 :\n        return True\n    else :\n        if test_ordre(liste[0],liste[1]) == False :\n            return False\n        else :\n            del liste[0]\n            return test_ordre_liste(liste)\n\ntest_ordre_liste([2,3,2])"
  },
  {
    "objectID": "langagesProgr/paradigmes_exercices.html#fa-solid-pencil-alt-exercice-3",
    "href": "langagesProgr/paradigmes_exercices.html#fa-solid-pencil-alt-exercice-3",
    "title": "Paradigmes de programmation (Exercices)",
    "section": " Exercice 3",
    "text": "Exercice 3\nLe programme ci-dessous ne respecte pas le paradigme fonctionnel. Pourquoi ?\ni = 5\n\ndef fct():\n  if i &gt; 5:\n    return True\n  else :\n    return False\n\nfct()\nModifier le programme pour qu’il respecte le paradigme fonctionnel."
  },
  {
    "objectID": "langagesProgr/paradigmes_exercices.html#fa-solid-pencil-alt-exercice-4",
    "href": "langagesProgr/paradigmes_exercices.html#fa-solid-pencil-alt-exercice-4",
    "title": "Paradigmes de programmation (Exercices)",
    "section": " Exercice 4",
    "text": "Exercice 4\nMême exercice avec le programme ci-dessous :\nl = [4,7,3]\n\ndef ajout(i):\n  l.append(i)\n\n\n\n\n\n\nComplément pour les curieux\n\n\n\nPour ceux qui voudraient découvrir un langage fonctionnel, cette page fournit une introduction pas à pas aux bases de OCamL. Ce langage est utilisé en CPGE scientifiques dans le cadre de l’option informatique. Une autre introduction, pour la prépa, est disponible ici. On peut programmer en OCamL en ligne ici."
  },
  {
    "objectID": "langagesProgr/POO_complements.html",
    "href": "langagesProgr/POO_complements.html",
    "title": "Programmation orientée objets (Compléments)",
    "section": "",
    "text": "Avertissement\n\n\n\nLes compléments présentés ici sont hors programme. Ils peuvent néanmoins apporter une connaissance et une compréhension plus fine de la POO et être utiles dans le cadre du travail sur les projets."
  },
  {
    "objectID": "langagesProgr/POO_complements.html#principes-et-définitions",
    "href": "langagesProgr/POO_complements.html#principes-et-définitions",
    "title": "Programmation orientée objets (Compléments)",
    "section": "Principes et définitions",
    "text": "Principes et définitions\n\nObjet\n\nUn objet est une donnée manipulable par un programme : il s’agit d’un conteneur pour une valeur ou un état auquel est associé un ensemble d’opérations. Cet objet est associé à un type, défini comme l’ensemble des valeurs possibles, cette liste d’opérations, ainsi que leur codage (binaire).\n\n\nUn objet est identifié dans un programme par un nom ou une notation littérale, mais peut parfois être anonyme (comme les variables temporaires ou les composantes d’un tableau).\nEt pour une définition d’un langage orienté objet, l’idée première que l’on retrouve dans la définition de wikipédia offre un cadre intéressant : un langage objet doit permettre l’analyse et le développement logiciel fondés sur des relations entre objets.\nConcrètement, un objet est une structure de données qui répond à un ensemble de messages. Cette structure de données définit son état tandis que l’ensemble des messages qu’il comprend décrit son comportement :\n\nles données, ou champs, qui décrivent sa structure interne sont appelées ses attributs ;\nl’ensemble des messages forme ce que l’on appelle l’interface de l’objet ; c’est seulement au travers de celle-ci que les objets interagissent entre eux. La réponse à la réception d’un message par un objet est appelée une méthode (méthode de mise en œuvre du message) ; elle décrit quelle réponse doit être donnée au message.\n\nLes attributs et les méthodes constituent les membres d’un objet. Un objet possède un type.\nEn Python, un objet la création d’un objet se fait en utilisant une classe : un objet est alors une instance de sa classe. La classe est un type, un ensemble d’objets partageant les mêmes propriétés concrétisées par une liste de membres.\n\nLangage orienté objet\n\nUn langage orienté objet est un langage de programmation qui comporte de manière native les éléments suivants : l’encapsulation, l’héritage, le polymorphisme et la programmation générique."
  },
  {
    "objectID": "langagesProgr/POO_complements.html#les-principes-clés-de-la-poo",
    "href": "langagesProgr/POO_complements.html#les-principes-clés-de-la-poo",
    "title": "Programmation orientée objets (Compléments)",
    "section": "Les principes clés de la POO",
    "text": "Les principes clés de la POO\n\nL’encapsulation\nCertains membres (ou plus exactement leur représentation informatique) sont cachés : c’est le principe d’encapsulation. Ainsi, le programme peut modifier la structure interne des objets ou leurs méthodes associées sans avoir d’impact sur les utilisateurs de l’objet. C’est un des principes fondamentaux notamment pour la robustesse du code.\nEn particulier, les bonnes pratiques de POO recommandent de na pas permettre un accès direct aux attributs d’un objet à l’extérieur de celui-ci. On appelle interface d’un objet l’ensemble de ses membres qui sont accessibles à l’extérieur de celui-ci. L’interface ne devrait donc contenir que des méthodes. Pas forcément toutes, certaines méthodes (comme __init__) restent privées.\nContrairement à d’autres langages, Python offre une totale liberté de modification sur les membres d’un objet. C’est au programmeur de rester vigilant. Il existe néanmoins des conventions permettant d’identifier les membres de l’interface des autres membres d’un objet.\n\n\n\n\n\n\nConventions de nommage en Python\n\n\n\n\nun nom d’attribut commençant par un double underscore __ désigne un attribut privé.\nune méthode dont le nom est de la forme __nom__ désigne une méthode privée.\n\n\n\nMais alors si les attributs doivent rester privés, comment y accéder, et comment les modifier ?\nIl convient pour cela, en toute rigueur, de définir des méthodes ad-hoc : une méthode qui permet d’accéder à un attribut est un getter, une période qui permet de changer la valeur d’un attribut est un setter.\nVoici par exemple une nouvelle définition de la classe “Rectangle” tenant compte des remarques précédentes.\nclass Rectangle:\n    \"\"\"Représente un rectangle\"\"\"\n\n    def __init__(self, largeur=2, hauteur=3):\n        self.__largeur = largeur\n        self.__hauteur = hauteur\n\n    def get_largeur(self):\n        return self.__largeur\n\n    def set_largeur(self, largeur):\n        self.__largeur = largeur\n\n    def get_hauteur(self):\n        return self.__hauteur\n\n    def set_hauteur(self, hauteur):\n        self.__hauteur = hauteur\n\n    def perimetre(self):\n        \"\"\"Retourne le périmètre\"\"\"\n        return 2 * (self.__largeur + self.__hauteur)\n\n    def aire(self):\n        \"\"\"Retourne l'aire\"\"\"\n        return self.__largeur * self.__hauteur\nUtilisation :\n&gt;&gt;&gt; rec = Rectangle(10, 5)\n&gt;&gt;&gt; rec.__hauteur\nAttributeError: 'Rectangle' object has no attribute '__hauteur'\n&gt;&gt;&gt; rec.get_hauteur()\n5\nNous voyons que l’accès direct à l’attribut n’est plus possible.\nCela n’est pas très pratique et change nos habitudes : nous aimerions en effet pouvoir accéder à la valeur d’un attribut en utilisant la notation pointée. Deux remarques à ces objections. D’une part, ces règles de programmation ne sont pas là pour nous embêter ! Il s’agit de sécuriser notre code : la définition d’un setter par exemple, peut permettre de vérifier la validité des arguments entrés et afficher un message d’erreur si besoin (par exemple si on appelle set_hauteur(-10). Deuxième remarque : Python propose une fonctionnalité avancée, appelée décorateurs et qui permet de retrouver, en apparence, l’accès direct aux attributs. Voici une nouvelle version de la classe “Rectangle” avec l’utilisation du décorateur @property et la redéfinition des getter et setter (qui doivent maintenant porter le même nom que le pseudo argument). On a introduit dans les setter des tests de validité des données.\nclass Rectangle:\n    \"\"\"Représente un rectangle\"\"\"\n\n    def __init__(self, largeur=2, hauteur=3):\n        self.__largeur = largeur\n        self.__hauteur = hauteur\n\n    @property\n    def largeur(self):\n        return self.__largeur\n\n    @largeur.setter\n    def largeur(self, largeur):\n        if isinstance(largeur, (int, float)) and largeur &gt;= 0:\n            self.__largeur = largeur\n        else:\n            print(\"Argument invalide, largeur inchangée !\")\n\n    @property\n    def hauteur(self):\n        return self.__hauteur\n\n    @hauteur.setter\n    def hauteur(self, hauteur):\n        if isinstance(hauteur, (int, float)) and hauteur &gt;= 0:\n            self.__hauteur = hauteur\n        else:\n            print(\"Argument invalide, hauteur inchangée !\")\n\n    def perimetre(self):\n        \"\"\"Retourne le périmètre\"\"\"\n        return 2 * (self.__largeur + self.__hauteur)\n\n    def aire(self):\n        \"\"\"Retourne l'aire\"\"\"\n        return self.__largeur * self.__hauteur\n\n\nrec = Rectangle(10, 25)\nprint(rec.largeur)\nrec.largeur = -15\nprint(rec.largeur)\nSortie en console :\n10\nArgument invalide, largeur inchangée !\n10\n\n\nL’héritage\nL’héritage est une relation asymétrique entre deux classes : l’une est la classe mère (aussi nommée classe parente, superclasse, classe de base), l’autre la classe-fille. L’héritage permet une économie d’écriture par la réutilisation automatique, lors de la définition de la classe-fille, de tous les membres et autres éléments définis dans la classe mère. Ainsi, les objets de la classe-fille héritent de toutes les propriétés de leur classe mère.\nPar exemple, nous pouvons définir une classe carre, fille de la classe Rectangle. Les attributs et les méthodes définis pour la classe Rectangle existent alors automatiquement aussi pour la classe carre.\nVoici la syntaxe Python pour définir une classe fille :\nclass Carre(Rectangle):\n\n    def __init__(self, cote=2):\n        Rectangle.__init__(self, cote, cote)\nUtilisation :\n&gt;&gt;&gt; car = Carre(5)\n&gt;&gt;&gt; car.perimetre()\n20\nLa méthode perimetre est héritée de la classe mère Rectangle.\n\n\n\n\n\n\nHéritage et initialiseur\n\n\n\nLa méthode initialiseur de la classe Carre fait appel à la méthode initialiseur de sa classe parente par la commande Rectangle.__init__(self, cote, cote). Cet appel est nécessaire afin que les membres de la classe Carre soient définis de la même manière que les membres de la classe Rectangle. La méthode __init__ est un initialiseur d’instance : elle n’est pas invoquée automatiquement lorsqu’on instancie des objets d’une classe fille.\n\n\n\n\nLe polymorphisme et la redéfinition\nLa redéfinition des méthodes permet à un objet de raffiner une méthode définie avec la même en-tête dans la classe mère. Une même méthode pourra ainsi avoir un comportement différent selon qu’elle s’applique à la classe mère ou à la classe fille : on parle de polymorphisme d’héritage.\nPar exemple, nous pouvons redéfinir la méthode aire de la classe Carre comme ci-dessous : appliquée à un objet Carre, la nouvelle définition sera utilisée à la place de la méthode héritée.\nclass Carre(Rectangle):\n\n    def __init__(self, cote=2):\n        self.__largeur = cote\n        self.__hauteur = cote\n    \n    def aire(self):\n        \"\"\"Retourne l'aire\"\"\"\n        return self.__largeur ** 2"
  },
  {
    "objectID": "langagesProgr/POO_complements.html#les-méthodes-spéciales",
    "href": "langagesProgr/POO_complements.html#les-méthodes-spéciales",
    "title": "Programmation orientée objets (Compléments)",
    "section": "Les méthodes spéciales",
    "text": "Les méthodes spéciales\nUn bon exemple de polymorphisme est fourni par la redéfinition des méthodes spéciales.\nNous savons que la fonction dir() renvoie tous les membres d’un objet.\nAppliquons cette commande à notre objet rec, instance de la classe Rectangle :\n&gt;&gt;&gt; dir(rec)\n['__class__',\n '__delattr__',\n '__dict__',\n '__dir__',\n '__doc__',\n '__eq__',\n '__format__',\n '__ge__',\n '__getattribute__',\n '__gt__',\n '__hash__',\n '__init__',\n '__init_subclass__',\n '__le__',\n '__lt__',\n '__module__',\n '__ne__',\n '__new__',\n '__reduce__',\n '__reduce_ex__',\n '__repr__',\n '__setattr__',\n '__sizeof__',\n '__str__',\n '__subclasshook__',\n '__weakref__',\n '_hauteur',\n '_largeur',\n 'aire',\n 'hauteur',\n 'largeur',\n 'perimetre']\nNous reconnaissons en fin de liste les attributs et méthodes que nous avons définis, mais nous découvrons l’existence d’un grand nombre de méthodes spéciales privées (puisque leur nom est entouré de __) qui sont en fait héritées d’une classe Object parente de toutes les classes. Parmi celles-ci, nous avons déjà rencontré __init__, la méthode initialiseur.\nLes curieux pourront rechercher le rôle de chacune de ces méthodes spéciales. Le voici pour certaines d’entre elles :\n\n\n\nMéthode spéciale\nUsage\n\n\n\n\nadd\n+\n\n\nmul\n*\n\n\nsub\n-\n\n\neq\n==\n\n\nne\n!=\n\n\nlt\n&lt;\n\n\nge\n&lt;=\n\n\ngt\n&gt;\n\n\nge\n&gt;=\n\n\nrepr\naffichage dans la console &gt;&gt;&gt; obj\n\n\nstr\nstr(obj), print(obj)\n\n\n\nLa redéfinition de la méthode __add__ permettrait par exemple de donner un sens à l’utilisation du symbole + entre deux objets (instruction du type rec1 + rec 2).\nDans notre exemple, nous allons redéfinir la méthode __str__ pour spécifier ce qui doit s’afficher quand l’instruction print(rec) est exécutée.\nPour l’instant, on obtient :\n&gt;&gt;&gt; print(rec)\n&lt;__main__.Rectangle object at 0x000002386735C730&gt;\nAjoutons la méthode ci-dessous dans la classe Rectangle :\ndef __str__(self):\n    return f\"Rectangle de largeur {self.__largeur} et de hauteur {self.__hauteur}.\"\nOn obtient maintenant :\n&gt;&gt;&gt; print(rec)\nRectangle de largeur 10 et de hauteur 25."
  },
  {
    "objectID": "langagesProgr/POO_cours.html",
    "href": "langagesProgr/POO_cours.html",
    "title": "Programmation orientée objets (Cours)",
    "section": "",
    "text": "Objectifs\n\n\n\n\nConnaître le vocabulaire de la POO : classes, attributs, méthodes objets.\nÉcrire la définition d’une classe.\nAccéder aux méthodes et attributs d’une classe.\nDes compléments sur la POO sont proposés à la suite de ce cours."
  },
  {
    "objectID": "langagesProgr/POO_cours.html#introduction",
    "href": "langagesProgr/POO_cours.html#introduction",
    "title": "Programmation orientée objets (Cours)",
    "section": "Introduction",
    "text": "Introduction\nLa Programmation Orientée Objets (POO) pour les intimes (que vous allez devenir !) est un paradigme (c’est-à-dire une manière de faire) de programmation\nPour un bref aperçu historique de l’idée d’objet en programmation, lire l’encadré ci-dessous, en grande partie tiré de l’article Object-oriented programming de Wikipedia en anglais.\n\n\n\n\n\n\nUn peu d’histoire\n\n\n\nLes termes objets orienté au sens moderne de la programmation orientée objet ont fait leur première apparition au MIT à la fin des années 1950 et au début des années 1960. Dans l’environnement du groupe d’intelligence artificielle, dès 1960, “objet” pouvait désigner des éléments identifiés avec des propriétés (attributs).\nC’est l’informaticien Alan Kay (1940-) qui est considéré comme l’un de pères de la programmation orientée objets.\n\nJe pensais que les objets étaient comme des cellules biologiques et / ou des ordinateurs individuels sur un réseau, uniquement capables de communiquer avec des messages.\nAlan Kay\n\nLe langage Simula dans les années 1960, puis Smalltalk dans les années 1970 posent les bases toujours actuelles de ce paradigme.\nAu début et au milieu des années 1990, la programmation orientée objet s’est développée comme le paradigme de programmation dominant lorsque les langages de programmation prenant en charge ces techniques sont devenus largement disponibles. Ceux-ci incluent par exemple C++ ou Delphi. Sa domination a été renforcée par la popularité croissante des interfaces utilisateur graphiques, qui reposent fortement sur des techniques de programmation orientées objet.\nDes fonctionnalités orientées objet ont été ajoutées à de nombreux langages existants, notamment Ada, BASIC, Fortran, Pascal et COBOL.\nPlus récemment, un certain nombre de langages ont émergé qui sont principalement orientés objet, mais qui sont également compatibles avec la méthodologie procédurale. Deux de ces langages sont Python et Ruby. Les langages orientés objet récents les plus importants sur le plan commercial sont probablement Java, développé par Sun Microsystems, ainsi que C# et Visual Basic.NET (VB.NET), tous deux conçus pour la plate-forme.NET de Microsoft.\n*[MIT] : Massachusetts Institute of Technology\n\n\nAlors de quoi s’agit-il ? Une approche intuitive consiste à dire que cette méthode de programmation nous permet de définir des nouveaux types de données, de nouveaux objets, correspondant à un objectif précis. Ces nouveaux types sont appelés classes. En définissant une classe, nous pouvons également définir ses attributs, c’est-à-dire les variables qui lui sont associées et ses méthodes, c’est-à-dire les fonctions sui lui sont propres.\nVoici ce que Gérard SWINNEN écrit dans son livre Apprendre à programmer avec Python 3 :\n\nLes classes sont les principaux outils de la programmation orientée objet (Object Oriented Programming ou OOP). Ce type de programmation permet de structurer les logiciels complexes en les organisant comme des ensembles d’objets qui interagissent, entre eux et avec le monde extérieur.\nLe premier bénéfice de cette approche de la programmation réside dans le fait que les différents objets utilisés peuvent être construits indépendamment les uns des autres (par exemple par des programmeurs différents) sans qu’il n’y ait de risque d’interférence. Ce résultat est obtenu grâce au concept d’encapsulation : la fonctionnalité interne de l’objet et les variables qu’il utilise pour effectuer son travail, sont en quelque sorte « enfermées » dans l’objet. Les autres objets et le monde extérieur ne peuvent y avoir accès qu’à travers des procédures bien définies : l’interface de l’objet.\nEn particulier, l’utilisation de classes dans vos programmes va vous permettre – entre autres avantages – d’éviter au maximum l’emploi de variables globales. Vous devez savoir en effet que l’utilisation de variables globales comporte des risques, d’autant plus importants que les programmes sont volumineux, parce qu’il est toujours possible que de telles variables soient modifiées, ou même redéfinies, n’importe où dans le corps du programme (ce risque s’aggrave particulièrement si plusieurs programmeurs différents travaillent sur un même logiciel).\n\nEn utilisant Python, nous avons déjà fréquenté des classes d’objets : il est usuel de lire qu’en Python “tout est objet”, même si Python ne permet pas vraiment de faire de la POO dans toute sa rigueur.\nPar exemple, définissons une chaîne de caractères et demandons à Python quel est son type :\n&gt;&gt;&gt; a = \"Coucou !\"\n&gt;&gt;&gt; type(a)\n&lt;class 'str'&gt;\nLe type ‘str’ bien connu est en fait une classe d’objet prédéfinie. On dit que a est une instance de l’objet str.\nUn exemple de méthode rattachée à la classe str est la fonction capitalize qui met le premier caractère en majuscule. Cette méthode est appelée par la notation pointée déjà rencontrée.\n&gt;&gt;&gt; a.capitalize()\n'Coucou !'\nLa commande help(str) affiche toutes les méthodes prédéfinies pour les objets de la classe str."
  },
  {
    "objectID": "langagesProgr/POO_cours.html#classe-initialiseur-attributs",
    "href": "langagesProgr/POO_cours.html#classe-initialiseur-attributs",
    "title": "Programmation orientée objets (Cours)",
    "section": "Classe, initialiseur, attributs",
    "text": "Classe, initialiseur, attributs\nEn Python, la définition d’une classe se fait avec le mot-clef class suivi du nom de la classe.\nSupposons par exemple que nous voulons définir une classe pour représenter des rectangles. Nous avons besoin, pour chaque rectangle, de connaître sa largeur et se hauteur, ce qui nous permettra de faire quelques calculs.\nObservons le code suivant :\nclass Rectangle:\n    \"\"\"Représente un rectangle\"\"\"\n    \n    def __init__(self, largeur = 2, hauteur = 3):\n        self.largeur = largeur\n        self.hauteur = hauteur\nÀ l’intérieur de la classe Rectangle, la méthode __init__ est l’initialiseur : elle est toujours exécutée lorsqu’une instance de l’objet Rectangle est créée (on parle aussi de constructeur). Cette fonction accepte des paramètres qui seront les valeurs à donner aux attributs à la création de l’objet (ici on a aussi donné des valeurs par défaut à ces paramètres) ; le premier paramètre est particulier : ce sera toujours le mot-clé self : ce mot-clef désigne l’instance qui est en train d’être définie au moment où cette fonction s’exécute.\n\n\n\n\n\n\nRemarque\n\n\n\nIl est d’usage, et recommandé, de nommer une classe par un nom commençant par une majuscule.\n\n\nObservons les lignes suivantes dans la console Python :\n&gt;&gt;&gt; rec1 = Rectangle()\n&gt;&gt;&gt; rec2=Rectangle(15, 25)\n&gt;&gt;&gt; rec1.largeur\n2\n&gt;&gt;&gt; rec2.largeur\n15\nrec1 est une instance de l’objet Rectangle. Aucun paramètre n’étant donné lors de sa création, les valeurs par défaut ont été appliquées. rec2 est une autre instance de l’objet Rectangle pour laquelle on a défini les attributs d’instance largeur et hauteur. On accède à ces attributs par la notation pointée."
  },
  {
    "objectID": "langagesProgr/POO_cours.html#méthodes",
    "href": "langagesProgr/POO_cours.html#méthodes",
    "title": "Programmation orientée objets (Cours)",
    "section": "Méthodes",
    "text": "Méthodes\nUne méthode, c’est ce qui permet à une instance de réaliser des actions. Techniquement se sont des fonctions définies dans le corps de la classe, et qui prennent toujours au moins un premier paramètre qui est self.\nCertaines méthodes sont particulières, leurs noms commencent par un double undescore (le caractère _). On a vu une première de ces méthodes : l’initialiseur __init__.\nDéfinissons ici une méthode permettant de calculer le périmètre d’un rectangle et une autre pour l’aire :\nclass Rectangle:\n    \"\"\"Représente un rectangle\"\"\"\n\n    def __init__(self, largeur=2, hauteur=3):\n        self.largeur = largeur\n        self.hauteur = hauteur\n\n    def perimetre(self):\n        \"\"\"Retourne le périmètre\"\"\"\n        return 2 * (self.largeur + self.hauteur)\n\n    def aire(self):\n        \"\"\"Retourne l'aire\"\"\"\n        return self.largeur * self.hauteur\nUtilisation :\n&gt;&gt;&gt; rec = Rectangle(10, 5)\n&gt;&gt;&gt; rec.perimetre()\n30\n&gt;&gt;&gt; rec.aire()\n50\nUne méthode peut modifier la valeur d’un attribut. Définissons par exemple une méthode permettant de doubler la largeur d’un rectangle.\ndef double_largeur(self):\n    \"\"\"Double la largeur du rectangle)\"\"\"\n    self.largeur *= 2\n&gt;&gt;&gt; rec = Rectangle(10, 5)\n&gt;&gt;&gt; rec.double_largeur()\n&gt;&gt;&gt; rec.largeur\n20\nLa POO encourage à n’exposer que des méthodes vers l’extérieur (on parle d’interface) en masquant les attributs. Il s’agit d’un des quatre éléments constitutifs de l’orienté objet : l’encapsulation.\n\n\n\n\n\n\nRemarque\n\n\n\nNous avons présenté ci-dessus les attributs d’instance, mais il est aussi possible de définir des attributs de classe qui seront donc les mêmes pour toutes les instances d’une même classe créées dans un programme. Ces attributs sont définis à l’intérieur de la classe, sans le préfixe self (puisque celui-ci fait référence à l’instance en train d’être créée).\nPar exemple, dans la définition de la classe Atome ci-dessous, la liste table est un attribut de classe, alors que l’entier np est un attribut d’instance. Dans la méthode __init__, on accède à l’attribut de classe en le préfixant par le nom de la classe Atome.table et on accède à l’attribut d’instance en le préfixant par le nom de l’instance self.np.\nclass Atome:\n\"\"\"atomes simplifiés, choisis parmi les 10 premiers éléments du TP\"\"\"\ntable = [None, ('hydrogène', 0), ('hélium', 2), ('lithium', 4), ('béryllium', 5),\n            ('bore', 6), ('carbone', 6), ('azote', 7), ('oxygène', 8), ('fluor', 10), ('néon', 10)]\n\ndef __init__(self, nat):\n    \"le n° atomique détermine le n. de protons, d'électrons et de neutrons\"\n    self.np, self.ne = nat, nat  # nat = numéro atomique\n    self.nn = Atome.table[nat][1]\n\ndef affiche(self):\n    print()\n    print(\"Nom de l'élément :\", Atome.table[self.np][0])\n    print(f\"{self.np} protons, {self.ne} électrons, {self.nn} neutrons\")\nDe la même façon, il est possible de définir des méthodes de classe."
  },
  {
    "objectID": "langagesProgr/POO_cours.html#représentation-simplifiée-dune-classe",
    "href": "langagesProgr/POO_cours.html#représentation-simplifiée-dune-classe",
    "title": "Programmation orientée objets (Cours)",
    "section": "Représentation simplifiée d’une classe",
    "text": "Représentation simplifiée d’une classe\nLorsqu’un module comportant plusieurs définitions de classe est développé, on peut réaliser une représentation graphique, appelée diagramme de classes qui permet de visualiser le nom de chaque classe, son interface (c’est-à-dire l’ensemble de ses attributs et méthodes publiques) et les relations éventuelles entre les différentes classes.\nUne présentation détaillée de ce type de diagramme n’est pas au programme, mais de manière simplifiée, le diagramme correspondant à la classe Rectangle pourrait ressembler à ce qui suit :\n\n\n\nDiagramme de classe\n\n\nDans des cases séparées, on place d’abord le nom de la classe, puis ses attributs et enfin ses méthodes. Un codage spécifique permet de préciser le type des différents membres, leur caractère public ou privé (voir les compléments à ce sujet) ou même leur état.\nUn attribut de classe ou une méthode de classe seront soulignés dans un tel diagramme.\nPour en savoir un peu plus sur les diagrammes de classes, je vous conseille ce document ou encore ce cours plus difficile.\n\nDes compléments sur la POO sont proposés à la suite de ce cours."
  },
  {
    "objectID": "langagesProgr/POO_exercices.html",
    "href": "langagesProgr/POO_exercices.html",
    "title": "Programmation orientée objets (Exercices)",
    "section": "",
    "text": "Les exercices précédés du symbole  sont à faire sur machine, en sauvegardant le fichier si nécessaire.\nLes exercices précédés du symbole  doivent être résolus par écrit."
  },
  {
    "objectID": "langagesProgr/POO_exercices.html#fa-desktop-exercice-1",
    "href": "langagesProgr/POO_exercices.html#fa-desktop-exercice-1",
    "title": "Programmation orientée objets (Exercices)",
    "section": " Exercice 1",
    "text": "Exercice 1\nOn considère la classe suivante :\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def deplace(self, dx, dy):\n        self.x = self.x + dx\n        self.y = self.y + dy\n\n    def symetrique(self):\n        return Point(-self.x, -self.y)\n\n    def __repr__(self):\n        return f\"Point({self.x}, {self.y})\"\n\nQuelle instruction entrer dans la console pour créer le point a d’abscisse 2 et d’ordonnée 4 ?\nQuels sont les attributs et les méthodes de cette classe ? Dresser le diagramme de classe de cette classe.\nLa méthode spéciale __repr__ permet de définir comment l’objet sera affiché dans la console Python.\nQu’affichent les instructions suivantes dont la sortie a été effacée ?\n&gt;&gt;&gt; b = Point(1, 2)\n&gt;&gt;&gt; b\n...\n&gt;&gt;&gt; b.deplace(3, 5)\n&gt;&gt;&gt; b\n...\nDéfinir une méthode abscisse qui renvoie l’abscisse du point.\nRecommencer avec la méthode ordonnee."
  },
  {
    "objectID": "langagesProgr/POO_exercices.html#fa-desktop-exercice-2",
    "href": "langagesProgr/POO_exercices.html#fa-desktop-exercice-2",
    "title": "Programmation orientée objets (Exercices)",
    "section": " Exercice 2",
    "text": "Exercice 2\nSoit la classe Date définie par le diagramme de classe (?@fig-classe).\n\n\n\nDiagramme de classe de la classe Date\n\n\n\nImplémenter cette classe en Python.\nCréer deux dates le 20 janvier 2012 et le 14 février 2022.\nDans la méthode d’initialisation d’instance de la classe, prévoir un dispositif pour éviter les dates impossibles (du genre 32/14/2020). Dans ce cas, la création doit provoquer une erreur, chose possible grâce à l’instruction raise (documentation à rechercher !).\nAjouter une méthode __repr__ et une méthode __str__permettant d’afficher la date sous la forme “25 janvier 1989”. Les noms des mois seront définis en tant qu’attribut de classe à l’aide d’une liste.\nAjouter une méthode __lt__ qui permet de comparer deux dates. L’expression d1 &lt; d2 (d1 et d2 étant deux objets de type Date) doit grâce à cette méthode renvoyer True ou False ."
  },
  {
    "objectID": "langagesProgr/POO_exercices.html#fa-solid-pencil-alt-exercice-3-bac-2022-extrait",
    "href": "langagesProgr/POO_exercices.html#fa-solid-pencil-alt-exercice-3-bac-2022-extrait",
    "title": "Programmation orientée objets (Exercices)",
    "section": " Exercice 3 (Bac 2022, extrait)",
    "text": "Exercice 3 (Bac 2022, extrait)\nSimon souhaite créer en Python le jeu de cartes « la bataille » pour deux joueurs. Les questions qui suivent demandent de reprogrammer quelques fonctions du jeu. On rappelle ici les règles du jeu de la bataille :\nPréparation :\n\nDistribuer toutes les cartes aux deux joueurs.\nLes joueurs ne prennent pas connaissance de leurs cartes et les laissent en tas face cachée devant eux.\n\nDéroulement :\n\nÀ chaque tour, chaque joueur dévoile la carte du haut de son tas.\nLe joueur qui présente la carte ayant la plus haute valeur emporte les deux cartes qu’il place sous son tas.\nLes valeurs des cartes sont : dans l’ordre de la plus forte à la plus faible : As, Roi, Dame, Valet, 10, 9, 8, 7, 6, 5, 4, 3 et 2 (la plus faible).\n\nSi deux cartes sont de même valeur, il y a “bataille”.\n\nChaque joueur pose alors une carte face cachée, suivie d’une carte face visible sur la carte dévoilée précédemment.\nOn recommence l’opération s’il y a de nouveau une bataille sinon, le joueur ayant la valeur la plus forte emporte tout le tas.\n\nLorsque l’un des joueurs possède toutes les cartes du jeu, la partie s’arrête et ce dernier gagne.\nPour cela Simon crée une classe Python Carte. Chaque instance de la classe a deux attributs : un pour sa valeur et un pour sa couleur. Il donne au valet la valeur 11, à la dame la valeur 12, au roi la valeur 13 et à l’as la valeur 14. La couleur est une chaîne de caractères: “trefle”, “carreau”, “coeur” ou “pique”.\nSimon a écrit la classe Python Carte suivante, ayant deux attributs valeur et couleur, et dont le constructeur prend deux arguments: val et coul.\n\nRecopier et compléter les pointillés des lignes ci-dessous.\nclass Carte:\n    def __init__(self, val, coul):\n        ... .valeur = ...\n        ... . ... = coul\nParmi les propositions ci-dessous quelle instruction permet de créer l’objet « 7 de cœur » sous le nom c7 ?\n\nc7. init (self, 7, \"coeur\")\nc7 = Carte(self, 7, \"coeur\")\nc7 = Carte ( 7, \"coeur\")\nfrom Carte import 7, \"coeur\"\n\nOn souhaite créer le jeu de cartes. Pour cela, on écrit une fonction initialiser() :\n\nsans paramètre\nqui renvoie une liste de 52 objets de la classe Carte représentant les 52 cartes du jeu.\n\nVoici une proposition de code. Recopier et compléter les lignes suivantes pour que la fonction réponde à la demande :\ndef initialiser() :\n    jeu = [] \n    for c in [\"coeur\", \"carreau\", \"trefle\", \"pique\"]:\n        for v in range( ... ) :\n            carte_cree = ...\n            jeu.append(carte_cree)\n    return jeu\nÉcrire une fonction comparer(cartel, carte2) qui prend en paramètres deux objets de la classe Carte. Cette fonction renvoie :\n\n0 si la force des deux cartes est identique,\n1 si la carte cartel est strictement plus forte que carte2\n-1 si la carte carte2 est strictement plus forte que cartel\n\n\nVoir le corrigé"
  },
  {
    "objectID": "langagesProgr/POO_exercices.html#fa-solid-pencil-alt-exercice-4-bac-2022",
    "href": "langagesProgr/POO_exercices.html#fa-solid-pencil-alt-exercice-4-bac-2022",
    "title": "Programmation orientée objets (Exercices)",
    "section": " Exercice 4 (Bac 2022)",
    "text": "Exercice 4 (Bac 2022)\nUn fabricant de brioches décide d’informatiser sa gestion des stocks. Il écrit pour cela un programme en langage Python. Une partie de son travail consiste à développer une classe Stock dont la première version est la suivante :\nclass Stock:\n    def __init__(self):\n        self.qt_farine = 0 # quantité de farine initialisée à 0 g\n        self.nb_oeufs = 0 # nombre d’œufs (0 à l’initialisation)\n        self.qt_beurre = 0 # quantité de beurre initialisée à 0 g\n\nÉcrire une méthode ajouter_beurre(self, qt) qui ajoute la quantité qt de beurre à un objet de la classe Stock.\nOn admet que l’on a écrit deux autres méthodes ajouter_farine et ajouter_oeufs qui ont des fonctionnements analogues.\nÉcrire une méthode afficher(self) qui affiche la quantité de farine, d’œufs et de beurre d’un objet de type Stock. L’exemple ci-dessous illustre l’exécution de cette méthode dans la console :\n&gt;&gt;&gt; mon_stock = Stock() \n&gt;&gt;&gt; mon_stock.afficher() \nfarine: 0 \noeuf: 0 \nbeurre: 0 \n&gt;&gt;&gt; mon_stock.ajouter_beurre(560) \n&gt;&gt;&gt; mon_stock.afficher() \nfarine: 0 \noeuf: 0 \nbeurre: 560 \nPour faire une brioche, il faut 350 g de farine, 175 g de beurre et 4 oeufs. Écrire une méthode stock_suffisant_brioche(self) qui renvoie un booléen : VRAI s’il y a assez d’ingrédients dans le stock pour faire une brioche et FAUX sinon.\nOn considère la méthode supplémentaire produire(self) de la classe Stock donnée par le code suivant :\ndef produire(self):\n    res = 0 \n    while self.stock_suffisant_brioche():\n        self.qt_beurre = self.qt_beurre - 175 \n        self.qt_farine = self.qt_farine - 350 \n        self.nb_oeufs = self.nb_oeufs - 4 \n        res = res + 1\n    return res\nOn considère un stock défini par les instructions suivantes :\n&gt;&gt;&gt; mon_stock=Stock()\n&gt;&gt;&gt; mon_stock.ajouter_beurre(1000) \n&gt;&gt;&gt; mon_stock.ajouter_farine(1000) \n&gt;&gt;&gt; mon_stock.ajouter_oeufs(10)\n\nOn exécute ensuite l’instruction : &gt;&gt;&gt; mon_stock.produire(). Quelle valeur s’affiche dans la console ? Que représente cette valeur ?\nOn exécute ensuite l’instruction : &gt;&gt;&gt; mon_stock.afficher(). Que s’affiche-t-il dans la console ?\n\nL’industriel possède n lieux de production distincts et donc n stocks distincts.\nOn suppose que ces stocks sont dans une liste dont chaque élément est un objet de type Stock. Écrire une fonction Python nb_brioches(liste_stocks) possédant pour unique paramètre la liste des stocks et qui renvoie le nombre total de brioches produites.\n\nVoir le corrigé"
  },
  {
    "objectID": "langagesProgr/recursivite_cours.html",
    "href": "langagesProgr/recursivite_cours.html",
    "title": "Récursivité (Cours)",
    "section": "",
    "text": "Un algorithme est dit récursif s’il s’appelle lui-même directement ou indirectement via l’appel d’une ou de plusieurs autres fonctions qui elles-mêmes finissent par l’appeler.\nLa récursivité est un concept fondamental en informatique qui met naturellement en pratique un mode de pensée puissant qui consiste à pouvoir découper la tâche à réaliser en sous-tâches de mêmes natures mais plus petites qui finalement sont simples à résoudre.\nPrenons par exemple le calcul de la factorielle d’un nombre entier \\(n\\). Par définition pour un \\(n\\) entier strictement positif, \\(n!\\) est égale au produit des entiers strictement positifs inférieurs à \\(n\\). Par convention on a aussi \\(0! = 1\\).\nPar exemple, on a : \\(5!=1\\times 2\\times 3\\times 4\\times 5 = 120\\).\nDonnons le code itératif d’une fonction calculant la factorielle:\n  def fact(n):\n    \"\"\"Renvoie la factorielle de n.\"\"\"\n    res = 1\n    for i in range(1,n+1):\n      res = res * i  \n    return res\nLa définition récursive se base sur le fait que \\(n! = n\\times (n-1)!\\) pour tout \\(n&gt;0\\).\nOn obtient le code:\n  def fact(n):\n    \"\"\"Renvoie la factorielle de n (méthode récursive).\"\"\"\n    if n == 0:\n      res = 1\n    else:\n      res = n*fact(n-1)\n    return res\nPour commencer à comprendre comment fonctionne cette fonction récursive, nous pouvons visualiser le calcul de fact(4) grâce à l’outil Python Tutor ci-dessous."
  },
  {
    "objectID": "langagesProgr/recursivite_cours.html#motivation-et-introduction-du-concept",
    "href": "langagesProgr/recursivite_cours.html#motivation-et-introduction-du-concept",
    "title": "Récursivité (Cours)",
    "section": "",
    "text": "Un algorithme est dit récursif s’il s’appelle lui-même directement ou indirectement via l’appel d’une ou de plusieurs autres fonctions qui elles-mêmes finissent par l’appeler.\nLa récursivité est un concept fondamental en informatique qui met naturellement en pratique un mode de pensée puissant qui consiste à pouvoir découper la tâche à réaliser en sous-tâches de mêmes natures mais plus petites qui finalement sont simples à résoudre.\nPrenons par exemple le calcul de la factorielle d’un nombre entier \\(n\\). Par définition pour un \\(n\\) entier strictement positif, \\(n!\\) est égale au produit des entiers strictement positifs inférieurs à \\(n\\). Par convention on a aussi \\(0! = 1\\).\nPar exemple, on a : \\(5!=1\\times 2\\times 3\\times 4\\times 5 = 120\\).\nDonnons le code itératif d’une fonction calculant la factorielle:\n  def fact(n):\n    \"\"\"Renvoie la factorielle de n.\"\"\"\n    res = 1\n    for i in range(1,n+1):\n      res = res * i  \n    return res\nLa définition récursive se base sur le fait que \\(n! = n\\times (n-1)!\\) pour tout \\(n&gt;0\\).\nOn obtient le code:\n  def fact(n):\n    \"\"\"Renvoie la factorielle de n (méthode récursive).\"\"\"\n    if n == 0:\n      res = 1\n    else:\n      res = n*fact(n-1)\n    return res\nPour commencer à comprendre comment fonctionne cette fonction récursive, nous pouvons visualiser le calcul de fact(4) grâce à l’outil Python Tutor ci-dessous."
  },
  {
    "objectID": "langagesProgr/recursivite_cours.html#mécanisme",
    "href": "langagesProgr/recursivite_cours.html#mécanisme",
    "title": "Récursivité (Cours)",
    "section": "2. Mécanisme",
    "text": "2. Mécanisme\nConsidérons la fonction foo ci-dessous :\ndef foo(n):\n    if n == 0:\n        print(\"Cas de base : \", n)\n    else:\n        print(\"Début avec n = \" , n)\n        foo(n-1)\n        print(\"Fin avec n = \" , n)\n\n\nfoo(3)\nCe programme génère la sortie suivante :\nDébut avec n =  3\nDébut avec n =  2\nDébut avec n =  1\nCas de base :  0\nFin avec n =  1\nFin avec n =  2\nFin avec n =  3\nL’observation de ces résultats permet de comprendre que le système, lors de l’exécution de ce programme, utilise une pile d’exécution. Une pile d’exécution permet d’enregistrer des informations sur les fonctions en cours d’exécution dans un programme. On parle de pile, car les exécutions successives “s’empilent” les unes sur les autres, comme une pile d’assiettes, ou de crêpes. Si nous nous intéressons à la pile d’exécution du programme étudié ci-dessus, nous obtenons le schéma suivant :\n\n\n\nPile d’exécution\n\n\nIl est important de bien comprendre que la fonction située au sommet de la pile d’exécution est en cours d’exécution. Toutes les fonctions situées “en dessous” sont mises en pause jusqu’au moment où elles se retrouveront au sommet de la pile. Quand une fonction termine son exécution, elle est automatiquement retirée du sommet de la pile (on dit que la fonction est dépilée).\nLa pile d’exécution permet de retenir la prochaine instruction à exécuter au moment où une fonction sera sortie de son “état de pause” (qu’elle se retrouvera au sommet de la pile d’exécution). Elle enregistre aussi le contexte, c’est-à-dire par exemple ici la valeur de la variable locale \\(n\\) associée à chaque appel de la fonction.\nNous pouvons comprendre que ce sont plusieurs copies (on dira plutôt des instances) de la fonction foo qui sont présentent dans la pile, chacune ayant son propre espace de noms : la variable \\(n\\) de la fonction située en haut de la pile n’est pas la même que la variable \\(n\\) de la fonction située en-dessous.\n\n\n\n\n\n\nLimitation propre à Python\n\n\n\nLe langage Python limite à 1000 le nombre d’appels récursifs d’une fonction, autrement dit la hauteur de la pile.\nRecursionError: maximum recursion depth exceeded while calling a Python object"
  },
  {
    "objectID": "langagesProgr/recursivite_cours.html#écrire-un-algorithme-récursif",
    "href": "langagesProgr/recursivite_cours.html#écrire-un-algorithme-récursif",
    "title": "Récursivité (Cours)",
    "section": "3. Écrire un algorithme récursif",
    "text": "3. Écrire un algorithme récursif\nLors de l’écriture d’un algorithme récursif, trois règles doivent toujours être vérifiées :\n\n\n\n\n\n\nLes trois règles de récursivité\n\n\n\n\nLa fonction s’appelle elle-même !\nLa fonction comporte un “cas de base” qui correspond à une condition d’arrêt.\nL’algorithme conduit vers le cas de base : il n’y a pas une infinité d’appels récursifs.\n\n\n\nLa troisième règle est assurée par la preuve de terminaison qui se fait souvent en identifiant la construction d’une suite strictement décroissante d’entiers positifs ou nuls."
  },
  {
    "objectID": "langagesProgr/recursivite_cours.html#fonction-récursive-et-fonction-itérative",
    "href": "langagesProgr/recursivite_cours.html#fonction-récursive-et-fonction-itérative",
    "title": "Récursivité (Cours)",
    "section": "4. Fonction récursive et fonction itérative",
    "text": "4. Fonction récursive et fonction itérative\nLa programmation récursive n’est ni meilleure, ni pire que, la programmation itérative. Toute fonction récursive peut aussi être programmée de façon itérative. Cependant, en cas de nombreux appels récursifs, la mémoire de la machine sera trop fortement sollicitée et l’exécution ralentie, voire impossible.\nLe choix entre une solution récursive ou une solution itérative est donc guidé par le type de problème à résoudre car certains problèmes s’écrivent naturellement de façon récursive."
  },
  {
    "objectID": "langagesProgr/recursivite_exercices.html",
    "href": "langagesProgr/recursivite_exercices.html",
    "title": "Récursivité (Exercices)",
    "section": "",
    "text": "Les exercices précédés du symbole  sont à faire sur machine, en sauvegardant le fichier si nécessaire.\nLes exercices précédés du symbole  doivent être résolus par écrit."
  },
  {
    "objectID": "langagesProgr/recursivite_exercices.html#fa-solid-pencil-alt-exercice-1-factorielle",
    "href": "langagesProgr/recursivite_exercices.html#fa-solid-pencil-alt-exercice-1-factorielle",
    "title": "Récursivité (Exercices)",
    "section": " Exercice 1 : factorielle",
    "text": "Exercice 1 : factorielle\nOn rappelle l’exemple du premier paragraphe du cours concernant le calcul de la factorielle \\(n!=1\\times 2\\times 3\\times\\ldots\\times n\\) d’un entier naturel \\(n\\), dans sa version récursive.\n  def fact(n):\n    \"\"\"Renvoie la factorielle de n (méthode récursive).\"\"\"\n    if n == 0:\n      res = 1\n    else:\n      res = n*fact(n-1)\n    return res\n\nDans cette fonction, quel est le cas de base ?\nDémontrer que l’algorithme se termine (preuve de terminaison) dès lors que l’argument \\(n\\) donné initialement est un entier naturel.\nQue se passe-t-il si on appelle la fonction fact avec \\(n=-2\\) ? Proposer une modification de la fonction pour traiter ce type de cas.\nPour démontrer que cet algorithme renvoie bien \\(n!\\) lorsque \\(n\\) est un entier naturel, on peut procéder par un raisonnement par récurrence.\n\nCas de base : pour \\(n=0\\), la fonction renvoie-t-elle \\(0!\\) ?\nHypothèse : on suppose que, pour une certaine valeur de l’entier naturel non nul \\(n\\), fact(n-1) renvoie \\((n-1)!\\). Montrer que, sous cette hypothèse, fac(n) renvoie bien \\(n!\\).\nConclusion : en déduire que fac(n) renvoie \\(n!\\) pour tout entier naturel \\(n\\).\n\nPour évaluer la complexité de cet algorithme, nous allons compter le nombre de multiplications et de comparaisons effectuées. Démontrer, à l’aide d’un raisonnement pas récurrence, que la complexité de cet algorithme est en \\(\\mathcal{O}(n)\\).\n\n\n\n\n\n\n\nÀ retenir …\n\n\n\n\nLe principe de la preuve de terminaison.\nLe principe du raisonnement pas récurrence"
  },
  {
    "objectID": "langagesProgr/recursivite_exercices.html#fa-solid-pencil-alt-fa-desktop-exercice-2-suite-de-fibonacci",
    "href": "langagesProgr/recursivite_exercices.html#fa-solid-pencil-alt-fa-desktop-exercice-2-suite-de-fibonacci",
    "title": "Récursivité (Exercices)",
    "section": "  Exercice 2 : suite de Fibonacci",
    "text": "Exercice 2 : suite de Fibonacci\nLa suite de Fibonacci est une suite de nombres entiers notés \\(F_n\\), définie par \\(F_0=0\\), \\(F_1=1\\) et dans laquelle chaque terme est égal à la somme des deux termes qui le précèdent.\n\nCalculer \\(F_n\\) à la main pour les valeurs de \\(n\\) allant de 2 jusqu’à 5.\nRecopier et compléter le code de la fonction fibo_iter qui retourne \\(F_n\\) en utilisant un algorithme itératif.\ndef fibo_iter(n: int) -&gt; int:\n    \"\"\"Suite de Fibonacci, version itérative\"\"\"\n    if n == 0:\n        return 0\n    else:\n        f0, f1 = 0, 1\n        for k in range(1, n):\n            f0, f1 = ...  # Ligne à compléter ...\n        return f1\n\n\nfor k in range(10):\n    print(fibo_iter(k))\nÉvaluer la complexité en termes de nombre d’additions.\nD’après la définition de la suite, on a, pour tout entier naturel \\(n\\geqslant 2\\) :\n\\[F_{n}=F_{n-2}+F_{n-1}\\]\nEn déduire une version récursive de l’algorithme de calcul de \\(F_n\\). Cet algorithme a ceci de particulier que chaque fonction procède à deux appels récursifs. On pourra recopier et compléter le code ci-dessous.\ndef fibo_rec(n: int) -&gt; int:\n    \"\"\"Suite de Fibonacci version récursive\"\"\"\n    # Cas de base\n    if ...:\n        return n\n    # Récursion\n    else:\n        return ...\n\n\nfor k in range(10):\n    print(fibo_rec(k))\nUtiliser chacune des deux versions pour calculer la valeur de \\(F_{50}\\). Que constate-t-on ? Expliquer.\n\n\n\n\n\n\n\nRemarques et compléments\n\n\n\n\n\nLa version récursive se révèle beaucoup moins efficace. Pour comprendre pourquoi, nous pouvons représenter par un arbre les appels récursifs nécessaires.\n\n\n\n\n\nOn retrouve les cas de base dans les feuilles de l’arbre. Nous pouvons constater que le nombre d’appels récursifs est très grand. Il est possible de démontrer que ce nombre augmente de façon exponentielle. Pour calculer \\(F_{100}\\), il y aurait environ \\(10^{20}\\) opérations. À raison de \\(10^9\\) opérations par seconde, la calcul prendra de l’ordre de \\(10^{11}\\) secondes, soit environ 3 000 ans !\nUn autre constat qui montre l’inefficacité de ce programme : plusieurs calculs identiques sont répétés plusieurs fois. On calcule par exemple \\(F_3\\) deux fois et \\(F_2\\) trois fois. Une solution meilleure serait de garder en mémoire les éléments déjà calculés et de ne calculer que les nouveaux éléments encore jamais rencontrés. Une telle démarche relève de la programmation dynamique qui sera abordée en fin d’année.\nPour satisfaire votre curiosité insatiable, vous pouvez déjà observer et tester le programme ci-dessous :\ndef fibo_dyn(n: int, suite: dict = {0: 0, 1: 1}) -&gt; int:\n    \"\"\"Suite de Fibonacci version dynamique\"\"\"\n    # Cas de base\n    if n == 0 or n == 1:\n        return n\n    # Récursion\n    else:\n        # Si Fn est déjà calculé, on le retourne\n        if n in suite.keys():\n            return suite[n]\n        else:\n            # Sinon, on le calcule et on le garde en mémoire\n            f = fibo_dyn(n-2, suite) + fibo_dyn(n-1, suite)\n            suite[n] = f\n            return f\n\n\nfor k in range(10):\n    print(fibo_dyn(k))\nUne exécution dans PythonTutor est instructive :\n\n\nVoir cet article du blog qui explique comment visualiser le temps d’exécution d’une fonction."
  },
  {
    "objectID": "langagesProgr/recursivite_exercices.html#fa-solid-pencil-alt-fa-desktop-exercice-3-calcul-de-xn",
    "href": "langagesProgr/recursivite_exercices.html#fa-solid-pencil-alt-fa-desktop-exercice-3-calcul-de-xn",
    "title": "Récursivité (Exercices)",
    "section": "  Exercice 3 : calcul de \\(x^n\\)",
    "text": "Exercice 3 : calcul de \\(x^n\\)\nPour tout nombre réel \\(x\\) et tout entier naturel \\(n\\), \\(x^n\\) est défini par \\(x^0=1\\) et, pour \\(n&gt;0\\), \\(x^n=x\\times x\\times x\\times \\ldots \\times x\\) : produit de \\(n\\) facteurs tous égaux à \\(x\\).\nLes règles de calcul sur les exposants permettent d’affirmer que, pour \\(n&gt;0\\), \\(x^n=x\\times x^{n-1}\\).\n\nÉcrire la fonction récursive puissance(x,n) qui calcule le nombre \\(x^n\\) pour tout entier naturel \\(n\\).\nDessiner l’arbre d’appels de cette fonction pour \\(x=3\\) et \\(n=5\\).\nPour les plus rapides\n\n\n\n\n\n\n\nQuestion bonus\n\n\n\nUn autre méthode de calcul de \\(x^n\\) consiste à distinguer le cas où \\(n\\) est pair et celui où \\(n\\) est impair :\n\nsi \\(n=0\\), alors \\(x^n=1\\) ;\nsi \\(n\\) est pair, alors \\(x^n=\\left(x^{n/2}\\right)^2\\) ;\nsi \\(n\\) est impair, alors \\(x^n=x\\times\\left(x^{(n-1)/2}\\right)^2\\).\n\nL’algorithme qui découle de cette définition porte également le nom d’exponentiation rapide. Comme son nom l’indique, il s’agit d’un algorithme particulièrement efficace pour calculer rapidement de grandes puissances entières.\nÉcrire la fonction récursive puissancev2(x,n) qui calcule le nombre \\(x^n\\) pour tout entier naturel n selon la méthode d’exponentiation rapide."
  },
  {
    "objectID": "langagesProgr/recursivite_exercices.html#fa-solid-pencil-alt-exercice-4-maximum-dune-liste",
    "href": "langagesProgr/recursivite_exercices.html#fa-solid-pencil-alt-exercice-4-maximum-dune-liste",
    "title": "Récursivité (Exercices)",
    "section": " Exercice 4 : maximum d’une liste",
    "text": "Exercice 4 : maximum d’une liste\nOn considère le programme ci-dessous :\ndef maximum(a, b):\n    if a &gt; b:\n        return a\n    else:\n        return b\n\ndef maximum_tab(tab):\n    if len(tab) == 1:\n        return tab[0]\n    else:\n        return maximum(tab[0], maximum_tab(tab[1:]))\n\nfrom random import randint\n\nmon_tab = []\nfor i in range(20):\n    mon_tab.append(randint(-100, 100))\nprint(mon_tab)\nprint(maximum_tab(mon_tab))\n\nDécrire, en langage usuel, le principe de fonctionnement de la fonction maximum_tab.\nExpliquer en quoi la fonction maximum_tab est récursive. Quel est le cas de base ?\nProuver la terminaison de cette fonction.\nEffectuer par récurrence la preuve de cet algorithme (c’est-à-dire prouver que la fonction retourne bien le maximum du tableau donné en argument).\nDessiner l’arbre d’appels de cette fonction pour l’appel maximum_tab([-4,55,-1,-35,-52,31])."
  },
  {
    "objectID": "langagesProgr/recursivite_exercices.html#fa-desktop-exercice-5-palindromes",
    "href": "langagesProgr/recursivite_exercices.html#fa-desktop-exercice-5-palindromes",
    "title": "Récursivité (Exercices)",
    "section": " Exercice 5 : palindromes",
    "text": "Exercice 5 : palindromes\nOn appelle palindrome un mot qui se lit dans les deux sens comme « été » ou « radar ».\nÉcrire une fonction récursive palindrome qui teste si un mot est un palindrome.\n\nEntrée : Un mot (type str).\nSortie : Un booléen égal à True si le mot est un palindrome, False sinon.\n\nOn considérera les deux cas suivant comme cas de base :\n\nsi le mot est la chaîne vide, c’est un palindrome ;\nsi le mot ne contient qu’une seule lettre, c’est un palindrome"
  },
  {
    "objectID": "langagesProgr/recursivite_exercices.html#fa-solid-pencil-alt-fa-desktop-exercice-6-flocon-de-von-koch",
    "href": "langagesProgr/recursivite_exercices.html#fa-solid-pencil-alt-fa-desktop-exercice-6-flocon-de-von-koch",
    "title": "Récursivité (Exercices)",
    "section": "  Exercice 6 : flocon de von Koch",
    "text": "Exercice 6 : flocon de von Koch\nUne image qui a une apparence similaire quelle que soit l’échelle à laquelle on l’observe est appelée une fractale (il y a d’autres types de fractales).\nUn exemple simple de fractale est le flocon de Von Koch, dont voici une représentation (pour un degré 4).\n\n\n\nFlocon de von Koch\n\n\nOn peut la créer à partir d’un segment de droite, en modifiant récursivement chaque segment de droite de la façon suivante :\n\non divise le segment de droite en trois segments de longueurs égales ;\non construit un triangle équilatéral ayant pour base le segment médian de la première étape ;\non supprime le segment de droite qui était la base du triangle de la deuxième étape.\n\nVoici le résultat obtenu en une étape :\n\n\n\nÉtape de construction\n\n\nPour continuer, il suffit de considérer chaque segment de cette dernière figure comme segment de départ.\nfrom turtle import *\n\n\ndef Koch(n, d):\n    if n == 0:\n        forward(d)\n    else:\n        Koch(n-1, d/3)\n        left(60)\n        Koch(n-1, d/3)\n        right(120)\n        Koch(n-1, d/3)\n        left(60)\n        Koch(n-1, d/3)\n    return None\n\n\ndef flocon(n, d):\n    for k in range(3):\n        Koch(n, d)\n        right(120)\n    return None\n\n\nflocon(4, 300)\nexitonclick()\n\nIdentifier le cas de base de la fonction récursive Koch(n, d). Que fait-il ?\nModifier les paramètres n et d lors de l’appel à la fonction flocon et observer l’impact de ces modifications sur le dessin.\nCombien d’appels récursifs sont-ils réalisés lors de l’appel de la fonction Koch(4, 300) ?"
  },
  {
    "objectID": "langagesProgr/recursivite_exercices.html#fa-solid-pencil-alt-exercice-7-type-bac",
    "href": "langagesProgr/recursivite_exercices.html#fa-solid-pencil-alt-exercice-7-type-bac",
    "title": "Récursivité (Exercices)",
    "section": " Exercice 7 (type bac)",
    "text": "Exercice 7 (type bac)"
  },
  {
    "objectID": "langagesProgr/TPHanoi.html",
    "href": "langagesProgr/TPHanoi.html",
    "title": "TP Tours de Hanoï",
    "section": "",
    "text": "Dans ce TP, vous mettrez en œuvre une procédure récursive afin de résoudre le célèbre problème des tours de Hanoï.\n\n\n\n\n\n\nObjectifs\n\n\n\n\nComprendre un algorithme.\nÉcrire une procédure récursive.\nCalculer une complexité.\n\n\n\nL’énoncé au format PDF est disponible ci-dessous.\n\n\n\n\n\n\nCritères d’évaluation\n\n\n\n\nReprésentation correcte des solutions “à la main”.\nLa procédure résout le problème.\nLa procédure fournit l’affichage demandé.\nJustification correcte du calcul de complexité (en nombre de déplacements)."
  },
  {
    "objectID": "langagesProgr/TPPOOBataille.html",
    "href": "langagesProgr/TPPOOBataille.html",
    "title": "TP - Bataille",
    "section": "",
    "text": "TP : le jeu de la bataille\nDans ce TP, vous mettrez en œuvre la POO pour créer un programme qui joue à la bataille.\n\n\n\nJeu de carte\n\n\n\n\n\n\n\n\nObjectifs\n\n\n\n\nDéfinir une classe et ses membres.\nUtiliser des objets, leurs attributs, leurs méthodes.\nRépondre à un cahier des charges.\n\n\n\nL’énoncé au format PDF est disponible ci-dessous.\n\n\n\n\n\n\nCritères d’évaluation\n\n\n\n\nRespect du cahier de charges.\nDocumentation, spécification des méthodes créées.\nLe jeu se déroule sans erreur.\nBonus : tenir compte des compléments sur la POO.\n\n\n\nFichier Python à télécharger et à compléter : bataille_eleves.py"
  },
  {
    "objectID": "ressources.html",
    "href": "ressources.html",
    "title": "Sources utilisées",
    "section": "",
    "text": "Pour rédiger ce cours et préparer les exercices, TP, projets présentés ici, j’ai utilisé de nombreuses sources que je vais essayer de citer ici, sans prétendre être exhaustif.\n\nDocuments d’accompagnement Eduscol.\nContenus du MOOC “Numérique et Sciences Informatiques : les fondamentaux” de l’INRIA, disponible sur la plateforme fun-mooc.\nApprendre à programmer avec Python 3, Gérard Swinnen, éditions Eyrolles, 2012. Disponible en ligne\nLe site interstices : https://interstices.info/.\nLes images et illustrations sont soit produites par mes soins, soit issues de Pixabay ou de Wikimedia commons ou encore de Pexels et, dans tous les cas, libres de droits.\nCours de David Roche.\nCours de Frédéric Junier.\nCours de Van Zuijlen Stéphan.\nCours de Konieczko Quentin\nCours de Olivier Lécluse\nCours du Lycée Blaise Pascal de Clermont-Ferrand\nCours du lycée Champollion de Grenoble\nCours du site Lyceum\nCours du site Mon Lycée Numérique\nCours du Lycée Stanislas de Wissembourg\nCours d’informatique de François Brucker (école Centrale de Marseille)\nCours de Philippe Rigaux sur les bases de données.\nCours de Gilles Lassus\nLe site MDN Web Docs : excellentissime ressource pour tout apprendre sur les langages HTML, CSS, Javascript et le protocole HTTP.\nLe site de M. JANVIER."
  },
  {
    "objectID": "structures/bilan.html",
    "href": "structures/bilan.html",
    "title": "Bilan de la séquence : Structures de données abstraites",
    "section": "",
    "text": "Bilan de la séquence : Structures de données abstraites\n\nCours :\n\nInterfaces et implémentation. : savoir différencier un type abstrait de données et un de ses implémentations, notion d’interface et d’API.\nListes., Piles. et Files. : connaître pour chacune de ces structures, sa définition, son fonctionnement, ses méthodes primitives et une ou deux implémentations différentes. Connaître des situations typiques d’utilisation de ces structures.\nDictionnaires. : connaître la définition, le fonctionnement et les méthodes primitives associées. En particulier, maîtriser l’utilisation des dictionnaires en Python. Connaître l’avantage des dictionnaires dur les listes en termes de performance.\n\nExercices de base faits et corrigés durant la séquence :\n\nFiche sur les listes, piles et files. : exercices 1, 2, 3, 4, 6, 7.\nFiche sur les dictionnaires. : exercices 1, 2, 3, 4. Correction de l’exercice 4.\n\nProblèmes, T.P. et mini projets étudiés durant la séquence :\n\nParenthésage correct. : exercice 5. Corrigé.\nT.P. Carnet d’adresses sur les dictionnaires. Corrigé.\nProjet détecteur de langue : utilisation de dictionnaires. corrigé.\nNotation polonaise inverse : énoncé et corrigé.\n2021 Métropole Jour 1 : exo 2 : énoncé et corrigé.\n2022 Centres étrangers Jour 1 : exo 1 : énoncé et corrigé.\n2022 Centres étrangers Jour 1 : exo 2 : énoncé et corrigé.\n\nProblèmes supplémentaires tirés des annales :\n\n2021 Centres étrangers Jour 2 : exo 1.\n2021 Centres étrangers Jour 1 : exo 5.\n2021 Amérique du Nord Jour1 : exo 5.\n2021 Sujet zéro : exo 1.\n2022 Métropole Jour 1 : exo 1.\n2022 Métropole Jour 2 : exo 2.\n2022 Mayotte Liban Jour 1 : exo 1.\n2022 Mayotte Liban Jour 2 : exo 1.\n2022 Amérique du Nord Jour 1 : exo 5.\n2022 Centres étrangers Jour 2 : exo 2.\n2021 Centres étrangers Jour 1 : exo 2.\n2021 Métropole Septembre Jour 2 : exo 2."
  },
  {
    "objectID": "structures/dictionnaires_cours.html",
    "href": "structures/dictionnaires_cours.html",
    "title": "Dictionnaires (Cours)",
    "section": "",
    "text": "Nous allons maintenant étudier un autre type abstrait de données : les dictionnaires aussi appelés tableaux associatifs.\n\n\n\n\n\n\nDéfinition\n\n\n\nUn dictionnaire est une structure de donnée permettant d’indexer des objets par leur nom plutôt que par un nombre.\n\n\nOn retrouve une structure qui ressemble, à première vue, beaucoup à un tableau (à chaque élément on associe un indice de position). Mais au lieu d’associer chaque élément à un indice de position, dans un dictionnaire, on associe chaque élément (on parle de valeur dans un dictionnaire) à une clé, on dit qu’un dictionnaire contient des couples clé:valeur (chaque clé est associée à une valeur).\nUn dictionnaire associe une clé à une valeur. On peut voir les tableaux comme un dictionnaire où les clés sont des entiers allant de 0 à la longueur de la liste moins 1.\nMais cela peut être bien plus général :\n\nles clés peuvent être des mots et les valeurs un nombre. Cela permet par exemple de compter le nombre de fois où un chaque mot d’un texte apparaît.\nassocier un nom (valeur) à un numéro de téléphone (clé) sans avoir besoin d’une liste allant de 0 à numéro max de téléphone.\n\nLes clés ne doivent pas changer une fois créées, sinon la serrure fabriquée dans le dictionnaire ne fonctionne plus. On ne doit donc utiliser que des objets non modifiables pour créer des clés d’un dictionnaire Python. Comme :\n\ndes entiers\ndes réels\ndes chaines de caractères\ndes tuples\n\n\n\n\n\n\n\nExemple\n\n\n\nExemples de couples clé:valeur :\n\nprenom:Kevin, nom:Durand, naissance:17-05-2005.\nprenom, nom et naissance sont des clés ; Kevin, Durand et 17-05-2005 sont des valeurs.\n\n\n\nLes méthodes primitives permettant de définir l’interface de la structure de dictionnaire peuvent être les suivantes :\n\ncréer() : création d’un nouveau dictionnaire vide ;\najouter(dict, clé, valeur) : on associe une nouvelle valeur à une nouvelle clé ;\nmodifier(dict, clé, valeur) : on modifie un couple clé:valeur en remplaçant la valeur courante par une autre valeur (la clé restant identique) ;\nsupprimer(dict, clé) : on supprime une clé (et donc la valeur qui lui est associée) ;\nrechercher(dict, clé) : on recherche une valeur à l’aide de la clé associée à cette valeur.\n\n\n\n\n\n\n\nExemple\n\n\n\nSoit le dictionnaire D composé des couples clé:valeur suivants : prenom:Kevin, nom:Durand, naissance:17-05-2005. Pour chaque exemple ci-dessous on repart du dictionnaire d’origine :\najouter(D, tel, 06060606)\nmodifier(D,nom,Dupont)\nsupprimer(D, naissance)\nrechercher(D, prenom)\n\nLigne 1 : le dictionnaire D est maintenant composé des couples suivants : prenom:Kevin, nom:Durand, date-naissance:17-05-2005, tel:06060606 ;\nLigne 2 : le dictionnaire D est maintenant composé des couples suivants : prenom:Kevin, nom:Dupont, date-naissance:17-05-2005 ;\nLigne 3 : le dictionnaire D est maintenant composé des couples suivants : prenom:Kevin, nom:Durand ;\nLigne 4 : la fonction renvoie Kevin.\n\n\n\nL’utilisation de la structure dictionnaire en Python a été étudiée en première. Il faut donc revoir le cours correspondant."
  },
  {
    "objectID": "structures/dictionnaires_cours.html#du-point-de-vue-utilisateur-interface",
    "href": "structures/dictionnaires_cours.html#du-point-de-vue-utilisateur-interface",
    "title": "Dictionnaires (Cours)",
    "section": "",
    "text": "Nous allons maintenant étudier un autre type abstrait de données : les dictionnaires aussi appelés tableaux associatifs.\n\n\n\n\n\n\nDéfinition\n\n\n\nUn dictionnaire est une structure de donnée permettant d’indexer des objets par leur nom plutôt que par un nombre.\n\n\nOn retrouve une structure qui ressemble, à première vue, beaucoup à un tableau (à chaque élément on associe un indice de position). Mais au lieu d’associer chaque élément à un indice de position, dans un dictionnaire, on associe chaque élément (on parle de valeur dans un dictionnaire) à une clé, on dit qu’un dictionnaire contient des couples clé:valeur (chaque clé est associée à une valeur).\nUn dictionnaire associe une clé à une valeur. On peut voir les tableaux comme un dictionnaire où les clés sont des entiers allant de 0 à la longueur de la liste moins 1.\nMais cela peut être bien plus général :\n\nles clés peuvent être des mots et les valeurs un nombre. Cela permet par exemple de compter le nombre de fois où un chaque mot d’un texte apparaît.\nassocier un nom (valeur) à un numéro de téléphone (clé) sans avoir besoin d’une liste allant de 0 à numéro max de téléphone.\n\nLes clés ne doivent pas changer une fois créées, sinon la serrure fabriquée dans le dictionnaire ne fonctionne plus. On ne doit donc utiliser que des objets non modifiables pour créer des clés d’un dictionnaire Python. Comme :\n\ndes entiers\ndes réels\ndes chaines de caractères\ndes tuples\n\n\n\n\n\n\n\nExemple\n\n\n\nExemples de couples clé:valeur :\n\nprenom:Kevin, nom:Durand, naissance:17-05-2005.\nprenom, nom et naissance sont des clés ; Kevin, Durand et 17-05-2005 sont des valeurs.\n\n\n\nLes méthodes primitives permettant de définir l’interface de la structure de dictionnaire peuvent être les suivantes :\n\ncréer() : création d’un nouveau dictionnaire vide ;\najouter(dict, clé, valeur) : on associe une nouvelle valeur à une nouvelle clé ;\nmodifier(dict, clé, valeur) : on modifie un couple clé:valeur en remplaçant la valeur courante par une autre valeur (la clé restant identique) ;\nsupprimer(dict, clé) : on supprime une clé (et donc la valeur qui lui est associée) ;\nrechercher(dict, clé) : on recherche une valeur à l’aide de la clé associée à cette valeur.\n\n\n\n\n\n\n\nExemple\n\n\n\nSoit le dictionnaire D composé des couples clé:valeur suivants : prenom:Kevin, nom:Durand, naissance:17-05-2005. Pour chaque exemple ci-dessous on repart du dictionnaire d’origine :\najouter(D, tel, 06060606)\nmodifier(D,nom,Dupont)\nsupprimer(D, naissance)\nrechercher(D, prenom)\n\nLigne 1 : le dictionnaire D est maintenant composé des couples suivants : prenom:Kevin, nom:Durand, date-naissance:17-05-2005, tel:06060606 ;\nLigne 2 : le dictionnaire D est maintenant composé des couples suivants : prenom:Kevin, nom:Dupont, date-naissance:17-05-2005 ;\nLigne 3 : le dictionnaire D est maintenant composé des couples suivants : prenom:Kevin, nom:Durand ;\nLigne 4 : la fonction renvoie Kevin.\n\n\n\nL’utilisation de la structure dictionnaire en Python a été étudiée en première. Il faut donc revoir le cours correspondant."
  },
  {
    "objectID": "structures/dictionnaires_cours.html#du-point-de-vue-concepteur-implémentation",
    "href": "structures/dictionnaires_cours.html#du-point-de-vue-concepteur-implémentation",
    "title": "Dictionnaires (Cours)",
    "section": "2. Du point de vue concepteur : Implémentation",
    "text": "2. Du point de vue concepteur : Implémentation\nL’implémentation du type abstrait dictionnaire est complexe et dépasse le cadre du programme de NSI. Cette implémentation utilise des fonctions de hachage.\n\n\n\n\n\nL’utilisation des tables et des fonctions de hachages est omniprésente en informatique, il est donc utile pour votre “culture générale informatique”, de connaître le principe des fonctions de hachages. Voici un texte qui vous permettra de comprendre le principe des fonctions de hachages : c’est quoi le hachage ? . Pour avoir quelques idées sur le principe des tables de hachages, je vous recommande le visionnage de cette vidéo : les tables de hachage.\nOn peut retenir que\n\n\n\n\n\n\nÀ retenir\n\n\n\nLa complexité de recherche, d’ajout et de suppression d’un élément dans un dictionnaire est en \\(\\mathcal{O}(1)\\) : elle ne dépend pas du nombre d’éléments présents dans le dictionnaire.\nEn comparaison, la complexité de l’algorithme de recherche dans un tableau non trié est \\(\\mathcal{O}(n)\\).\nLa structure de dictionnaire est donc une structure très efficace ! N’hésitez pas à l’utiliser car son temps moyen d’exécution est très rapide."
  },
  {
    "objectID": "structures/dictionnaires_exercices.html",
    "href": "structures/dictionnaires_exercices.html",
    "title": "Dictionnaires (Exercices)",
    "section": "",
    "text": "Les exercices précédés du symbole  sont à faire sur machine, en sauvegardant le fichier si nécessaire.\nLes exercices précédés du symbole  doivent être résolus par écrit."
  },
  {
    "objectID": "structures/dictionnaires_exercices.html#fa-solid-pencil-alt-exercice-1",
    "href": "structures/dictionnaires_exercices.html#fa-solid-pencil-alt-exercice-1",
    "title": "Dictionnaires (Exercices)",
    "section": " Exercice 1",
    "text": "Exercice 1\nSoit le programme Python suivant :\ninventaire = {'pommes': 430, 'bananes': 312,'oranges' : 274, 'poires' : 137}\n\nstock = 0\nfor fruit in inventaire.keys():\n  if fruit != 'bananes':\n    stock = stock + inventaire[fruit]\nQuelle est la valeur de la variable stock après l’exécution de ce programme ?"
  },
  {
    "objectID": "structures/dictionnaires_exercices.html#fa-solid-pencil-alt-exercice-2",
    "href": "structures/dictionnaires_exercices.html#fa-solid-pencil-alt-exercice-2",
    "title": "Dictionnaires (Exercices)",
    "section": " Exercice 2",
    "text": "Exercice 2\nSoit le programme Python suivant :\nP = [{\"nom\":\"Turing\",\"prenom\":\"Alan\",\"age\":28},{\"nom\":\"Lovelace\",\"prenom\":\"Ada\",\"age\":27}]\nQu’obtient-on si on tape P[1]['age'] dans une console Python ?"
  },
  {
    "objectID": "structures/dictionnaires_exercices.html#fa-solid-pencil-alt-exercice-3",
    "href": "structures/dictionnaires_exercices.html#fa-solid-pencil-alt-exercice-3",
    "title": "Dictionnaires (Exercices)",
    "section": " Exercice 3",
    "text": "Exercice 3\nSoit le programme Python suivant :\ndef ajoute(stock,element,quantite):\n  if element in stock:\n    stock[element] = stock[element] + quantite\n  else:\n    stock[element] = quantite\n\nstock = { 'clous': 14, 'vis': 27, 'boulons': 8, 'écrous': 24 }\najoute(stock,'vis',5)\najoute(stock,'chevilles',3)\nQuelle est la valeur de la variable stock à la fin de cette exécution ?"
  },
  {
    "objectID": "structures/dictionnaires_exercices.html#fa-desktop-exercice-4",
    "href": "structures/dictionnaires_exercices.html#fa-desktop-exercice-4",
    "title": "Dictionnaires (Exercices)",
    "section": " Exercice 4",
    "text": "Exercice 4\nÉcrire une fonction occurrences(texte) répondant aux spécifications ci-dessous :\ndef occurrences(texte: str) -&gt; dict:\n    \"\"\"\n    Retourne un dictionnaire indiquant le nombre d'apparitions de chaque mot dans le texte\n\n    Parameters\n    ----------\n    texte : str\n        chaîne de caractère à étudier\n\n    Returns\n    -------\n    occurrences : dict\n        dictionnaire, clés : str, valeurs = int\n    \"\"\"\nIndication : la méthode split des chaînes de caractères sera fort utile.\nExemple d’exécution en console :\n&gt;&gt;&gt; phrase = \"coucou les gars coucou les filles\"\n&gt;&gt;&gt; occurrences(phrase)\n{'coucou': 2, 'les': 2, 'gars': 1, 'filles': 1}"
  },
  {
    "objectID": "structures/dictionnaires_exercices.html#fa-solid-pencil-alt-exercices-tombés-au-bac",
    "href": "structures/dictionnaires_exercices.html#fa-solid-pencil-alt-exercices-tombés-au-bac",
    "title": "Dictionnaires (Exercices)",
    "section": " Exercices tombés au bac",
    "text": "Exercices tombés au bac\n\n2022 Centres étrangers Jour 1 : exo 1 et exo 3.\n2022 Centres étrangers Jour 2 : exo 2.\n2021 Centres étrangers Jour 1 : exo 2.\n2021 Métropole Septembre Jour 2 : exo 2."
  },
  {
    "objectID": "structures/files_cours.html",
    "href": "structures/files_cours.html",
    "title": "Files (Cours)",
    "section": "",
    "text": "Définition\n\n\n\nLa file, comme la liste et la pile, permet de stocker des données et d’y accéder. La différence se situe au niveau de l’ajout et du retrait d’éléments.\n\nLe prochain élément auquel on peut accéder est le premier élément ajouté à la structure ;\nLes nouveaux éléments viennent en bout de file : on ne pourra y accéder que lorsque tous les éléments ayant été ajoutés avant eux seront sortis de la file.\n\n\n\nOn parle de mode FIFO (First in, First out, en anglais, premier arrivé, premier sorti), c’est-à-dire que le premier élément ayant été ajouté à la structure sera le prochain élément auquel on accédera. Les derniers éléments ajoutés devront « attendre » que tous les éléments ayant été ajoutés avant eux soient sortis de la file. Contrairement aux listes, on ne peut donc pas accéder à n’importe quelle valeur de la structure (pas d’index).\nPour gérer cette contrainte, la pile est caractérisée par deux « emplacements » :\n\nla tête de file, sortie de la file (début de la structure), où les éléments sont retirés ;\nle bout de file, entrée de la file (fin de la structure), où les éléments sont ajoutés.\n\nOn peut s’imaginer une file d’attente, dans un cinéma par exemple. Les premières personnes à pouvoir acheter leur place sont les premières arrivées, et les nouveaux arrivants se placent au bout de la file.\n\n\n\n\n\nUne file est une collection de données. On appelle tête de file le premier élément de la structure et bout de file le dernier élément. Quand un élément est ajouté à la file, on l’ajoute en bout de file et il devient le nouveau bout de file c’est-à-dire l’élément « suivant » l’élément situé précédemment en bout de file. Quand un élément est retiré de la file, on le sélectionne à la tête de la file et la nouvelle tête est l’élément qui suivait l’ancienne tête. Lorsqu’on ajoute un élément à une file vide, celui-ci est donc à la fois la tête et le bout de la file.\n\n\n\n\n\n6 primitives constituent l’interface permettant de définir le type abstrait de données “file” :\n\ncreer(), qui crée une file vide ;\ntaille(file), qui permet de connaître le nombre d’éléments contenus dans la file ;\nest_vide(file), qui renvoie vrai si la file est vide, faux sinon ;\nenfiler(file, element), qui ajoute un élément au bout de la file (et devient le nouveau bout de file) ;\ndefiler(file), qui retire et renvoie l’élément situé à la tête de la file (la nouvelle tête devient l’élément qui suivait l’ancienne tête) ;\ntete(file), qui renvoie l’élément situé à la tête de la file (sans le retirer).\n\nEnfiler se dit enqueue en anglais et défiler se dit dequeue.\n\n\n\n\n\n\nLa file est utile dans différents types de problèmes\n\n\n\n\npour une imprimante, gestion de la file d’attente des documents à imprimer ;\nmodélisation du jeu de la bataille (on révèle la carte au-dessus du paquet et on place celles gagnées en dessous…) ;\ngestion de mémoires tampon, pour gérer les flux de lecture et d’écriture dans un fichier, par exemple ;\nmatérialisation d’une file d’attente, pour un logiciel (visioconférence par exemple) ou un jeu (gestion des connexions des utilisateurs, des tours de jeu…),…\nalgorithme du parcours en largeur pour les arbres et les graphes, par exemple, pour trouver le plus court trajet sur une carte, ou récupérer les valeurs d’une structure dans l’ordre croissant.. (voir séquence 6).\n\n\n\n\n\n\n\n\n\nExemple\n\n\n\nSupposons implémenté le type abstrait file. Nous disposons d’une interface composée des six primitives décrites ci-dessus. On considère une file F composée des éléments suivants : 12, 14, 8, 7, 19 et 22 (la tête = premier élément entré dans la file est 22, le dernier élément entré est 12). On exécute le code suivant ligne par ligne :\n    enfiler(F,42)\n    defiler(F)\n    defiler(F)\n    taille(F)\n    estVide(F)\n    tete(F)\n\nL’exécution de la ligne 1 ajoute l’élément 42 au bout de la file qui contient alors 42, 12, 14, 8, 7, 19, 22 ;\nL’exécution de la ligne 2 affiche 22 et retire cet élément de la file qui contient maintenant 42, 12, 14, 8, 7, 19 ;\nL’exécution de la ligne 3 affiche 19 et retire cet élément de la file qui contient maintenant 42, 12, 14, 8, 7 ;\nLa ligne 4 renvoie la taille de F : 5 ;\nLa file n’est pas vide, on obtient dont False."
  },
  {
    "objectID": "structures/files_cours.html#du-point-de-vue-utilisateur-interface",
    "href": "structures/files_cours.html#du-point-de-vue-utilisateur-interface",
    "title": "Files (Cours)",
    "section": "",
    "text": "Définition\n\n\n\nLa file, comme la liste et la pile, permet de stocker des données et d’y accéder. La différence se situe au niveau de l’ajout et du retrait d’éléments.\n\nLe prochain élément auquel on peut accéder est le premier élément ajouté à la structure ;\nLes nouveaux éléments viennent en bout de file : on ne pourra y accéder que lorsque tous les éléments ayant été ajoutés avant eux seront sortis de la file.\n\n\n\nOn parle de mode FIFO (First in, First out, en anglais, premier arrivé, premier sorti), c’est-à-dire que le premier élément ayant été ajouté à la structure sera le prochain élément auquel on accédera. Les derniers éléments ajoutés devront « attendre » que tous les éléments ayant été ajoutés avant eux soient sortis de la file. Contrairement aux listes, on ne peut donc pas accéder à n’importe quelle valeur de la structure (pas d’index).\nPour gérer cette contrainte, la pile est caractérisée par deux « emplacements » :\n\nla tête de file, sortie de la file (début de la structure), où les éléments sont retirés ;\nle bout de file, entrée de la file (fin de la structure), où les éléments sont ajoutés.\n\nOn peut s’imaginer une file d’attente, dans un cinéma par exemple. Les premières personnes à pouvoir acheter leur place sont les premières arrivées, et les nouveaux arrivants se placent au bout de la file.\n\n\n\n\n\nUne file est une collection de données. On appelle tête de file le premier élément de la structure et bout de file le dernier élément. Quand un élément est ajouté à la file, on l’ajoute en bout de file et il devient le nouveau bout de file c’est-à-dire l’élément « suivant » l’élément situé précédemment en bout de file. Quand un élément est retiré de la file, on le sélectionne à la tête de la file et la nouvelle tête est l’élément qui suivait l’ancienne tête. Lorsqu’on ajoute un élément à une file vide, celui-ci est donc à la fois la tête et le bout de la file.\n\n\n\n\n\n6 primitives constituent l’interface permettant de définir le type abstrait de données “file” :\n\ncreer(), qui crée une file vide ;\ntaille(file), qui permet de connaître le nombre d’éléments contenus dans la file ;\nest_vide(file), qui renvoie vrai si la file est vide, faux sinon ;\nenfiler(file, element), qui ajoute un élément au bout de la file (et devient le nouveau bout de file) ;\ndefiler(file), qui retire et renvoie l’élément situé à la tête de la file (la nouvelle tête devient l’élément qui suivait l’ancienne tête) ;\ntete(file), qui renvoie l’élément situé à la tête de la file (sans le retirer).\n\nEnfiler se dit enqueue en anglais et défiler se dit dequeue.\n\n\n\n\n\n\nLa file est utile dans différents types de problèmes\n\n\n\n\npour une imprimante, gestion de la file d’attente des documents à imprimer ;\nmodélisation du jeu de la bataille (on révèle la carte au-dessus du paquet et on place celles gagnées en dessous…) ;\ngestion de mémoires tampon, pour gérer les flux de lecture et d’écriture dans un fichier, par exemple ;\nmatérialisation d’une file d’attente, pour un logiciel (visioconférence par exemple) ou un jeu (gestion des connexions des utilisateurs, des tours de jeu…),…\nalgorithme du parcours en largeur pour les arbres et les graphes, par exemple, pour trouver le plus court trajet sur une carte, ou récupérer les valeurs d’une structure dans l’ordre croissant.. (voir séquence 6).\n\n\n\n\n\n\n\n\n\nExemple\n\n\n\nSupposons implémenté le type abstrait file. Nous disposons d’une interface composée des six primitives décrites ci-dessus. On considère une file F composée des éléments suivants : 12, 14, 8, 7, 19 et 22 (la tête = premier élément entré dans la file est 22, le dernier élément entré est 12). On exécute le code suivant ligne par ligne :\n    enfiler(F,42)\n    defiler(F)\n    defiler(F)\n    taille(F)\n    estVide(F)\n    tete(F)\n\nL’exécution de la ligne 1 ajoute l’élément 42 au bout de la file qui contient alors 42, 12, 14, 8, 7, 19, 22 ;\nL’exécution de la ligne 2 affiche 22 et retire cet élément de la file qui contient maintenant 42, 12, 14, 8, 7, 19 ;\nL’exécution de la ligne 3 affiche 19 et retire cet élément de la file qui contient maintenant 42, 12, 14, 8, 7 ;\nLa ligne 4 renvoie la taille de F : 5 ;\nLa file n’est pas vide, on obtient dont False."
  },
  {
    "objectID": "structures/files_cours.html#du-point-de-vue-concepteur-implémentations",
    "href": "structures/files_cours.html#du-point-de-vue-concepteur-implémentations",
    "title": "Files (Cours)",
    "section": "2. Du point de vue concepteur : implémentation(s)",
    "text": "2. Du point de vue concepteur : implémentation(s)\nL’implémentation utilisant des listes Python est possible, mais l’opération defiler() est inefficace dans ce cas (on a une complexité en \\(\\mathcal{O}(n)\\)).\nNous allons tout d’abord étudier une implémentation utilisant deux piles.\n\nImplémentation utilisant deux piles\nComme le programme le suggère, il est possible d’implanter une file en utilisant deux piles. Le procédé est le suivant :\n\nla file est, au départ, composée de deux piles vides ;\nla première pile est une pile dite « d’entrée » et la seconde « de sortie » ;\nquand on ajoute un élément dans la file, on le place dans la pile « d’entrée » ;\nQuand on retire (ou qu’on accède) au premier élément de la file, on a deux cas :\n\nsoit la pile « de sortie » est vide et on dépile chaque élément de la pile « d’entrée » pour les empiler immédiatement dans la pile « de sortie » ;\nsoit il y a au moins un élément dans la pile « de sortie », auquel cas on ne fait rien de plus.\nEnfin, on sélectionne le sommet de la pile « de sortie » ;\n\ncomme il y a deux piles, la taille de la file (et le fait qu’elle soit vide ou non) doit se baser sur les éléments contenus dans les deux piles.\n\n\n\n\n\n\nDans notre implémentation, on propose de matérialiser la file sous la forme d’un tuple contenant deux piles, crées (et manipulées) avec les méthodes du module modélisant le type abstrait de données pile en utilisant les listes Python, définit plus tôt dans la section sur les piles. Ce module, nommé piles.py sera importé dans le présent fichier. On introduit également une nouvelle méthode « transferer » qui sert à effectuer le transfert entre les piles (si nécessaire) avant de retirer ou de récupérer le premier élément de la file.\nimport piles\n\n\"\"\"Implémentation du type abstrait \"file\" avec deux piles\"\"\"\n\n\ndef creer_file():\n    \"\"\"Retourne une file vide\"\"\"\n    pile_in = piles.creer()\n    pile_out = piles.creer()\n    return (pile_in, pile_out)\n\n\ndef taille_file(file):\n    \"\"\"Retourne le nombre d'éléments dans la file\"\"\"\n    return piles.taille(file[0]) + piles.taille(file[1])\n\n\ndef est_vide_file(file):\n    \"\"\"Retourne True si la file est vide, False sinon\"\"\"\n    return piles.est_vide(file[0]) and piles.est_vide(file[1])\n\n\ndef enfiler(file, element):\n    \"\"\"Ajoute un nouvel élément à l'arrière de la file\"\"\"\n    piles.empiler(file[0], element)\n\n\ndef transferer(file):\n    \"\"\"Transfère les éléments de la pile d'entrée vers la pile de sortie\"\"\"\n    while piles.taille(file[0]) != 0:\n        item = piles.depiler(file[0])\n        piles.empiler(file[1], item)\n\n\ndef defiler(file):\n    \"\"\"Retourne l'élément situé en tête de la file et le supprime de la file\"\"\"\n    if taille_file(file) == 0:\n        return None\n    else:\n        if piles.sommet(file[1]) is None:\n            transferer(file)\n        return file[1].pop()\n\n\ndef tete_file(file):\n    \"\"\"Retourne l'élément situé en tête de la file\"\"\"\n    if taille_file(file) == 0:\n        return None\n    else:\n        if piles.sommet(file[1]) is None:\n            transferer(file)\n        return piles.sommet(file[1])\nCette implémentation sera testée en exercices.\n\n\nImplémentation utilisant la POO\nOn reprend l’idée du chaînon, mais cette fois-ci, un chaînon est lié à son élément précédent dans la file, et non à son élément suivant : en effet, quand un élément sort de la file, c’est le précédent qui prend la tête.\n\"\"\"\"Implémentation du type abstrait file en POO\"\"\"\n\n\nclass Chainon:\n    def __init__(self, element=None, precedent=None):\n        \"\"\"element est la valeur du chainon et precedent est le chainon qui suit\"\"\"\n        self.element = element\n        self.precedent = precedent\n\n\nclass File():\n    def __init__(self):\n        self.front = None\n        self.back = None\n\n    def taille(self) -&gt; int:\n        \"\"\"Retourne le nombre d'éléments dans la file\"\"\"\n        long = 0\n        chainon = self.front\n        while chainon is not None:\n            chainon = chainon.precedent\n            long = long + 1\n        return long\n\n    def est_vide(self) -&gt; bool:\n        \"\"\"Retourne True si la file est vide et False sinon\"\"\"\n        return self.front is None\n\n    def enfiler(self, element):\n        \"\"\"Ajoute un nouvel élément à l'arrière de la file\"\"\"\n        new_back = Chainon(element, None)   # Création d'un nouveau chaînon\n        if self.taille() == 0:\n            # dans ce cas la file est vide et la tête est la queue\n            self.front = new_back\n        else:\n            self.back.precedent = new_back    # On relie l'ancien dernier élément au nouveau\n        self.back = new_back    # On définit le nouveau dernier élément\n\n    def defiler(self):\n        \"\"\"Retourne l'élément situé en tête de la file et le supprime de la file\"\"\"\n        item = self.front.element\n        self.front = self.front.precedent\n        return item\n\n    def tete(self):\n        \"\"\"Retourne l'élément situé en tête de la file\"\"\"\n        return self.front.element\n\n    def __str__(self):\n        chainon = self.front\n        res = str(chainon.element)\n        while chainon.precedent is not None:\n            res = \" &lt;-- \" + res\n            chainon = chainon.precedent\n            res = str(chainon.element) + res\n        return res\nLa méthode enfiler demande un peu d’attention et doit être bien comprise.\nExemple d’utilisation de cette interface en console :\n&gt;&gt;&gt; a = File()\n&gt;&gt;&gt; a.taille()\n0\n&gt;&gt;&gt; a.est_vide()\nTrue\n&gt;&gt;&gt; for k in range(5):\n        a.enfiler(10*k)\n&gt;&gt;&gt; a.est_vide()\nFalse\n&gt;&gt;&gt; a.taille()\n5\n&gt;&gt;&gt; print(a)\n40 &lt;-- 30 &lt;-- 20 &lt;-- 10 &lt;-- 0\n&gt;&gt;&gt; a.tete()\n0\n&gt;&gt;&gt; a.defiler()\n0\n&gt;&gt;&gt; a.defiler()\n10\n&gt;&gt;&gt; a.taille()\n3\n\n\n\n\n\n\nRemarque (extrait de la documentation Python)\n\n\n\nIl est également possible d’utiliser une liste comme une file, où le premier élément ajouté est le premier récupéré (« premier entré, premier sorti » ou FIFO pour first-in, first-out) ; toutefois, les listes ne sont pas très efficaces pour réaliser ce type de traitement. Alors que les ajouts et suppressions en fin de liste sont rapides, les insertions ou les retraits en début de liste sont lents (car tous les autres éléments doivent être décalés d’une position).\nPour implémenter une file, utilisez plutôt la classe collections.deque qui a été conçue spécialement pour réaliser rapidement les opérations d’ajout et de retrait aux deux extrémités. Par exemple :\n&gt;&gt;&gt; from collections import deque\n&gt;&gt;&gt; queue = deque([\"Eric\", \"John\", \"Michael\"])\n&gt;&gt;&gt; queue.append(\"Terry\")           # Terry arrives\n&gt;&gt;&gt; queue.append(\"Graham\")          # Graham arrives\n&gt;&gt;&gt; queue.popleft()                 # The first to arrive now leaves\n'Eric'\n&gt;&gt;&gt; queue.popleft()                 # The second to arrive now leaves\n'John'\n&gt;&gt;&gt; queue                           # Remaining queue in order of arrival\ndeque(['Michael', 'Terry', 'Graham'])"
  },
  {
    "objectID": "structures/index.html",
    "href": "structures/index.html",
    "title": "Programme",
    "section": "",
    "text": "Points du programme traités dans cette séquence :\n\n\n\n\n\n\n\n\nContenus\nCapacités attendues\nCommentaires\n\n\n\n\nStructures de données, interface et implémentation.\nSpécifier une structure de données par son interface. Distinguer interface et implémentation. Écrire plusieurs implémentations d’une même structure de données.\nL’abstraction des structures de données est introduite après plusieurs implémentations d’une structure simple comme la file (avec un tableau ou avec deux piles)\n\n\nListes, piles, files : structures linéaires. Dictionnaires, index et clé.\nDistinguer des structures par le jeu des méthodes qui les caractérisent. Choisir une structure de données adaptée à la situation à modéliser. Distinguer la recherche d’une valeur dans une liste et dans un dictionnaire.\nOn distingue les modes FIFO (first in first out) et LIFO (last in first out) des piles et des files."
  },
  {
    "objectID": "structures/interface/index.html",
    "href": "structures/interface/index.html",
    "title": "Interface et implémentation",
    "section": "",
    "text": "Nous allons dans ce chapitre nous intéresser aux structures de données comme les listes, les piles, les files et les dictionnaires.\nLes dictionnaires ont déjà été rencontrés en première. Plus précisément, c’est l’implémentation du type abstrait “dictionnaire” en Python qui a été utilisée.\nToutes ces structures de données sont des types abstraits qui doivent être définis dans un langage de programmation pour pouvoir être utilisés.\n\n\n\n\n\n\nDéfinition\n\n\n\nImplémenter un algorithme, c’est le traduire dans un langage de programmation.\n\n\nPour un type abstrait donné, disons les dictionnaires, plusieurs implémentations sont possibles. Elles peuvent se différencier par leur rapidité d’exécution ou leur capacité à travailler avec des données de grande taille par exemple.\nUne fois implémenté, le type abstrait doit pouvoir être utilisé par un programmeur (utilisateur). Cet utilisateur n’a pas besoin de connaître comment le type “dictionnaire” a été concrètement implémenté dans le langage de programmation qu’il utilise. Par contre, il faut qu’il connaisse précisément les actions qu’i peut réaliser sur ce type de données.\nPar exemple, un dictionnaire associe à un ensemble de clés un ensemble de valeurs (ce sont les données) et permet notamment les opérations :\n\nd’ajout d’un couple clé-valeur ;\nde suppression d’une clé, et donc de la valeur correspondante ;\nde modification de la valeur associée à une clé et ;\nde recherche de la valeur correspondant à une clé.\n\nL’ensemble des fonctions (méthodes) associées à un type abstrait constitue son interface. Ces fonctions, et leurs spécifications, permettent à l’utilisateur d’utiliser le type abstrait dans son programme.\nQuand on utilise une bibliothèque contenant l’implémentation de structures de données, l’ensemble de ces spécifications est nommée API (Application Programming Interface, Interface de Programmation en français).\n\n\n\n\n\n\nDéfinition (d’après Wikipedia)\n\n\n\nEn informatique, une interface de programmation (souvent désignée par le terme API pour Application Programming Interface) est un ensemble normalisé de classes, de méthodes, de fonctions et de constantes qui sert de façade par laquelle un logiciel offre des services à d’autres logiciels. Elle est offerte par une bibliothèque logicielle ou un service web, le plus souvent accompagnée d’une description qui spécifie comment des programmes consommateurs peuvent se servir des fonctionnalités du programme fournisseur.\n\n\nL’usage des bibliothèques permet à chaque programmeur d’ajouter des structures réalisant des types abstraits de données, cette implémentation n’étant pas nécessairement connue de l’utilisateur de la structure. Cette méthode de conception logicielle, utilisant l’encapsulation, permet à la fois :\n\nle développement séparé de l’application et de l’implémentation de la structure ;\nla modification de l’implémentation sans modification de ses utilisations (on préserve l’interface) ;\nl’utilisation facile de l’implémentation de la structure dans des programmes à venir ;\nla limitation des erreurs ;\nl’ajout :\n\nde vérifications sous forme d’assertions ;\nd’outils de correction des problèmes de programmation ;\n\nune meilleure lisibilité du code de l’application.\n\nDans la suite de ce chapitre, nous allons étudier successivement les listes, les piles, les files et les dictionnaire du point de vue du concepteur (implémentation) et de l’utilisateur (interface)."
  },
  {
    "objectID": "structures/interfaces_cours.html",
    "href": "structures/interfaces_cours.html",
    "title": "Interfaces et implémentations (Cours)",
    "section": "",
    "text": "Nous allons dans ce chapitre nous intéresser aux structures de données comme les listes, les piles, les files et les dictionnaires.\nLes dictionnaires ont déjà été rencontrés en première. Plus précisément, c’est l’implémentation du type abstrait “dictionnaire” en Python qui a été utilisée.\nToutes ces structures de données sont des types abstraits qui doivent être définis dans un langage de programmation pour pouvoir être utilisés.\n\n\n\n\n\n\nDéfinition\n\n\n\nImplémenter un algorithme, c’est le traduire dans un langage de programmation.\n\n\nPour un type abstrait donné, disons les dictionnaires, plusieurs implémentations sont possibles. Elles peuvent se différencier par leur rapidité d’exécution ou leur capacité à travailler avec des données de grande taille par exemple.\nUne fois implémenté, le type abstrait doit pouvoir être utilisé par un programmeur (utilisateur). Cet utilisateur n’a pas besoin de connaître comment le type “dictionnaire” a été concrètement implémenté dans le langage de programmation qu’il utilise. Par contre, il faut qu’il connaisse précisément les actions qu’i peut réaliser sur ce type de données.\nPar exemple, un dictionnaire associe à un ensemble de clés un ensemble de valeurs (ce sont les données) et permet notamment les opérations :\n\nd’ajout d’un couple clé-valeur ;\nde suppression d’une clé, et donc de la valeur correspondante ;\nde modification de la valeur associée à une clé et ;\nde recherche de la valeur correspondant à une clé.\n\nL’ensemble des fonctions (méthodes) associées à un type abstrait constitue son interface. Ces fonctions et leurs spécifications, permettent à l’utilisateur d’utiliser le type abstrait dans son programme.\nQuand on utilise une bibliothèque contenant l’implémentation de structures de données, l’ensemble de ces spécifications est nommée API (Application Programming Interface, Interface de Programmation en français).\n\n\n\n\n\n\nDéfinition (d’après Wikipedia)\n\n\n\nEn informatique, une interface de programmation (souvent désignée par le terme API pour Application Programming Interface) est un ensemble normalisé de classes, de méthodes, de fonctions et de constantes qui sert de façade par laquelle un logiciel offre des services à d’autres logiciels. Elle est offerte par une bibliothèque logicielle ou un service web, le plus souvent accompagnée d’une description qui spécifie comment des programmes consommateurs peuvent se servir des fonctionnalités du programme fournisseur.\n\n\nL’usage des bibliothèques permet à chaque programmeur d’ajouter des structures réalisant des types abstraits de données, cette implémentation n’étant pas nécessairement connue de l’utilisateur de la structure. Cette méthode de conception logicielle, utilisant l’encapsulation, permet à la fois :\n\nle développement séparé de l’application et de l’implémentation de la structure ;\nla modification de l’implémentation sans modification de ses utilisations (on préserve l’interface) ;\nl’utilisation facile de l’implémentation de la structure dans des programmes à venir ;\nla limitation des erreurs ;\nl’ajout :\n\nde vérifications sous forme d’assertions ;\nd’outils de correction des problèmes de programmation ;\n\nune meilleure lisibilité du code de l’application.\n\nDans la suite de ce chapitre, nous allons étudier successivement les listes, les piles, les files et les dictionnaires du point de vue du concepteur (implémentation) et de l’utilisateur (interface)."
  },
  {
    "objectID": "structures/listes_cours.html",
    "href": "structures/listes_cours.html",
    "title": "Listes (Cours)",
    "section": "",
    "text": "Attention !\n\n\n\nEn Première, nous avons utilisé le type de données list de Python pour représenter des tableaux de d’éléments de même type. Le vocabulaire propre à Python peut induire en erreur et amener à penser que le type “liste” est déjà connu. La structure list de Python réalise en fait l’implémentation du type abstrait de données “tableau dynamique” et doit être laissée de côté, malgré l’utilisation du même vocabulaire.\nCela ne nous empêchera pas d’implémenter le type abstrait de données liste en utilisant des structures de type list en Python."
  },
  {
    "objectID": "structures/listes_cours.html#du-point-de-vue-utilisateur-interface",
    "href": "structures/listes_cours.html#du-point-de-vue-utilisateur-interface",
    "title": "Listes (Cours)",
    "section": "1. Du point de vue utilisateur : interface",
    "text": "1. Du point de vue utilisateur : interface\n\n\n\n\n\n\nDéfinition\n\n\n\nUne liste est une structure de données qui permet de stocker des données et d’y accéder directement.\nC’est un type abstrait de données :\n\nlinéaire : les données sont stockées dans une structure unidimensionnelle ;\nindexé : chaque donnée est associée à une valeur ;\nordonné : les données sont présentées les unes après les autres.\n\n\n\nUne liste est une collection finie de données. On appelle tête le premier élément de la liste et queue la liste privée de son premier élément. Il est seulement possible d’ajouter et de lire une donnée en tête de la liste.\nL’interface minimale permettant de définir le type abstrait de données “liste” comporte cinq fonctions, qui sont appelées primitives :\n\ncreer(), qui crée une liste vide ;\najouter(element, liste), qui ajoute un élément en tête de liste ; ces deux première primitives peuvent parfois se regrouper en une seule ;\ntete(liste), qui renvoie la valeur de l’élément en tête de liste ;\nqueue(liste), qui renvoie la liste privée de son premier élément ;\nest_vide(liste), qui renvoie vrai si la liste est vide, faux sinon.\n\nCe type abstrait de données est non mutable (il n’y a pas de primitive permettant de modifier la valeur d’un élément de la liste).\nRemarque : on peut selon les besoins ajouter d’autres fonctions permettant par exemple de renvoyer la longueur d’une liste, de rechercher un élément ou d’accéder au ième élément …\n\n\n\n\n\n\nExemple\n\n\n\nSupposons implémenté le type abstrait liste. Nous disposons d’une interface composée des cinq primitives décrites ci-dessus. On exécute le code suivant ligne par ligne :\nL = creer()\nest_vide(L)\nL1 = ajouter(12, L)\nest_vide(L1)\nL1 = ajouter(15, L1)\nL1 = ajouter(1, ajouter(11,L1))\ntete(L1)\nL2 = queue(L1)\n\nLa ligne 1 créée une liste vide L ;\nLa ligne 2 affiche True car la liste L est vide ;\nAprès exécution de la ligne 3, la liste L1 contient l’élément unique 12 ;\nLa ligne 4 affiche False car la liste L1 n’est pas vide ;\nAprès exécution de la ligne 5, la liste L1 contient les éléments 12 et 15 ;\nLa ligne 6 montre que l’on peut composer les ajouts pour ajouter en une seule fois plusieurs éléments. Après exécution de la ligne 6, la liste L1 contient les éléments 12, 15, 11 et 1 ;\nLa ligne 7 affiche 1 : c’est la tête de la liste (il s’agit du dernier élément ajouté) ;\nLa ligne 8 définit une liste L2 égale à la queue de la liste L1. L2 contient donc les éléments 12, 15 et 11."
  },
  {
    "objectID": "structures/listes_cours.html#du-point-de-vue-concepteur-implémentations",
    "href": "structures/listes_cours.html#du-point-de-vue-concepteur-implémentations",
    "title": "Listes (Cours)",
    "section": "2. Du point de vue concepteur : implémentation(s)",
    "text": "2. Du point de vue concepteur : implémentation(s)\nNous allons implémenter le type abstrait “liste” en Python de deux façons différentes.\n\nImplémentation avec des tuples\nNous allons ici utiliser des tuples et la programmation fonctionnelle (rappel : fonctions pures, pas d’affectations, pas de boucles).\n\"\"\" Implémentation du type abstrait \"liste\" avec des tuples\"\"\"\n\n\ndef creer() -&gt; tuple:\n    \"\"\"Retourne une liste vide\"\"\"\n    return ()\n\n\ndef ajouter(element: all, liste: tuple) -&gt; tuple:\n    \"\"\"Retourne la liste avec l'élément ajouté en tête de liste\"\"\"\n    return (element, liste)\n\n\ndef est_vide(liste: tuple) -&gt; bool:\n    \"\"\"Retourne True si la liste est vide et False sinon\"\"\"\n    return liste == ()\n\n\ndef tete(liste: tuple) -&gt; all:\n    \"\"\"Retourne la tête de la liste\"\"\"\n    assert not est_vide(liste), \"Erreur : liste vide\"\n    return liste[0]\n\n\ndef queue(liste: tuple) -&gt; tuple:\n    \"\"\"Retourne la queue de la liste\"\"\"\n    assert not est_vide(liste), \"Erreur : liste vide\"\n    return liste[1]\n\n\ndef longueur(liste: tuple) -&gt; int:\n    \"\"\"Retourne le nombre d'éléments de la liste\"\"\"\n    if est_vide(liste):\n        return 0\n    else:\n        return 1 + longueur(liste[1])\nAvec cette représentation une liste est toujours un tuple à deux éléments dont le premier est la tête de la liste (le dernier élément ajouté) et le deuxième est la queue (c’est donc une liste).\n\\[L=(1, (11, (15, (12, ()))))\\]\nOn remarquera que la fonction longueur est codée sans boucle, mais de façon récursive, afin de correspondre au paradigme fonctionnel.\n\n\nImplémentation en POO\nConformément au programme, on se limite à une version naïve de la POO. On pourra à titre d’exercice reprendre cette implémentation en respectant les règles plus strictes édictées dans les compléments de cours sur la POO.\nOn définit ci-dessous une liste chaînée : chaque chaînon est constitué de l’élément qui fait partie de la liste et de la référence à l’élément suivant. C’est la classe Chainon qui implémente cette structure. L’objet Liste est défini à partir de son premier élément (tête) et ses primitives sont définies sous forme de méthodes.\n\"\"\"Implémentation du type abstrait liste en POO\"\"\"\n\n\nclass Chainon:\n    def __init__(self, element=None, suivant=None):\n        \"\"\"element est la valeur du chainon et suivant est le chainon qui suit\"\"\"\n        self.element = element\n        self.suivant = suivant\n\n\nclass Liste:\n    def __init__(self):\n        \"\"\"Crée une liste vide\"\"\"\n        self.head = Chainon()\n\n    def est_vide(self) -&gt; bool:\n        \"\"\"Retourne True si la liste est vide et False sinon\"\"\"\n        return self.head.element is None\n\n    def ajouter(self, element):\n        \"\"\"Ajoute element en tête de la liste\"\"\"\n        self.head = Chainon(element, self.head)\n\n    def tete(self):\n        \"\"\"Retourne la valeur de la tête de la liste\"\"\"\n        return self.head.element\n\n    def queue(self):\n        \"\"\"Retourne la queue de la liste, c.-à-d. la liste privée de sa tête\"\"\"\n        new_liste = Liste()\n        new_liste.head = self.head.suivant\n        return new_liste\n\n    def longueur(self):\n        \"\"\"Retourne la longueur de la liste\"\"\"\n        long = 0\n        chainon = self.head\n        while chainon.element is not None:\n            chainon = chainon.suivant\n            long = long + 1\n        return long\nOn peut améliorer l’implémentation en redéfinissant les méthodes spéciales __len__ (qui permettra de taper len(L) au lieu de L.longueur()) et __str__ (qui permettra d’utiliser l’instruction print(L)).\n    def __len__(self):\n        return self.longueur()\n\n    def __str__(self):\n        rep = \"\"\n        chainon = self.head\n        while chainon.element is not None:\n            rep = rep + str(chainon.element) + \" --&gt; \"\n            chainon = chainon.suivant\n        return rep[:-4]\n&gt;&gt;&gt; L=Liste()\n&gt;&gt;&gt; L.ajouter(11)\n&gt;&gt;&gt; L.ajouter(12)\n&gt;&gt;&gt; L.ajouter(13)\n&gt;&gt;&gt; print(L)\n13 --&gt; 12 --&gt; 11"
  },
  {
    "objectID": "structures/listes_exercices.html",
    "href": "structures/listes_exercices.html",
    "title": "Listes, Piles et Files (Exercices)",
    "section": "",
    "text": "Les exercices précédés du symbole  sont à faire sur machine, en sauvegardant le fichier si nécessaire.\nLes exercices précédés du symbole  doivent être résolus par écrit."
  },
  {
    "objectID": "structures/listes_exercices.html#fa-desktop-exercice-1-listes",
    "href": "structures/listes_exercices.html#fa-desktop-exercice-1-listes",
    "title": "Listes, Piles et Files (Exercices)",
    "section": " Exercice 1 (listes)",
    "text": "Exercice 1 (listes)\nOn reprend l’implémentation des listes avec des tuples présentée dans le cours.\nPrévoir l’effet et l’affichage en console des instructions suivantes, puis vérifier en exécutant ces instructions dans la console interactive après avoir créé et importé un fichier contenant le code du cours :\n&gt;&gt;&gt; L = creer()\n&gt;&gt;&gt; est_vide(L)\n&gt;&gt;&gt; L = ajouter(5, ajouter(4, ajouter(3, ajouter(2, ajouter(1, ajouter(0,()))))))\n&gt;&gt;&gt; est_vide(L)\n&gt;&gt;&gt; longueur(L)\n&gt;&gt;&gt; L = ajouter(6,L)\n&gt;&gt;&gt; longueur(L)\n&gt;&gt;&gt; tete(L)\n&gt;&gt;&gt; queue(L)\n&gt;&gt;&gt; longueur(queue(L))"
  },
  {
    "objectID": "structures/listes_exercices.html#fa-solid-pencil-alt-exercice-2-listes",
    "href": "structures/listes_exercices.html#fa-solid-pencil-alt-exercice-2-listes",
    "title": "Listes, Piles et Files (Exercices)",
    "section": " Exercice 2 (listes)",
    "text": "Exercice 2 (listes)\nSoit la suite d’instructions suivantes :\nL = creer()\nL = ajouter(2, ajouter(15, ajouter (23, L)))\nL1 = queue(L)\na = tete(L1)\nL1 = ajouter(4, ajouter(3, L1))\nDonnez le contenu des listes L et L1 et la valeur de a."
  },
  {
    "objectID": "structures/listes_exercices.html#fa-solid-pencil-alt-exercice-3-piles",
    "href": "structures/listes_exercices.html#fa-solid-pencil-alt-exercice-3-piles",
    "title": "Listes, Piles et Files (Exercices)",
    "section": " Exercice 3 (piles)",
    "text": "Exercice 3 (piles)\nSoit une pile P initialement vide. Soit les instructions suivantes (implémentation des piles avec des listes Python) :\n&gt;&gt;&gt; empiler(P,4)\n&gt;&gt;&gt; empiler(P,7)\n&gt;&gt;&gt; a = depiler(P)\n&gt;&gt;&gt; b = taille(P)\n&gt;&gt;&gt; c = depiler(P)\n&gt;&gt;&gt; empiler(P,3)\n&gt;&gt;&gt; empiler(P,2)\n&gt;&gt;&gt; d = taille(P)\nDonnez le contenu de la pile P, la valeur de a, la valeur de b, la valeur de c et la valeur de d."
  },
  {
    "objectID": "structures/listes_exercices.html#fa-solid-pencil-alt-exercice-4-piles",
    "href": "structures/listes_exercices.html#fa-solid-pencil-alt-exercice-4-piles",
    "title": "Listes, Piles et Files (Exercices)",
    "section": " Exercice 4 (piles)",
    "text": "Exercice 4 (piles)\nSoit le programme Python suivant (on utilise l’implémentation des piles en POO) :\npile = Pile()\ntab = [5,8,6,1,3,7]\nfor k in tab:\n    pile.empiler(k)\npile.empiler(5)\npile.empiler(10)\npile.empiler(8)\npile.empiler(15)\nfor k in tab:\n    if k &gt; 5:\n        pile.depiler()\nDonnez l’état de la pile pile après l’exécution de ce programme."
  },
  {
    "objectID": "structures/listes_exercices.html#fa-solid-pencil-alt-fa-desktop-exercice-5-piles",
    "href": "structures/listes_exercices.html#fa-solid-pencil-alt-fa-desktop-exercice-5-piles",
    "title": "Listes, Piles et Files (Exercices)",
    "section": "  Exercice 5 (piles)",
    "text": "Exercice 5 (piles)\nCe problème propose une application concrète des piles. Il s’agit d’écrire une fonction qui contrôle si une expression mathématique, donnée sous forme d’une chaîne de caractères, est bien parenthésée, c’est- à-dire s’il y a autant de parenthèses ouvrantes que de fermantes, et qu’elles sont bien placées\nPar exemple :\n\n(..(..)..) est bien parenthésée\n(…(..(..)…) ne l’est pas\n\nL’algorithme :\n\nOn crée une pile\nOn parcourt l’expression de gauche à droite.\nÀ chaque fois que l’on rencontre une parenthèse ouvrante “(” on l’empile\nSi on rencontre une parenthèse fermante ” ) ” et que la pile n’est pas vide on dépile ( sinon on retourne faux )\nÀ la fin la pile doit être vide…\n\n\nEn utilisant l’une des structures pile du cours, écrire une fonction verification(expr) qui vérifie si une expression mathématique passée en paramètre est correctement parenthésée.\nProposer un jeu de tests unitaires vérifiant le bon fonctionnement de la fonction.\nFaire en sorte que le programme tienne compte également des [."
  },
  {
    "objectID": "structures/listes_exercices.html#fa-solid-pencil-alt-exercice-6-files",
    "href": "structures/listes_exercices.html#fa-solid-pencil-alt-exercice-6-files",
    "title": "Listes, Piles et Files (Exercices)",
    "section": " Exercice 6 (files)",
    "text": "Exercice 6 (files)\nSoit une file F initialement vide. Soit les instructions suivantes :\nenfiler(F,6)\nenfiler(F,3)\na = defiler(F)\nenfiler(F,9)\nb = taille_file(F)\nenfiler(F,17)\nc = defiler(F)\nenfiler(F,2)\nd = taille_file(F)\nDonnez le contenu de la file F, la valeur de a, la valeur de b, la valeur de c et la valeur de d."
  },
  {
    "objectID": "structures/listes_exercices.html#fa-solid-pencil-alt-exercice-7-files",
    "href": "structures/listes_exercices.html#fa-solid-pencil-alt-exercice-7-files",
    "title": "Listes, Piles et Files (Exercices)",
    "section": " Exercice 7 (files)",
    "text": "Exercice 7 (files)\nSoit le programme Python suivant :\nfile = File()\ntab = [2,78,6,89,3,17]\nfile.enfiler(5)\nfile.enfiler(10)\nfile.enfiler(8)\nfile.enfiler(15)\nfor i in tab:\n    if i &gt; 50:\n        file.defiler()\nDonnez l’état de la file file après l’exécution de ce programme"
  },
  {
    "objectID": "structures/listes_exercices.html#fa-solid-pencil-alt-exercices-tombés-au-bac",
    "href": "structures/listes_exercices.html#fa-solid-pencil-alt-exercices-tombés-au-bac",
    "title": "Listes, Piles et Files (Exercices)",
    "section": " Exercices tombés au bac",
    "text": "Exercices tombés au bac\n\n2021 Métropole Jour 1 : exo 2.\n2021 Centres étrangers Jour 2 : exo 1.\n2021 Centres étrangers Jour 1 : exo 5.\n2021 Amérique du Nord Jour1 : exo 5.\n2021 Sujet zéro : exo 1.\n2022 Centres étrangers Jour 1 : exo 2.\n2022 Métropole Jour 1 : exo 1.\n2022 Métropole Jour 2 : exo 2.\n2022 Mayotte Liban Jour 1 : exo 1.\n2022 Mayotte Liban Jour 2 : exo 1.\n2022 Amérique du Nord Jour 1 : exo 5."
  },
  {
    "objectID": "structures/piles_cours.html",
    "href": "structures/piles_cours.html",
    "title": "Piles (Cours)",
    "section": "",
    "text": "Définition\n\n\n\nLa pile est une structure de données qui permet de stocker des données et d’y accéder. Une pile se comporte comme une pile d’assiettes :\n\non ajoute des nouvelles assiettes au sommet de la pile ;\nquand on veut en retirer une, on est obligé de prendre celle située au sommet.\n\n\n\nOn parle de mode LIFO (Last In, First Out, en anglais, dernier arrivé, premier sorti), c’est-à-dire que le dernier élément ajouté à la structure sera le prochain élément auquel on accédera. Les premiers éléments ayant été ajoutés devront « attendre » que tous les éléments qui ont été ajoutés après eux soient sortis de la pile. Contrairement aux listes, on ne peut donc pas accéder à n’importe quelle valeur de la structure (pas d’index). Pour gérer cette contrainte, on définit le sommet de la pile qui caractérise l’emplacement pour ajouter ou retirer des éléments.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nL’interface suivante permet de définir le type abstrait de données pile :\n\ncreer(), qui crée une pile vide ;\ntaille(pile), qui permet de connaître le nombre d’éléments contenus dans la pile ;\nest_vide(pile), qui renvoie vrai si la pile est vide, faux sinon ;\nempiler(pile, element), qui ajoute un élément au sommet de la pile (qui devient le nouveau sommet) ;\ndepiler(pile), qui retire et renvoie l’élément situé au sommet de la pile (le nouveau sommet devient l’élément qui suivait l’ancien sommet) ;\nsommet(pile), qui renvoie l’élément situé au sommet de la pile (sans le retirer).\n\nL’opération d’empilement se dit “push” en anglais, l’opération de dépilement se dit “pop”.\n\n\n\n\n\n\nLa pile est utile dans différents types de problèmes\n\n\n\n\nalgorithme d’un navigateur pour pouvoir mémoriser les pages web et revenir en arrière (ou ré-avancer) sur certaines pages ;\nstocker des actions et les annuler (ou les réappliquer), sur l’ordinateur (fonction CTRL+Z, et CTRL+Y) ;\ncoder une calculatrice en notation polonaise inversée (voir exercices) ;\nalgorithme du parcours en profondeur pour les arbres et les graphes, par exemple, pour résoudre un labyrinthe, trouver un trajet sur une carte… (voir séquence 6) ;\nécrire des versions itératives de certains algorithmes récursifs (voir séquence 1) ;\nillustration du fonctionnement de la pile d’appels des fonctions lors de l’exécution d’un programme.\n\n\n\n\n\n\n\n\n\nExemple\n\n\n\nSupposons implémenté le type abstrait pile. Nous disposons d’une interface composée des six primitives décrites ci-dessus. On considère une pile P composée des éléments suivants : 12, 14, 8, 7, 19 et 22 (le sommet de la pile est 22). On exécute le code suivant ligne par ligne :\n    depiler(P)\n    empiler(P,42)\n    depiler(P)\n    taille(P)\n    estVide(P)\n\nL’exécution de la ligne 1 renvoie la valeur 22 et la pile est maintenant composée des éléments 12, 14, 8, 7 et 19 ;\nL’exécution de la ligne 2 place l’élément 42 au sommet de la pile ;\nL’exécution de la ligne 3 renvoie la valeur 42 et la pile est maintenant à nouveau composée des éléments 12, 14, 8, 7 et 19 ;\nLa ligne 4 renvoie la taille de P : 5 ;\nLa pile n’est pas vide, on obtient dont False."
  },
  {
    "objectID": "structures/piles_cours.html#du-point-de-vue-utilisateur-interface",
    "href": "structures/piles_cours.html#du-point-de-vue-utilisateur-interface",
    "title": "Piles (Cours)",
    "section": "",
    "text": "Définition\n\n\n\nLa pile est une structure de données qui permet de stocker des données et d’y accéder. Une pile se comporte comme une pile d’assiettes :\n\non ajoute des nouvelles assiettes au sommet de la pile ;\nquand on veut en retirer une, on est obligé de prendre celle située au sommet.\n\n\n\nOn parle de mode LIFO (Last In, First Out, en anglais, dernier arrivé, premier sorti), c’est-à-dire que le dernier élément ajouté à la structure sera le prochain élément auquel on accédera. Les premiers éléments ayant été ajoutés devront « attendre » que tous les éléments qui ont été ajoutés après eux soient sortis de la pile. Contrairement aux listes, on ne peut donc pas accéder à n’importe quelle valeur de la structure (pas d’index). Pour gérer cette contrainte, on définit le sommet de la pile qui caractérise l’emplacement pour ajouter ou retirer des éléments.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nL’interface suivante permet de définir le type abstrait de données pile :\n\ncreer(), qui crée une pile vide ;\ntaille(pile), qui permet de connaître le nombre d’éléments contenus dans la pile ;\nest_vide(pile), qui renvoie vrai si la pile est vide, faux sinon ;\nempiler(pile, element), qui ajoute un élément au sommet de la pile (qui devient le nouveau sommet) ;\ndepiler(pile), qui retire et renvoie l’élément situé au sommet de la pile (le nouveau sommet devient l’élément qui suivait l’ancien sommet) ;\nsommet(pile), qui renvoie l’élément situé au sommet de la pile (sans le retirer).\n\nL’opération d’empilement se dit “push” en anglais, l’opération de dépilement se dit “pop”.\n\n\n\n\n\n\nLa pile est utile dans différents types de problèmes\n\n\n\n\nalgorithme d’un navigateur pour pouvoir mémoriser les pages web et revenir en arrière (ou ré-avancer) sur certaines pages ;\nstocker des actions et les annuler (ou les réappliquer), sur l’ordinateur (fonction CTRL+Z, et CTRL+Y) ;\ncoder une calculatrice en notation polonaise inversée (voir exercices) ;\nalgorithme du parcours en profondeur pour les arbres et les graphes, par exemple, pour résoudre un labyrinthe, trouver un trajet sur une carte… (voir séquence 6) ;\nécrire des versions itératives de certains algorithmes récursifs (voir séquence 1) ;\nillustration du fonctionnement de la pile d’appels des fonctions lors de l’exécution d’un programme.\n\n\n\n\n\n\n\n\n\nExemple\n\n\n\nSupposons implémenté le type abstrait pile. Nous disposons d’une interface composée des six primitives décrites ci-dessus. On considère une pile P composée des éléments suivants : 12, 14, 8, 7, 19 et 22 (le sommet de la pile est 22). On exécute le code suivant ligne par ligne :\n    depiler(P)\n    empiler(P,42)\n    depiler(P)\n    taille(P)\n    estVide(P)\n\nL’exécution de la ligne 1 renvoie la valeur 22 et la pile est maintenant composée des éléments 12, 14, 8, 7 et 19 ;\nL’exécution de la ligne 2 place l’élément 42 au sommet de la pile ;\nL’exécution de la ligne 3 renvoie la valeur 42 et la pile est maintenant à nouveau composée des éléments 12, 14, 8, 7 et 19 ;\nLa ligne 4 renvoie la taille de P : 5 ;\nLa pile n’est pas vide, on obtient dont False."
  },
  {
    "objectID": "structures/piles_cours.html#du-point-de-vue-concepteur-implémentations",
    "href": "structures/piles_cours.html#du-point-de-vue-concepteur-implémentations",
    "title": "Piles (Cours)",
    "section": "2. Du point de vue concepteur : implémentation(s)",
    "text": "2. Du point de vue concepteur : implémentation(s)\n\nImplémentation avec listes Python\nPremière solution, on peut implémenter une pile en utilisant des listes Python. Cette solution est très facile, car les méthodes append et pop des objets de type list correspondent exactement aux primitives empiler et dépiler de la structure pile.\n\"\"\"Implémentation des piles avec des listes Python\"\"\"\n\n\ndef creer():\n    \"\"\"Retourne une pile vide\"\"\"\n    return []\n\n\ndef taille(pile):\n    \"\"\"Retourne le nombre d'éléments de la pile\"\"\"\n    return len(pile)\n\n\ndef est_vide(pile):\n    \"\"\"Retourne True si la pile est vide, False sinon\"\"\"\n    return pile == []\n\n\ndef empiler(pile, element):\n    \"\"\"Empile un nouvel élément au sommet de la pile\"\"\"\n    pile.append(element)\n\n\ndef depiler(pile):\n    \"\"\"Retourne l'élément situé au sommet de la pile\n    et le supprime de celle-ci\"\"\"\n    if not est_vide(pile):\n        return pile.pop()\n    else:\n        return None\n\n\ndef sommet(pile):\n    \"\"\"Retourne l'élément situé au sommet de la pile\"\"\"\n    if not est_vide(pile):\n        return pile[-1]\n    else:\n        return None\nCette implémentation sera testée en exercices.\n\n\nImplémentation en POO\nConformément au programme, on se limite à une version naïve de la POO. On pourra à titre d’exercice reprendre cette implémentation en respectant les règles plus strictes édictées dans les compléments de cours sur la POO.\nOn reprend l’idée de chaînon utilisée pour les listes.\n\"\"\"Implémentation du type abstrait pile en POO\"\"\"\n\n\nclass Chainon:\n    def __init__(self, element=None, suivant=None):\n        \"\"\"element est la valeur du chainon et suivant est le chainon qui suit\"\"\"\n        self.element = element\n        self.suivant = suivant\n\n\nclass Pile:\n    def __init__(self):\n        \"\"\"Crée une pile vide\"\"\"\n        self.summit = Chainon()\n\n    def taille(self):\n        \"\"\"Retourne le nombre d'éléments dans la pile\"\"\"\n        long = 0\n        chainon = self.summit\n        while chainon.element is not None:\n            chainon = chainon.suivant\n            long = long + 1\n        return long\n\n    def est_vide(self) -&gt; bool:\n        \"\"\"Retourne True si la pile est vide et False sinon\"\"\"\n        return self.summit.element is None\n\n    def empiler(self, element):\n        \"\"\"Empile element qu sommet de la pile\"\"\"\n        self.summit = Chainon(element, self.summit)\n\n    def depiler(self):\n        \"\"\"Retourne l'élément situé au sommet de la pile\n        et le supprime de celle-ci\"\"\"\n        item = self.summit.element\n        self.summit = self.summit.suivant\n        return item\n\n    def sommet(self):\n        \"\"\"Retourne la valeur du sommet de la pile\"\"\"\n        return self.summit.element\n\nCette implémentation sera testée en exercices.\n\n\n\n\n\n\nComparaison des deux implémentations\n\n\n\nOn peut comparer en termes de temps d’exécution l’efficacité de ces deux implémentations.\nOn utilise pour cela la bibliothèque timeit présentée dans cet article.\nPour cela, on ajoute les lignes suivantes au code de la version “listes Python” :\nimport timeit\n\nma_pile = creer()\nprint(timeit.timeit('empiler(ma_pile,1)', number=10000000, globals=globals()))\non obtient :\n2.2605971000011778\net les lignes suivantes au code de la version “POO” :\nimport timeit\n\nma_pile = Pile()\nprint(timeit.timeit('ma_pile.empiler(1)', number=10000000, globals=globals()))\non obtient :\n7.292327400005888\nOn constate donc que la version utilisant les listes Python est beaucoup plus efficace. Cela s’explique notamment par le fait que l’implantation avec les listes Python repose sur une programmation avancée et optimisée, contrairement à l’implantation objet qui a été construite sans utiliser de structure externe.\nNéanmoins, on peut montrer que, dans les deux implémentations, les opérations d’empilement et de dépilement sont en \\(\\mathcal{O}(1)\\), ce qui signifie que le temps d’exécution ne dépend pas du nombre de données.\nL’utilisation des listes est la plus efficace. Néanmoins, l’implantation objet a pour avantage de montrer et d’assimiler le fonctionnement interne de cette structure. C’est donc un meilleur outil d’apprentissage des concepts."
  },
  {
    "objectID": "structures/projet_detecteur_langue.html",
    "href": "structures/projet_detecteur_langue.html",
    "title": "Projet - Détecteur de langue",
    "section": "",
    "text": "Tour de Babel\n\n\nL’objectif final de ce projet est de produire un programme qui détecte dans quelle langue un texte est écrit, en s’appuyant sur une analyse fréquentielle des lettres du texte.\nIl s’agit d’un projet : les consignes sont donc volontairement très limitées et seul le résultat attendu est détaillé (cahier des charges). Il vous revient d’organiser votre travail comme vous le voulez : création de fichiers, de bibliothèques, recherches documentaires.\nVous pouvez exercer votre liberté et choisir le style de programmation qui vous plait : impératif, POO, modulaire …\nDes compléments facultatifs sont proposés pour les plus rapides.\n\n\nCréer un programme qui :\n\nlit un fichier texte (encodé en UTF-8) ;\ncrée un dictionnaire dont les clés sont les lettres de l’alphabet de “a” à “z” ;\nanalyse le contenu du fichier caractère par caractère et remplit le dictionnaire avec comme valeur le nombre d’apparitions de chacune des lettres dans le texte. Les lettres autres que les lettres “a” à “z” sont ignorées ;\ncrée un nouveau dictionnaire avec les mêmes clés, mais en valeurs les fréquences d’apparition de chaque lettre ;\naffiche un diagramme en barres de cette répartition de fréquences à l’aide de la librairie MatPlotLib.\n\nRemarques :\n\nil peut être judicieux de décomposer le programme en plusieurs fonctions ;\nvous rechercherez dans la documentation les exemples d’utilisation de MatPlotLib ;\nvoici un fichier texte pour tester votre programme : texte.\n\n\n\n\nLa fréquence d’apparition des lettres dans les différentes langues qui utilisent l’alphabet latin est différente. C’est pour cette raison que les points attribués aux différentes lettres ainsi que le nombre de ces lettres dans le jeu du Scrabble ne sont pas les mêmes dans tous les pays.\nLe tableau disponible sur Wikipédia à cette adresse : -Wikipédia- donne cette fréquence dans les langues les plus courantes.\nNous allons choisir comme signature d’une langue la liste des dix lettres les plus utilisées dans cette langue, de la plus utilisée à la moins utilisée.\nCréer un dictionnaire signature dont les clés sont le nom des langues sous forme de chaîne de caractères et les valeurs sont ces listes de dix lettres.\nPar exemple, l’appel signature[\"Français\"][0] retournera \"e\".\nOn se limitera aux langues suivantes : Français, Anglais, Allemand, Espagnol, Italien, Portugais, Espéranto, Polonais et Néerlandais.\n\n\n\nÀ partir du programme réalisé à l’étape 1, programmer une fonction qui, pour un fichier texte donné, crée une liste signature_texte avec pour éléments les dix lettres les plus utilisées dans ce texte, de la plus utilisée à la moins utilisée.\nÉcrire une fonction detecte_langue(texte) qui, à partir des éléments précédents, retourne le nom de la langue dans laquelle le texte donné en paramètre est le plus probablement écrit. Il vous faudra notamment choisir un moyen de comparer la liste signature_texte avec l’ensemble des listes du dictionnaire signature afin de trouver cette qui est la plus “proche”.\nPour tester votre programme, voici des fichiers texte dans les différentes langues concernées : textes (fichier .zip à décompresser).\nProposer des améliorations possibles.\n\n\n\nProgrammer une fonction detecte_langue(url) qui prend en argument l’adresse d’une page web et qui retourne le nom de la langue dans laquelle la page est le plus probablement écrite. Vous pourrez utiliser la bibliothèque Python BeautifulSoup qui permet d’extraire le texte présent dans les balises HTML d’une page web (voir la documentation)."
  },
  {
    "objectID": "structures/projet_detecteur_langue.html#étape-1",
    "href": "structures/projet_detecteur_langue.html#étape-1",
    "title": "Projet - Détecteur de langue",
    "section": "",
    "text": "Créer un programme qui :\n\nlit un fichier texte (encodé en UTF-8) ;\ncrée un dictionnaire dont les clés sont les lettres de l’alphabet de “a” à “z” ;\nanalyse le contenu du fichier caractère par caractère et remplit le dictionnaire avec comme valeur le nombre d’apparitions de chacune des lettres dans le texte. Les lettres autres que les lettres “a” à “z” sont ignorées ;\ncrée un nouveau dictionnaire avec les mêmes clés, mais en valeurs les fréquences d’apparition de chaque lettre ;\naffiche un diagramme en barres de cette répartition de fréquences à l’aide de la librairie MatPlotLib.\n\nRemarques :\n\nil peut être judicieux de décomposer le programme en plusieurs fonctions ;\nvous rechercherez dans la documentation les exemples d’utilisation de MatPlotLib ;\nvoici un fichier texte pour tester votre programme : texte."
  },
  {
    "objectID": "structures/projet_detecteur_langue.html#étape-2",
    "href": "structures/projet_detecteur_langue.html#étape-2",
    "title": "Projet - Détecteur de langue",
    "section": "",
    "text": "La fréquence d’apparition des lettres dans les différentes langues qui utilisent l’alphabet latin est différente. C’est pour cette raison que les points attribués aux différentes lettres ainsi que le nombre de ces lettres dans le jeu du Scrabble ne sont pas les mêmes dans tous les pays.\nLe tableau disponible sur Wikipédia à cette adresse : -Wikipédia- donne cette fréquence dans les langues les plus courantes.\nNous allons choisir comme signature d’une langue la liste des dix lettres les plus utilisées dans cette langue, de la plus utilisée à la moins utilisée.\nCréer un dictionnaire signature dont les clés sont le nom des langues sous forme de chaîne de caractères et les valeurs sont ces listes de dix lettres.\nPar exemple, l’appel signature[\"Français\"][0] retournera \"e\".\nOn se limitera aux langues suivantes : Français, Anglais, Allemand, Espagnol, Italien, Portugais, Espéranto, Polonais et Néerlandais."
  },
  {
    "objectID": "structures/projet_detecteur_langue.html#étape-3",
    "href": "structures/projet_detecteur_langue.html#étape-3",
    "title": "Projet - Détecteur de langue",
    "section": "",
    "text": "À partir du programme réalisé à l’étape 1, programmer une fonction qui, pour un fichier texte donné, crée une liste signature_texte avec pour éléments les dix lettres les plus utilisées dans ce texte, de la plus utilisée à la moins utilisée.\nÉcrire une fonction detecte_langue(texte) qui, à partir des éléments précédents, retourne le nom de la langue dans laquelle le texte donné en paramètre est le plus probablement écrit. Il vous faudra notamment choisir un moyen de comparer la liste signature_texte avec l’ensemble des listes du dictionnaire signature afin de trouver cette qui est la plus “proche”.\nPour tester votre programme, voici des fichiers texte dans les différentes langues concernées : textes (fichier .zip à décompresser).\nProposer des améliorations possibles."
  },
  {
    "objectID": "structures/projet_detecteur_langue.html#complément-facultatif",
    "href": "structures/projet_detecteur_langue.html#complément-facultatif",
    "title": "Projet - Détecteur de langue",
    "section": "",
    "text": "Programmer une fonction detecte_langue(url) qui prend en argument l’adresse d’une page web et qui retourne le nom de la langue dans laquelle la page est le plus probablement écrite. Vous pourrez utiliser la bibliothèque Python BeautifulSoup qui permet d’extraire le texte présent dans les balises HTML d’une page web (voir la documentation)."
  },
  {
    "objectID": "structures/TPDictionnaire.html",
    "href": "structures/TPDictionnaire.html",
    "title": "Dictionnaires (TP)",
    "section": "",
    "text": "T.P. Dictionnaires\nCe T. P. prend la forme d’un notebook Jupyter à compléter.\nTélécharger la notebook en cliquant sur le bouton ci-dessous et l’ouvrir dans Edupython pour le compléter.\nNotebook"
  },
  {
    "objectID": "structures/TPDictionnaires.html",
    "href": "structures/TPDictionnaires.html",
    "title": "T.P. Dictionnaires",
    "section": "",
    "text": "NSI Terminale"
  },
  {
    "objectID": "structures/TPDictionnaires.html#rappels-sur-les-dictionnaires",
    "href": "structures/TPDictionnaires.html#rappels-sur-les-dictionnaires",
    "title": "T.P. Dictionnaires",
    "section": "Rappels sur les dictionnaires",
    "text": "Rappels sur les dictionnaires\nDans cette partie, nous allons fabriquer un carnet d’adresse pour stocker des contacts.\n\nFabrication d’un contact\nChaque contact sera un dictionnaire dont les clés seront : - nom : Nom et prénom du contact - tel : N° de téléphone - rue : adresse complète - code : code postal - ville : ville\nCréez un dictionnaire nommé contact correspondant au contact suivant : &gt; Margaret Costa-Royer &gt; 08 06 18 37 28 &gt; 93, avenue Bruneau &gt; 13749 Perrot\n\n# YOUR CODE HERE\n\n\n# Vérification\nassert contact[\"nom\"] == \"Margaret Costa-Royer\"\nassert contact[\"tel\"] == \"08 06 18 37 28\"\nassert contact[\"ville\"] == \"Perrot\"\n\nAjouter une nouvelle entrée “passwd” dans le contact ayant pour valeur ‘s75JWikE&o’\n\n# YOUR CODE HERE\n\n\n# Vérification\nassert contact[\"passwd\"] == 's75JWikE&o'\n\n\n\nGénération automatique d’un contact\nÉcrire une fonction genere_contact() - qui ne prend aucun paramètre - qui renvoie un dictionnaire possédant les mêmes clés que le contact ci-dessus, y compris “passwd”\nOn pourra utiliser le module faker de python dont un exemple d’utilisation est donné dans la cellule ci-dessous.\n\n%pip install faker\n\n\nfrom faker import Faker\n\nfake = Faker(\"fr_FR\") # Générateur de données personnelles pour un français\n\nprint(fake.name())\nprint(fake.phone_number())\nprint(fake.street_address())\nprint(fake.postcode(), fake.city())\nprint(fake.password())\n\nRemarque : Si la cellule ci-dessus provoque une erreur disant que le module faker n’est pas disponible, vous pouvez l’installer dans l’environnement jupyter via la commande\n!pip install faker\n\ndef genere_contact():\n    \"\"\"Fabrique un contact factice et renvoie le contact sous forme d'un dictionnaire\"\"\"\n    # YOUR CODE HERE\n    \n\n\ncontact1 = genere_contact()\nassert type(contact1[\"nom\"]) == str\nassert \"ville\" in contact1"
  },
  {
    "objectID": "structures/TPDictionnaires.html#mise-en-pratique",
    "href": "structures/TPDictionnaires.html#mise-en-pratique",
    "title": "T.P. Dictionnaires",
    "section": "Mise en pratique",
    "text": "Mise en pratique\n\nFabrication du carnet d’adresse\nTout est à présent en place pour que nous puissions fabriquer notre carnet d’adresse.\n\nPremière implémentation\nDans une première approche, nous allons considérer que le carnet d’adresse sera une liste de contacts, chaque contact étant un dictionnaire dont la structure a été définie à la section précédente.\nFabriquez une fonction genere_carnet1 - prenant en paramètre le nombre n de contacts à générer - renvoyant une liste de n contacts générés aléatoirement.\n\ndef genere_carnet1(n):\n    \"\"\"Renvoie une liste de n contacts aléatoires\"\"\"\n    # YOUR CODE HERE\n    \n\n\n# vérification\n\ncarnet1 = genere_carnet1(10)\nassert type(carnet1) == list\nassert \"nom\" in carnet1[3]\n\nEcrire à présent une fonction est_present - prenant 2 paramètres : un nom et un carnet d’adresse - renvoyant True si le nom figure dans le carnet d’adresse, False sinon\n\ndef est_present(nom, carnet):\n    \"\"\"Teste si nom est présent dans le carnet d'adresse\"\"\"\n    # YOUR CODE HERE\n    \n\n\n# Vérification\n\ncarnet1 = genere_carnet1(10)\nnom = carnet1[-1][\"nom\"]\nassert est_present(nom, carnet1)\nassert not est_present(\"Géo Trouvetout\", carnet1)\n\n\n\nMesure de performance de la recherche\nNous allons regarder ici comment évolue la vitesse de recherche en fonction de la taille du carnet d’adresse. On utilisera pour cela la fonction magique de jupyter : %%timeit. Étudiez la cellule suivante :\n\n# Fabrication d'un carnet de 100 contacts\ncarnet1 = genere_carnet1(100)\nnom = carnet1[-1][\"nom\"]  # On récupère un nom du carnet\nnom\n\n\n%%timeit\n\n# On mesure le temps d'une recherche\nest_present(nom, carnet1) \n\nVous lisez sous la cellule le temps de recherche.\nA présent, on refait l’expérience pour 1000 contacts dans le carnet d’adresse.\n\ncarnet1 = genere_carnet1(1000)\nnom = carnet1[-1][\"nom\"]  # On récupère un nom du carnet\nnom\n\n\n%%timeit\n\n# On mesure le temps d'une recherche dans ce carnet\nest_present(nom, carnet1)\n\n\n\nSeconde implémentation\nVous devez avoir constaté ci-dessus que le temps de recherche est proportionnel à la taille du carnet d’adresse : si celui-ci contient 10 fois plus de contact, la recherche peut être jusqu’à 10 fois plus longue.\nNous allons changer d’approche et fabriquer un carnet d’adresse sous forme d’un dictionnaire dont les clés seront les noms et les valeurs seront les fiches contacts. Ainsi notre carnet d’adresse sera un dictionnaire dont les valeurs seront des dictionnaires !\nFabriquez une fonction genere_carnet2 - prenant en paramètre le nombre n de contacts à générer - renvoyant un dictionnaire de n contacts générés aléatoirement\n\ndef genere_carnet2(n):\n    \"\"\"Renvoie un dictionnaire de n contacts aléatoires\"\"\"\n    # YOUR CODE HERE\n    \n\n\n# Vérification\n\ncarnet2 = genere_carnet2(10)\nassert type(carnet2) == dict\nnom = list(carnet2.keys())[-1]\nassert type(carnet2[nom]) == dict\n\n\n\nMesure de performance de la recherche\nNous allons regarder pour cette nouvelle implémentation comment évolue la vitesse de recherche en fonction de la taille du carnet d’adresse. Validez les 2 cellules suivantes.\n\n# Fabrication d'un carnet de 100 contacts\ncarnet2 = genere_carnet2(100)\nnom = list(carnet2.keys())[-1] # On récupère un nom du carnet\nnom\n\n\n%%timeit\n\nnom in carnet2                 # On le recherche\n\nOn constate déjà que la recherche est plus rapide que pour la première implémentation du carnet à l’aide d’un tableau.\nRefaisons l’expérience avec 100 fois plus de contacts dans le carnet !!\n\n# Fabrication d'un carnet de 10000 contacts\ncarnet2 = genere_carnet2(10000)\nnom = list(carnet2.keys())[-1] # On récupère un nom du carnet\nnom\n\n\n%%timeit\n\nnom in carnet2           # On le recherche"
  },
  {
    "objectID": "structures/TPDictionnaires.html#conclusion",
    "href": "structures/TPDictionnaires.html#conclusion",
    "title": "T.P. Dictionnaires",
    "section": "Conclusion",
    "text": "Conclusion\nVous le constatez d’après les expériences ci-dessus : le temps de recherche dans le dictionnaire est pratiquement indépendant du nombre d’entrées dans ce dictionnaire, car en multipliant le nombre de contacts par 100, le temps est resté pratiquement identique alors que dans le cas de la recherche dans un tableau, celui-ci est proportionnel à la longueur du tableau.\nLe dictionnaire est donc une structure de données optimisée pour la recherche sur les clés."
  },
  {
    "objectID": "structures/TPDictionnaires_CORR.html",
    "href": "structures/TPDictionnaires_CORR.html",
    "title": "T.P. Dictionnaires",
    "section": "",
    "text": "NSI Terminale"
  },
  {
    "objectID": "structures/TPDictionnaires_CORR.html#rappels-sur-les-dictionnaires",
    "href": "structures/TPDictionnaires_CORR.html#rappels-sur-les-dictionnaires",
    "title": "T.P. Dictionnaires",
    "section": "Rappels sur les dictionnaires",
    "text": "Rappels sur les dictionnaires\nDans cette partie, nous allons fabriquer un carnet d’adresse pour stocker des contacts.\n\nFabrication d’un contact\nChaque contact sera un dictionnaire dont les clés seront : - nom : Nom et prénom du contact - tel : N° de téléphone - rue : adresse complète - code : code postal - ville : ville\nCréez un dictionnaire nommé contact correspondant au contact suivant : &gt; Margaret Costa-Royer &gt; 08 06 18 37 28 &gt; 93, avenue Bruneau &gt; 13749 Perrot\n\n# YOUR CODE HERE\ncontact = {\"nom\":\"Margaret Costa-Royer\", \"tel\":\"08 06 18 37 28\", \"rue\":\"93, avenue Bruneau\", \"code\":13749, \"ville\":\"Perrot\"}\n\n\n# Vérification\nassert contact[\"nom\"] == \"Margaret Costa-Royer\"\nassert contact[\"tel\"] == \"08 06 18 37 28\"\nassert contact[\"ville\"] == \"Perrot\"\n\nAjouter une nouvelle entrée “passwd” dans le contact ayant pour valeur ‘s75JWikE&o’\n\n# YOUR CODE HERE\ncontact[\"passwd\"] = \"s75JWikE&o\"\n\n\n# Vérification\nassert contact[\"passwd\"] == 's75JWikE&o'\n\n\n\nGénération automatique d’un contact\nÉcrire une fonction genere_contact() - qui ne prend aucun paramètre - qui renvoie un dictionnaire possédant les mêmes clés que le contact ci-dessus, y compris “passwd”\nOn pourra utiliser le module faker de python dont un exemple d’utilisation est donné dans la cellule ci-dessous.\n\n%pip install faker\n\n\nfrom faker import Faker\n\nfake = Faker(\"fr_FR\") # Générateur de données personnelles pour un français\n\nprint(fake.name())\nprint(fake.phone_number())\nprint(fake.street_address())\nprint(fake.postcode(), fake.city())\nprint(fake.password())\n\nHugues Monnier de Roger\n+33 (0)3 71 66 66 71\n866, boulevard de Texier\n82052 PhilippeBourg\ndy3Ixvj)^V\n\n\nRemarque : Si la cellule ci-dessus provoque une erreur disant que le module faker n’est pas disponible, vous pouvez l’installer dans l’environnement jupyter via la commande\n!pip install faker\n\ndef genere_contact():\n    \"\"\"Fabrique un contact factice et renvoie le contact sous forme d'un dictionnaire\"\"\"\n    # YOUR CODE HERE\n    fake = Faker(\"fr_FR\")\n    contact = {}\n    contact[\"nom\"] = fake.name()\n    contact[\"tel\"] = fake.phone_number()\n    contact[\"rue\"] = fake.street_address()\n    contact[\"code\"] = fake.postcode()\n    contact[\"ville\"] = fake.city()\n    contact[\"passwd\"] = fake.password()\n    return contact\n\n\ncontact1 = genere_contact()\nassert type(contact1[\"nom\"]) == str\nassert \"ville\" in contact1"
  },
  {
    "objectID": "structures/TPDictionnaires_CORR.html#mise-en-pratique",
    "href": "structures/TPDictionnaires_CORR.html#mise-en-pratique",
    "title": "T.P. Dictionnaires",
    "section": "Mise en pratique",
    "text": "Mise en pratique\n\nFabrication du carnet d’adresse\nTout est à présent en place pour que nous puissions fabriquer notre carnet d’adresse.\n\nPremière implémentation\nDans une première approche, nous allons considérer que le carnet d’adresse sera une liste de contacts, chaque contact étant un dictionnaire dont la structure a été définie à la section précédente.\nFabriquez une fonction genere_carnet1 - prenant en paramètre le nombre n de contacts à générer - renvoyant une liste de n contacts générés aléatoirement.\n\ndef genere_carnet1(n):\n    \"\"\"Renvoie une liste de n contacts aléatoires\"\"\"\n    # YOUR CODE HERE\n    liste = []\n    for k in range(n):\n        liste.append(genere_contact())\n    return liste\n\n\n# vérification\n\ncarnet1 = genere_carnet1(10)\nassert type(carnet1) == list\nassert \"nom\" in carnet1[3]\n\nEcrire à présent une fonction est_present - prenant 2 paramètres : un nom et un carnet d’adresse - renvoyant True si le nom figure dans le carnet d’adresse, False sinon\n\ndef est_present(nom, carnet):\n    \"\"\"Teste si nom est présent dans le carnet d'adresse\"\"\"\n    # YOUR CODE HERE\n    for contact in carnet:\n        if contact[\"nom\"] == nom:\n            return True\n    return False  \n\n\n# Vérification\n\ncarnet1 = genere_carnet1(10)\nnom = carnet1[-1][\"nom\"]\nassert est_present(nom, carnet1)\nassert not est_present(\"Géo Trouvetout\", carnet1)\n\n\n\nMesure de performance de la recherche\nNous allons regarder ici comment évolue la vitesse de recherche en fonction de la taille du carnet d’adresse. On utilisera pour cela la fonction magique de jupyter : %%timeit. Étudiez la cellule suivante :\n\n# Fabrication d'un carnet de 100 contacts\ncarnet1 = genere_carnet1(100)\nnom = carnet1[-1][\"nom\"]  # On récupère un nom du carnet\nnom\n\n'Roger Joseph-Charrier'\n\n\n\n%%timeit\n\n# On mesure le temps d'une recherche\nest_present(nom, carnet1) \n\n2.88 µs ± 14.8 ns per loop (mean ± std. dev. of 7 runs, 100,000 loops each)\n\n\nVous lisez sous la cellule le temps de recherche.\nA présent, on refait l’expérience pour 1000 contacts dans le carnet d’adresse.\n\ncarnet1 = genere_carnet1(1000)\nnom = carnet1[-1][\"nom\"]  # On récupère un nom du carnet\nnom\n\n'Benoît Mahe'\n\n\n\n%%timeit\n\n# On mesure le temps d'une recherche dans ce carnet\nest_present(nom, carnet1)\n\n33.9 µs ± 362 ns per loop (mean ± std. dev. of 7 runs, 10,000 loops each)\n\n\n\n\nSeconde implémentation\nVous devez avoir constaté ci-dessus que le temps de recherche est proportionnel à la taille du carnet d’adresse : si celui-ci contient 10 fois plus de contact, la recherche peut être jusqu’à 10 fois plus longue.\nNous allons changer d’approche et fabriquer un carnet d’adresse sous forme d’un dictionnaire dont les clés seront les noms et les valeurs seront les fiches contacts. Ainsi notre carnet d’adresse sera un dictionnaire dont les valeurs seront des dictionnaires !\nFabriquez une fonction genere_carnet2 - prenant en paramètre le nombre n de contacts à générer - renvoyant un dictionnaire de n contacts générés aléatoirement\n\ndef genere_carnet2(n):\n    \"\"\"Renvoie un dictionnaire de n contacts aléatoires\"\"\"\n    # YOUR CODE HERE\n    dico = {}\n    for k in range(n):\n        contact = genere_contact()\n        nom = contact[\"nom\"]\n        dico[nom] = contact\n    return dico    \n\n\n# Vérification\n\ncarnet2 = genere_carnet2(10)\nassert type(carnet2) == dict\nnom = list(carnet2.keys())[-1]\nassert type(carnet2[nom]) == dict\n\n\n\nMesure de performance de la recherche\nNous allons regarder pour cette nouvelle implémentation comment évolue la vitesse de recherche en fonction de la taille du carnet d’adresse. Validez les 2 cellules suivantes.\n\n# Fabrication d'un carnet de 100 contacts\ncarnet2 = genere_carnet2(100)\nnom = list(carnet2.keys())[-1] # On récupère un nom du carnet\nnom\n\n'Richard Andre'\n\n\n\n%%timeit\n\nnom in carnet2                 # On le recherche\n\n29.2 ns ± 0.196 ns per loop (mean ± std. dev. of 7 runs, 10,000,000 loops each)\n\n\nOn constate déjà que la recherche est plus rapide que pour la première implémentation du carnet à l’aide d’un tableau.\nRefaisons l’expérience avec 100 fois plus de contacts dans le carnet !!\n\n# Fabrication d'un carnet de 10000 contacts\ncarnet2 = genere_carnet2(10000)\nnom = list(carnet2.keys())[-1] # On récupère un nom du carnet\nnom\n\n'Guy Pereira de Blanc'\n\n\n\n%%timeit\n\nnom in carnet2           # On le recherche\n\n30.8 ns ± 0.21 ns per loop (mean ± std. dev. of 7 runs, 10,000,000 loops each)"
  },
  {
    "objectID": "structures/TPDictionnaires_CORR.html#conclusion",
    "href": "structures/TPDictionnaires_CORR.html#conclusion",
    "title": "T.P. Dictionnaires",
    "section": "Conclusion",
    "text": "Conclusion\nVous le constatez d’après les expériences ci-dessus : le temps de recherche dans le dictionnaire est pratiquement indépendant du nombre d’entrées dans ce dictionnaire, car en multipliant le nombre de contacts par 100, le temps est resté pratiquement identique alors que dans le cas de la recherche dans un tableau, celui-ci est proportionnel à la longueur du tableau.\nLe dictionnaire est donc une structure de données optimisée pour la recherche sur les clés."
  }
]