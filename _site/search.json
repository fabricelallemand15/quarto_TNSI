[
  {
    "objectID": "01-langagesProgr/index.html",
    "href": "01-langagesProgr/index.html",
    "title": "Programme",
    "section": "",
    "text": "Points du programme traités dans cette séquence :\n\n\n\n\n\n\n\n\nContenus\nCapacités attendues\nCommentaires\n\n\n\n\nRécursivité.\nÉcrire un programme récursif. Analyser le fonctionnement d’un programme récursif.\nDes exemples relevant de domaines variés sont à privilégier.\n\n\nParadigmes de programmation.\nDistinguer sur des exemples les paradigmes impératif, fonctionnel et objet. Choisir le paradigme de programmation selon le champ d’application d’un programme.\nAvec un même langage de programmation, on peut utiliser des paradigmes différents. Dans un même programme, on peut utiliser des paradigmes différents.\n\n\nVocabulaire de la programmation objet : classes, attributs, méthodes, objets.\nÉcrire la définition d’une classe. Accéder aux attributs et méthodes d’une classe.\nOn n’aborde pas ici tous les aspects de la programmation objet comme le polymorphisme et l’héritage."
  },
  {
    "objectID": "01-langagesProgr/index.html#programme-de-la-séquence",
    "href": "01-langagesProgr/index.html#programme-de-la-séquence",
    "title": "Programme",
    "section": "",
    "text": "Points du programme traités dans cette séquence :\n\n\n\n\n\n\n\n\nContenus\nCapacités attendues\nCommentaires\n\n\n\n\nRécursivité.\nÉcrire un programme récursif. Analyser le fonctionnement d’un programme récursif.\nDes exemples relevant de domaines variés sont à privilégier.\n\n\nParadigmes de programmation.\nDistinguer sur des exemples les paradigmes impératif, fonctionnel et objet. Choisir le paradigme de programmation selon le champ d’application d’un programme.\nAvec un même langage de programmation, on peut utiliser des paradigmes différents. Dans un même programme, on peut utiliser des paradigmes différents.\n\n\nVocabulaire de la programmation objet : classes, attributs, méthodes, objets.\nÉcrire la définition d’une classe. Accéder aux attributs et méthodes d’une classe.\nOn n’aborde pas ici tous les aspects de la programmation objet comme le polymorphisme et l’héritage."
  },
  {
    "objectID": "01-langagesProgr/paradigmes_cours.html",
    "href": "01-langagesProgr/paradigmes_cours.html",
    "title": "Paradigmes de programmation (Cours)",
    "section": "",
    "text": "Tout d’abord, nous pouvons nous demander ce que signifie le mot paradigme. Parmi les trois définitions fournies par le dictionnaire Le Robert, celle qui nous intéresse est la suivante :\n\n\n\n\n\n\nDéfinition\n\n\n\n\nParadigme\n\nModèle de pensée.\n\n\n\n\nEn programmation, un paradigme est donc une manière de penser un programme, une méthode de programmation.\nUn programme est un texte, avec ses conventions d’écriture. Il s’agit bien d’un langage écrit, au sens commun, mais il doit toujours avoir un sens univoque et non contextuel.\nIl faut que la formulation textuelle d’un programme soit :\n\nsuffisamment proche d’un code réel, conforme à une famille d’ordinateurs particuliers ;\nstandardisée et générale pour permettre une adaptation immédiate et automatique — on parle de « portabilité » — à d’autres contextes similaires ;\nparfaitement univoque, non ambiguë, puisque destinée à un traitement automatique ;\nintelligible par un être humain.\n\nVu le grand nombre de langages existants, une classification s’est fait jour. On regroupe en général les langages en « familles » selon le paradigme de programmation auquel ils sont (le mieux) adaptés.\nConformément au programme, nous allons définir les paradigmes impératif, fonctionnel et objet.\nNotons tout d’abord que la plupart des langages de programmation modernes sont multiparadigmes : ils permettent de programmer aussi bien de façon impérative, fonctionnelle qu’avec des objets."
  },
  {
    "objectID": "01-langagesProgr/paradigmes_cours.html#introduction-et-définition",
    "href": "01-langagesProgr/paradigmes_cours.html#introduction-et-définition",
    "title": "Paradigmes de programmation (Cours)",
    "section": "",
    "text": "Tout d’abord, nous pouvons nous demander ce que signifie le mot paradigme. Parmi les trois définitions fournies par le dictionnaire Le Robert, celle qui nous intéresse est la suivante :\n\n\n\n\n\n\nDéfinition\n\n\n\n\nParadigme\n\nModèle de pensée.\n\n\n\n\nEn programmation, un paradigme est donc une manière de penser un programme, une méthode de programmation.\nUn programme est un texte, avec ses conventions d’écriture. Il s’agit bien d’un langage écrit, au sens commun, mais il doit toujours avoir un sens univoque et non contextuel.\nIl faut que la formulation textuelle d’un programme soit :\n\nsuffisamment proche d’un code réel, conforme à une famille d’ordinateurs particuliers ;\nstandardisée et générale pour permettre une adaptation immédiate et automatique — on parle de « portabilité » — à d’autres contextes similaires ;\nparfaitement univoque, non ambiguë, puisque destinée à un traitement automatique ;\nintelligible par un être humain.\n\nVu le grand nombre de langages existants, une classification s’est fait jour. On regroupe en général les langages en « familles » selon le paradigme de programmation auquel ils sont (le mieux) adaptés.\nConformément au programme, nous allons définir les paradigmes impératif, fonctionnel et objet.\nNotons tout d’abord que la plupart des langages de programmation modernes sont multiparadigmes : ils permettent de programmer aussi bien de façon impérative, fonctionnelle qu’avec des objets."
  },
  {
    "objectID": "01-langagesProgr/paradigmes_cours.html#paradigme-impératif",
    "href": "01-langagesProgr/paradigmes_cours.html#paradigme-impératif",
    "title": "Paradigmes de programmation (Cours)",
    "section": "Paradigme impératif",
    "text": "Paradigme impératif\nLa programmation impérative est la méthode de programmation que vous avez le plus couramment utilisée jusqu’à présent.\nIl s’agit d’un paradigme de programmation qui décrit les opérations en séquences d’instructions exécutées par l’ordinateur pour modifier l’état du programme.\nLa programmation impérative se concentre sur la description du fonctionnement d’un programme.\nLa plupart des langages de haut niveau comporte cinq types d’instructions principales :\n\nla séquence d’instructions\nl’assignation ou affectation\nl’instruction conditionnelle (if, else)\nla boucle (for, while)\nles branchements.\n\nCe type de programmation est le plus ancien et utilisé, il est facile à comprendre, souvent efficace, car proche des instructions réalisées par les processeurs. Par contre, il est assez difficile à tester, car l’état du programme ne cesse de changer et il est difficile de tester une petite partie du programme au milieu de son exécution par exemple, car elle nécessite que toutes les instructions précédentes aient déjà été appliquées correctement.\nLes langages C, C++, Java, JavaScript, Python et beaucoup d’autres permettent la programmation impérative."
  },
  {
    "objectID": "01-langagesProgr/paradigmes_cours.html#paradigme-fonctionnel",
    "href": "01-langagesProgr/paradigmes_cours.html#paradigme-fonctionnel",
    "title": "Paradigmes de programmation (Cours)",
    "section": "Paradigme fonctionnel",
    "text": "Paradigme fonctionnel\n\nIntroduction\nLe paradigme fonctionnel est un paradigme de programmation qui reprend les principes du lambda-calcul introduit par Alonzo Church dans les années 1930.\nL’idée fondamentale du lambda-calcul est de considérer que les fonctions sont des données comme les autres. Ainsi, elles peuvent être par exemple passées en paramètre à d’autres fonctions.\nD’autres principes découlent également de la thèse de Church :\n\nles fonctions sont des fonctions au sens mathématique du terme : elles se contentent de renvoyer une valeur en fonction de leurs arguments ;\nil n’y a pas de notion « d’état », ni à l’extérieur des fonctions, ni dans les fonctions. Un programme n’est donc qu’une composition de fonctions.\n\nLe paradigme fonctionnel a d’abord été implanté au sein de langages dédiés, plus ou moins « purement fonctionnel ». Parmi les langages dits fonctionnels, on peut citer :\n\nLISP (List Processing) : 1958 ;\nSML (Standard Meta Language) : 1983 ;\nCAML (Categorical Abstract Machine Language) : 1987, puis son extension objet OCAML ;\nHaskell : 1990 ;\nClojure : 2007.\n\nMais certains aspects du paradigme fonctionnel ont fini par être intégrés dans des langages impératifs, car ils présentent certains avantages :\n\nfonctions pures ;\nfonctions d’ordre supérieur ;\nlambda-expressions ;\névaluation paresseuse.\n\nEn programmation fonctionnelle, les variables sont toujours constantes : une fois qu’elles ont été affectées, leur valeur ne doit plus changer ; de plus les boucles sont remplacées par des appels récursifs.\n\n\nMise en œuvre en Python\n\nFonctions pures\nUne fonction pure est une fonction qui ne modifie rien ; elle ne fait que renvoyer des valeurs en fonction de ses paramètres. Et les valeurs renvoyées ne doivent dépendre que de ses paramètres, et pas de variables extérieures à la fonction.\nLes modifications qu’une fonction peut effectuer sur l’état du système sont appelées effets de bord. Un affichage à l’écran est un exemple d’effet de bord.\nEn Python, rien n’impose d’implémenter des fonctions pures. Notamment, étant donné la façon dont les arguments sont passés à une fonction en Python (utilisation d’une copie de la référence initiale), rien n’interdit qu’une fonction modifie l’objet référencé par l’un de ses paramètres.\nVoici un tel exemple :\ndef retirer_dernier(liste) :\n    liste.pop()\nOn utilise cette fonction ainsi :\n&gt;&gt;&gt; ma_liste = [1, 2, 3]\n&gt;&gt;&gt; retirer_dernier(ma_liste)\nL’inconvénient de ce type de fonction est qu’elle modifie la variable ma_liste qui, à l’issue de l’exécution des deux lignes précédentes contient [1, 2]. Cela peut rendre le code plus difficile à comprendre et générer des comportements inattendus. Une fonction pure, au contraire, doit renvoyer la valeur calculée sans modifier ses paramètres. Ainsi, on peut réécrire le traitement précédent de la façon suivante :\ndef retirer_dernier_pure(liste) :\n    retour = liste[:]\n    retour.pop()\n    return retour\nCette fonction s’utilise ainsi :\n&gt;&gt;&gt; l1 = [1, 2, 3]\n&gt;&gt;&gt; l2 = retirer_dernier_pure(l1)\nDans ce dernier cas, le fait que l’appel à retirer_dernier_pure ne modifie par l1 est bien plus intuitif.\n\n\n\n\n\n\nÀ retenir\n\n\n\nPour faciliter l’écriture de fonctions pures en Python, on peut :\n\nutiliser au maximum des données non mutables (tuples plutôt que listes par exemple) ;\ncopier systématiquement au début des fonctions les paramètres référençant des données mutables et utiliser ces copies dans la fonction.\non veille à ne pas modifier de valeur existante, mais plutôt à créer une nouvelle valeur à partir de la valeur existante.\n\n\n\nEssayer de n’écrire que des fonctions pures permet de limiter les risques de bugs et facilite la relecture des programmes. Il s’agit donc d’un style de programmation à privilégier.\n\n\n\nFonctions d’ordre supérieur\nLes fonctions étant considérées comme des données comme les autres, il est possible de définir des fonctions dont les arguments sont d’autres fonctions. On parle alors de fonctions d’ordre supérieur.\nPython fournit des fonctions d’ordre supérieur dans sa bibliothèque standard. Voyons par exemple la fonction map qui permet d’appliquer une fonction à tous les éléments d’une liste. Quelques remarques et explications s’imposent :\n\nmap peut s’appliquer à tout objet itérable, donc aux chaînes de caractères, aux tuples, aux listes.\nmap retourne un objet itérable : les valeurs résultat ne sont pas toutes calculées par avance, elles le seront à la demande. Cet itérable peut être transformé en liste en tapant list(map(...)) ou être utilisé dans une boucle for item in map(...):. Ce calcul des valeurs à la demande est une mise en œuvre du principe de l’évaluation paresseuse caractéristique de la programmation fonctionnelle.\n\nConsidérons le programme suivant :\ndef carre(x):\n    return x**2\n\n\ndef capit(ch):\n    return ch.capitalize()\n\n\nma_str = \"azerty\"\nmon_tuple = (1, 2, 3, 4, 5)\nma_liste = [1, 2, 3, 4, 5]\n\niter1 = map(capit, ma_str)\niter2 = map(carre, mon_tuple)\niter3 = map(carre, ma_liste)\n\nfor car in iter1:\n    print(car, end=\"\")\nprint()\nprint(tuple(iter2))\nprint(list(iter3))\nOn obtient en sortie :\nAZERTY\n(1, 4, 9, 16, 25)\n[1, 4, 9, 16, 25]\n\n\n\n\n\n\nRemarque\n\n\n\nLe programme ci-dessus est donné pour illustrer l’idée de fonction d’ordre supérieur, mais il n’est pas rédigé, notamment sa partie itérative, dans l’esprit de la programmation fonctionnelle !\n\n\nLes langages OCamL, Haskell, F#, Rust par exemple sont des langages fonctionnels."
  },
  {
    "objectID": "01-langagesProgr/paradigmes_cours.html#paradigme-objet",
    "href": "01-langagesProgr/paradigmes_cours.html#paradigme-objet",
    "title": "Paradigmes de programmation (Cours)",
    "section": "Paradigme objet",
    "text": "Paradigme objet\nLa POO consiste en la définition et l’interaction de briques logicielles appelées objets; un objet représente un concept, une idée ou toute entité du monde physique, comme une voiture, une personne ou encore une page d’un livre.\nUn objet possède:\n\ndes données: ses attributs et\ndes fonctions: ses méthodes\n\nLes différents principes de la conception orientée objet aident à la réutilisation du code, au masquage des données, etc. Les bases de la POO sont détaillées dans le cours précédent, avec ses compléments."
  },
  {
    "objectID": "01-langagesProgr/paradigmes_cours.html#à-quel-paradigme-se-vouer",
    "href": "01-langagesProgr/paradigmes_cours.html#à-quel-paradigme-se-vouer",
    "title": "Paradigmes de programmation (Cours)",
    "section": "À quel paradigme se vouer ?",
    "text": "À quel paradigme se vouer ?\nComment choisir entre les différents paradigmes existants ?\nIl est important de bien comprendre qu’un programmeur doit maitriser plusieurs paradigmes de programmation (impératif, objet ou encore fonctionnelle). En effet, il sera plus facile d’utiliser le paradigme objet dans certains cas alors que dans d’autres situations, l’utilisation du paradigme fonctionnel sera préférable. Être capable de choisir le “bon” paradigme en fonction des situations fait partie du bagage de tout bon programmeur.\nIl est aussi important de bien comprendre que la frontière entre ces différents paradigmes est parfois floue, par exemple on utilise très souvent de l’impératif en programmation orientée objet.\nDans l’article Perceiving Python programming paradigms du site opensource.com/, les conseils suivants sont donnés :\n\nPour simplifier, si votre problème implique une série de manipulations séquentielles simples, suivre le paradigme de programmation impérative de la vieille école serait le moins cher en termes de temps et d’efforts et vous donnerait potentiellement les meilleures performances.\nDans le cas de problèmes nécessitant des transformations mathématiques des valeurs, le filtrage des informations, le mappage (transformer une liste en une autre) et les réductions (transformer une liste en une valeur), la programmation fonctionnelle pourrait être adaptée.\nSi le problème est structuré comme un tas d’objets interdépendants avec certains attributs qui peuvent changer avec le temps, en fonction de certaines conditions, la programmation orientée objet sera certainement la plus naturelle.\n\nBien sûr, il n’y a pas de règle simple, car le choix du paradigme de programmation dépend également fortement du type de données à traiter, des connaissances des programmeurs et de diverses autres choses comme l’évolutivité.\nNotons pour finir que cette courte présentation ne recouvre pas tous les paradigmes de programmation existants. On rencontrera notamment l’idée de programmation événementielle lors du développement d’interfaces graphiques."
  },
  {
    "objectID": "01-langagesProgr/paradigmes_exercices.html",
    "href": "01-langagesProgr/paradigmes_exercices.html",
    "title": "Paradigmes de programmation (Exercices)",
    "section": "",
    "text": "Les exercices précédés du symbole  sont à faire sur machine, en sauvegardant le fichier si nécessaire.\nLes exercices précédés du symbole  doivent être résolus par écrit."
  },
  {
    "objectID": "01-langagesProgr/paradigmes_exercices.html#exercice-1",
    "href": "01-langagesProgr/paradigmes_exercices.html#exercice-1",
    "title": "Paradigmes de programmation (Exercices)",
    "section": " Exercice 1",
    "text": "Exercice 1\nVoici différents algorithmiques permettant l’affichage des 10 chiffres entiers dans l’ordre décroissant.\nPréciser pour chacun des algorithme le type de paradigme auquel il correspond.\nAlgorithme 1 :\ndef decompter(n:int)-&gt;None:\n    if n&gt;=0: \n        print(n)\n        decompter(n-1)\ndecompter(9)\nAlgorithme 2 :\nfor i in range(10):\n    print(9-i)\nAlgorithme 3 :\nclass Nombres():\n\n    def __init__(self,valeur):\n        self.valeur = valeur\n\n    def diminuer(self):\n        self.valeur -= 1\n\n    def __str__(self):\n        return str(self.valeur)\n\nn = Nombres(9)\nwhile n.valeur &gt;= 0 :\n    print(n)\n    n.diminuer()"
  },
  {
    "objectID": "01-langagesProgr/paradigmes_exercices.html#exercice-2",
    "href": "01-langagesProgr/paradigmes_exercices.html#exercice-2",
    "title": "Paradigmes de programmation (Exercices)",
    "section": " Exercice 2",
    "text": "Exercice 2\nVoici deux versions d’une fonction teste_ordre_liste dont l’objectif est de savoir si une liste est ordonnée par ordre croissant. Indiquer quel paradigme est utilisé dans chacune des deux versions et expliquer votre réponse.\nVersion 1\n# -*- coding: utf-8 -*-\n\ndef test_ordre(a,b) :\n    if a &lt; b :\n        return True\n    else :\n        return False\n\ndef test_ordre_liste(liste) :\n    if len(liste) &lt; 2 :\n        return True\n    return test_ordre(liste[0],liste[1]) and test_ordre_liste(liste[1:])\n\ntest_ordre_liste([2,3,2])\nVersion 2\n# -*- coding: utf-8 -*-\n\ndef test_ordre(a,b) :\n    if a &lt; b :\n        return True\n    else :\n        return False\n\ndef test_ordre_liste(liste) :\n    if len(liste) &lt; 2 :\n        return True\n    else :\n        if test_ordre(liste[0],liste[1]) == False :\n            return False\n        else :\n            del liste[0]\n            return test_ordre_liste(liste)\n\ntest_ordre_liste([2,3,2])"
  },
  {
    "objectID": "01-langagesProgr/paradigmes_exercices.html#exercice-3",
    "href": "01-langagesProgr/paradigmes_exercices.html#exercice-3",
    "title": "Paradigmes de programmation (Exercices)",
    "section": " Exercice 3",
    "text": "Exercice 3\nLe programme ci-dessous ne respecte pas le paradigme fonctionnel. Pourquoi ?\ni = 5\n\ndef fct():\n  if i &gt; 5:\n    return True\n  else :\n    return False\n\nfct()\nModifier le programme pour qu’il respecte le paradigme fonctionnel."
  },
  {
    "objectID": "01-langagesProgr/paradigmes_exercices.html#exercice-4",
    "href": "01-langagesProgr/paradigmes_exercices.html#exercice-4",
    "title": "Paradigmes de programmation (Exercices)",
    "section": " Exercice 4",
    "text": "Exercice 4\nMême exercice avec le programme ci-dessous :\nl = [4,7,3]\n\ndef ajout(i):\n  l.append(i)\n\n\n\n\n\n\nComplément pour les curieux\n\n\n\nPour ceux qui voudraient découvrir un langage fonctionnel, cette page fournit une introduction pas à pas aux bases de OCamL. Ce langage est utilisé en CPGE scientifiques dans le cadre de l’option informatique. Une autre introduction, pour la prépa, est disponible ici. On peut programmer en OCamL en ligne ici."
  },
  {
    "objectID": "01-langagesProgr/POO_complements.html",
    "href": "01-langagesProgr/POO_complements.html",
    "title": "Programmation orientée objets (Compléments)",
    "section": "",
    "text": "Avertissement\n\n\n\nLes compléments présentés ici sont hors programme. Ils peuvent néanmoins apporter une connaissance et une compréhension plus fine de la POO et être utiles dans le cadre du travail sur les projets."
  },
  {
    "objectID": "01-langagesProgr/POO_complements.html#principes-et-définitions",
    "href": "01-langagesProgr/POO_complements.html#principes-et-définitions",
    "title": "Programmation orientée objets (Compléments)",
    "section": "Principes et définitions",
    "text": "Principes et définitions\n\nObjet\n\nUn objet est une donnée manipulable par un programme : il s’agit d’un conteneur pour une valeur ou un état auquel est associé un ensemble d’opérations. Cet objet est associé à un type, défini comme l’ensemble des valeurs possibles, cette liste d’opérations, ainsi que leur codage (binaire).\n\n\nUn objet est identifié dans un programme par un nom ou une notation littérale, mais peut parfois être anonyme (comme les variables temporaires ou les composantes d’un tableau).\nEt pour une définition d’un langage orienté objet, l’idée première que l’on retrouve dans la définition de wikipédia offre un cadre intéressant : un langage objet doit permettre l’analyse et le développement logiciel fondés sur des relations entre objets.\nConcrètement, un objet est une structure de données qui répond à un ensemble de messages. Cette structure de données définit son état tandis que l’ensemble des messages qu’il comprend décrit son comportement :\n\nles données, ou champs, qui décrivent sa structure interne sont appelées ses attributs ;\nl’ensemble des messages forme ce que l’on appelle l’interface de l’objet ; c’est seulement au travers de celle-ci que les objets interagissent entre eux. La réponse à la réception d’un message par un objet est appelée une méthode (méthode de mise en œuvre du message) ; elle décrit quelle réponse doit être donnée au message.\n\nLes attributs et les méthodes constituent les membres d’un objet. Un objet possède un type.\nEn Python, un objet la création d’un objet se fait en utilisant une classe : un objet est alors une instance de sa classe. La classe est un type, un ensemble d’objets partageant les mêmes propriétés concrétisées par une liste de membres.\n\nLangage orienté objet\n\nUn langage orienté objet est un langage de programmation qui comporte de manière native les éléments suivants : l’encapsulation, l’héritage, le polymorphisme et la programmation générique."
  },
  {
    "objectID": "01-langagesProgr/POO_complements.html#les-principes-clés-de-la-poo",
    "href": "01-langagesProgr/POO_complements.html#les-principes-clés-de-la-poo",
    "title": "Programmation orientée objets (Compléments)",
    "section": "Les principes clés de la POO",
    "text": "Les principes clés de la POO\n\nL’encapsulation\nCertains membres (ou plus exactement leur représentation informatique) sont cachés : c’est le principe d’encapsulation. Ainsi, le programme peut modifier la structure interne des objets ou leurs méthodes associées sans avoir d’impact sur les utilisateurs de l’objet. C’est un des principes fondamentaux notamment pour la robustesse du code.\nEn particulier, les bonnes pratiques de POO recommandent de na pas permettre un accès direct aux attributs d’un objet à l’extérieur de celui-ci. On appelle interface d’un objet l’ensemble de ses membres qui sont accessibles à l’extérieur de celui-ci. L’interface ne devrait donc contenir que des méthodes. Pas forcément toutes, certaines méthodes (comme __init__) restent privées.\nContrairement à d’autres langages, Python offre une totale liberté de modification sur les membres d’un objet. C’est au programmeur de rester vigilant. Il existe néanmoins des conventions permettant d’identifier les membres de l’interface des autres membres d’un objet.\n\n\n\n\n\n\nConventions de nommage en Python\n\n\n\n\nun nom d’attribut commençant par un double underscore __ désigne un attribut privé.\nune méthode dont le nom est de la forme __nom__ désigne une méthode privée.\n\n\n\nMais alors si les attributs doivent rester privés, comment y accéder, et comment les modifier ?\nIl convient pour cela, en toute rigueur, de définir des méthodes ad-hoc : une méthode qui permet d’accéder à un attribut est un getter, une période qui permet de changer la valeur d’un attribut est un setter.\nVoici par exemple une nouvelle définition de la classe “Rectangle” tenant compte des remarques précédentes.\nclass Rectangle:\n    \"\"\"Représente un rectangle\"\"\"\n\n    def __init__(self, largeur=2, hauteur=3):\n        self.__largeur = largeur\n        self.__hauteur = hauteur\n\n    def get_largeur(self):\n        return self.__largeur\n\n    def set_largeur(self, largeur):\n        self.__largeur = largeur\n\n    def get_hauteur(self):\n        return self.__hauteur\n\n    def set_hauteur(self, hauteur):\n        self.__hauteur = hauteur\n\n    def perimetre(self):\n        \"\"\"Retourne le périmètre\"\"\"\n        return 2 * (self.__largeur + self.__hauteur)\n\n    def aire(self):\n        \"\"\"Retourne l'aire\"\"\"\n        return self.__largeur * self.__hauteur\nUtilisation :\n&gt;&gt;&gt; rec = Rectangle(10, 5)\n&gt;&gt;&gt; rec.__hauteur\nAttributeError: 'Rectangle' object has no attribute '__hauteur'\n&gt;&gt;&gt; rec.get_hauteur()\n5\nNous voyons que l’accès direct à l’attribut n’est plus possible.\nCela n’est pas très pratique et change nos habitudes : nous aimerions en effet pouvoir accéder à la valeur d’un attribut en utilisant la notation pointée. Deux remarques à ces objections. D’une part, ces règles de programmation ne sont pas là pour nous embêter ! Il s’agit de sécuriser notre code : la définition d’un setter par exemple, peut permettre de vérifier la validité des arguments entrés et afficher un message d’erreur si besoin (par exemple si on appelle set_hauteur(-10). Deuxième remarque : Python propose une fonctionnalité avancée, appelée décorateurs et qui permet de retrouver, en apparence, l’accès direct aux attributs. Voici une nouvelle version de la classe “Rectangle” avec l’utilisation du décorateur @property et la redéfinition des getter et setter (qui doivent maintenant porter le même nom que le pseudo argument). On a introduit dans les setter des tests de validité des données.\nclass Rectangle:\n    \"\"\"Représente un rectangle\"\"\"\n\n    def __init__(self, largeur=2, hauteur=3):\n        self.__largeur = largeur\n        self.__hauteur = hauteur\n\n    @property\n    def largeur(self):\n        return self.__largeur\n\n    @largeur.setter\n    def largeur(self, largeur):\n        if isinstance(largeur, (int, float)) and largeur &gt;= 0:\n            self.__largeur = largeur\n        else:\n            print(\"Argument invalide, largeur inchangée !\")\n\n    @property\n    def hauteur(self):\n        return self.__hauteur\n\n    @hauteur.setter\n    def hauteur(self, hauteur):\n        if isinstance(hauteur, (int, float)) and hauteur &gt;= 0:\n            self.__hauteur = hauteur\n        else:\n            print(\"Argument invalide, hauteur inchangée !\")\n\n    def perimetre(self):\n        \"\"\"Retourne le périmètre\"\"\"\n        return 2 * (self.__largeur + self.__hauteur)\n\n    def aire(self):\n        \"\"\"Retourne l'aire\"\"\"\n        return self.__largeur * self.__hauteur\n\n\nrec = Rectangle(10, 25)\nprint(rec.largeur)\nrec.largeur = -15\nprint(rec.largeur)\nSortie en console :\n10\nArgument invalide, largeur inchangée !\n10\n\n\nL’héritage\nL’héritage est une relation asymétrique entre deux classes : l’une est la classe mère (aussi nommée classe parente, superclasse, classe de base), l’autre la classe-fille. L’héritage permet une économie d’écriture par la réutilisation automatique, lors de la définition de la classe-fille, de tous les membres et autres éléments définis dans la classe mère. Ainsi, les objets de la classe-fille héritent de toutes les propriétés de leur classe mère.\nPar exemple, nous pouvons définir une classe carre, fille de la classe Rectangle. Les attributs et les méthodes définis pour la classe Rectangle existent alors automatiquement aussi pour la classe carre.\nVoici la syntaxe Python pour définir une classe fille :\nclass Carre(Rectangle):\n\n    def __init__(self, cote=2):\n        Rectangle.__init__(self, cote, cote)\nUtilisation :\n&gt;&gt;&gt; car = Carre(5)\n&gt;&gt;&gt; car.perimetre()\n20\nLa méthode perimetre est héritée de la classe mère Rectangle.\n\n\n\n\n\n\nHéritage et initialiseur\n\n\n\nLa méthode initialiseur de la classe Carre fait appel à la méthode initialiseur de sa classe parente par la commande Rectangle.__init__(self, cote, cote). Cet appel est nécessaire afin que les membres de la classe Carre soient définis de la même manière que les membres de la classe Rectangle. La méthode __init__ est un initialiseur d’instance : elle n’est pas invoquée automatiquement lorsqu’on instancie des objets d’une classe fille.\n\n\n\n\nLe polymorphisme et la redéfinition\nLa redéfinition des méthodes permet à un objet de raffiner une méthode définie avec la même en-tête dans la classe mère. Une même méthode pourra ainsi avoir un comportement différent selon qu’elle s’applique à la classe mère ou à la classe fille : on parle de polymorphisme d’héritage.\nPar exemple, nous pouvons redéfinir la méthode aire de la classe Carre comme ci-dessous : appliquée à un objet Carre, la nouvelle définition sera utilisée à la place de la méthode héritée.\nclass Carre(Rectangle):\n\n    def __init__(self, cote=2):\n        self.__largeur = cote\n        self.__hauteur = cote\n    \n    def aire(self):\n        \"\"\"Retourne l'aire\"\"\"\n        return self.__largeur ** 2"
  },
  {
    "objectID": "01-langagesProgr/POO_complements.html#les-méthodes-spéciales",
    "href": "01-langagesProgr/POO_complements.html#les-méthodes-spéciales",
    "title": "Programmation orientée objets (Compléments)",
    "section": "Les méthodes spéciales",
    "text": "Les méthodes spéciales\nUn bon exemple de polymorphisme est fourni par la redéfinition des méthodes spéciales.\nNous savons que la fonction dir() renvoie tous les membres d’un objet.\nAppliquons cette commande à notre objet rec, instance de la classe Rectangle :\n&gt;&gt;&gt; dir(rec)\n['__class__',\n '__delattr__',\n '__dict__',\n '__dir__',\n '__doc__',\n '__eq__',\n '__format__',\n '__ge__',\n '__getattribute__',\n '__gt__',\n '__hash__',\n '__init__',\n '__init_subclass__',\n '__le__',\n '__lt__',\n '__module__',\n '__ne__',\n '__new__',\n '__reduce__',\n '__reduce_ex__',\n '__repr__',\n '__setattr__',\n '__sizeof__',\n '__str__',\n '__subclasshook__',\n '__weakref__',\n '_hauteur',\n '_largeur',\n 'aire',\n 'hauteur',\n 'largeur',\n 'perimetre']\nNous reconnaissons en fin de liste les attributs et méthodes que nous avons définis, mais nous découvrons l’existence d’un grand nombre de méthodes spéciales privées (puisque leur nom est entouré de __) qui sont en fait héritées d’une classe Object parente de toutes les classes. Parmi celles-ci, nous avons déjà rencontré __init__, la méthode initialiseur.\nLes curieux pourront rechercher le rôle de chacune de ces méthodes spéciales. Le voici pour certaines d’entre elles :\n\n\n\nMéthode spéciale\nUsage\n\n\n\n\nadd\n+\n\n\nmul\n*\n\n\nsub\n-\n\n\neq\n==\n\n\nne\n!=\n\n\nlt\n&lt;\n\n\nge\n&lt;=\n\n\ngt\n&gt;\n\n\nge\n&gt;=\n\n\nrepr\naffichage dans la console &gt;&gt;&gt; obj\n\n\nstr\nstr(obj), print(obj)\n\n\n\nLa redéfinition de la méthode __add__ permettrait par exemple de donner un sens à l’utilisation du symbole + entre deux objets (instruction du type rec1 + rec 2).\nDans notre exemple, nous allons redéfinir la méthode __str__ pour spécifier ce qui doit s’afficher quand l’instruction print(rec) est exécutée.\nPour l’instant, on obtient :\n&gt;&gt;&gt; print(rec)\n&lt;__main__.Rectangle object at 0x000002386735C730&gt;\nAjoutons la méthode ci-dessous dans la classe Rectangle :\ndef __str__(self):\n    return f\"Rectangle de largeur {self.__largeur} et de hauteur {self.__hauteur}.\"\nOn obtient maintenant :\n&gt;&gt;&gt; print(rec)\nRectangle de largeur 10 et de hauteur 25."
  },
  {
    "objectID": "01-langagesProgr/POO_cours.html",
    "href": "01-langagesProgr/POO_cours.html",
    "title": "Programmation orientée objets (Cours)",
    "section": "",
    "text": "Objectifs\n\n\n\n\nConnaître le vocabulaire de la POO : classes, attributs, méthodes objets.\nÉcrire la définition d’une classe.\nAccéder aux méthodes et attributs d’une classe.\nDes compléments sur la POO sont proposés à la suite de ce cours."
  },
  {
    "objectID": "01-langagesProgr/POO_cours.html#introduction",
    "href": "01-langagesProgr/POO_cours.html#introduction",
    "title": "Programmation orientée objets (Cours)",
    "section": "Introduction",
    "text": "Introduction\nLa Programmation Orientée Objets (POO) pour les intimes (que vous allez devenir !) est un paradigme (c’est-à-dire une manière de faire) de programmation\nPour un bref aperçu historique de l’idée d’objet en programmation, lire l’encadré ci-dessous, en grande partie tiré de l’article Object-oriented programming de Wikipedia en anglais.\n\n\n\n\n\n\nUn peu d’histoire\n\n\n\nLes termes objets orienté au sens moderne de la programmation orientée objet ont fait leur première apparition au MIT à la fin des années 1950 et au début des années 1960. Dans l’environnement du groupe d’intelligence artificielle, dès 1960, “objet” pouvait désigner des éléments identifiés avec des propriétés (attributs).\nC’est l’informaticien Alan Kay (1940-) qui est considéré comme l’un de pères de la programmation orientée objets.\n\nJe pensais que les objets étaient comme des cellules biologiques et / ou des ordinateurs individuels sur un réseau, uniquement capables de communiquer avec des messages.\nAlan Kay\n\nLe langage Simula dans les années 1960, puis Smalltalk dans les années 1970 posent les bases toujours actuelles de ce paradigme.\nAu début et au milieu des années 1990, la programmation orientée objet s’est développée comme le paradigme de programmation dominant lorsque les langages de programmation prenant en charge ces techniques sont devenus largement disponibles. Ceux-ci incluent par exemple C++ ou Delphi. Sa domination a été renforcée par la popularité croissante des interfaces utilisateur graphiques, qui reposent fortement sur des techniques de programmation orientées objet.\nDes fonctionnalités orientées objet ont été ajoutées à de nombreux langages existants, notamment Ada, BASIC, Fortran, Pascal et COBOL.\nPlus récemment, un certain nombre de langages ont émergé qui sont principalement orientés objet, mais qui sont également compatibles avec la méthodologie procédurale. Deux de ces langages sont Python et Ruby. Les langages orientés objet récents les plus importants sur le plan commercial sont probablement Java, développé par Sun Microsystems, ainsi que C# et Visual Basic.NET (VB.NET), tous deux conçus pour la plate-forme.NET de Microsoft.\n*[MIT] : Massachusetts Institute of Technology\n\n\nAlors de quoi s’agit-il ? Une approche intuitive consiste à dire que cette méthode de programmation nous permet de définir des nouveaux types de données, de nouveaux objets, correspondant à un objectif précis. Ces nouveaux types sont appelés classes. En définissant une classe, nous pouvons également définir ses attributs, c’est-à-dire les variables qui lui sont associées et ses méthodes, c’est-à-dire les fonctions sui lui sont propres.\nVoici ce que Gérard SWINNEN écrit dans son livre Apprendre à programmer avec Python 3 :\n\nLes classes sont les principaux outils de la programmation orientée objet (Object Oriented Programming ou OOP). Ce type de programmation permet de structurer les logiciels complexes en les organisant comme des ensembles d’objets qui interagissent, entre eux et avec le monde extérieur.\nLe premier bénéfice de cette approche de la programmation réside dans le fait que les différents objets utilisés peuvent être construits indépendamment les uns des autres (par exemple par des programmeurs différents) sans qu’il n’y ait de risque d’interférence. Ce résultat est obtenu grâce au concept d’encapsulation : la fonctionnalité interne de l’objet et les variables qu’il utilise pour effectuer son travail, sont en quelque sorte « enfermées » dans l’objet. Les autres objets et le monde extérieur ne peuvent y avoir accès qu’à travers des procédures bien définies : l’interface de l’objet.\nEn particulier, l’utilisation de classes dans vos programmes va vous permettre – entre autres avantages – d’éviter au maximum l’emploi de variables globales. Vous devez savoir en effet que l’utilisation de variables globales comporte des risques, d’autant plus importants que les programmes sont volumineux, parce qu’il est toujours possible que de telles variables soient modifiées, ou même redéfinies, n’importe où dans le corps du programme (ce risque s’aggrave particulièrement si plusieurs programmeurs différents travaillent sur un même logiciel).\n\nEn utilisant Python, nous avons déjà fréquenté des classes d’objets : il est usuel de lire qu’en Python “tout est objet”, même si Python ne permet pas vraiment de faire de la POO dans toute sa rigueur.\nPar exemple, définissons une chaîne de caractères et demandons à Python quel est son type :\n&gt;&gt;&gt; a = \"Coucou !\"\n&gt;&gt;&gt; type(a)\n&lt;class 'str'&gt;\nLe type ‘str’ bien connu est en fait une classe d’objet prédéfinie. On dit que a est une instance de l’objet str.\nUn exemple de méthode rattachée à la classe str est la fonction capitalize qui met le premier caractère en majuscule. Cette méthode est appelée par la notation pointée déjà rencontrée.\n&gt;&gt;&gt; a.capitalize()\n'Coucou !'\nLa commande help(str) affiche toutes les méthodes prédéfinies pour les objets de la classe str."
  },
  {
    "objectID": "01-langagesProgr/POO_cours.html#classe-initialiseur-attributs",
    "href": "01-langagesProgr/POO_cours.html#classe-initialiseur-attributs",
    "title": "Programmation orientée objets (Cours)",
    "section": "Classe, initialiseur, attributs",
    "text": "Classe, initialiseur, attributs\nEn Python, la définition d’une classe se fait avec le mot-clef class suivi du nom de la classe.\nSupposons par exemple que nous voulons définir une classe pour représenter des rectangles. Nous avons besoin, pour chaque rectangle, de connaître sa largeur et se hauteur, ce qui nous permettra de faire quelques calculs.\nObservons le code suivant :\nclass Rectangle:\n    \"\"\"Représente un rectangle\"\"\"\n    \n    def __init__(self, largeur = 2, hauteur = 3):\n        self.largeur = largeur\n        self.hauteur = hauteur\nÀ l’intérieur de la classe Rectangle, la méthode __init__ est l’initialiseur : elle est toujours exécutée lorsqu’une instance de l’objet Rectangle est créée (on parle aussi de constructeur). Cette fonction accepte des paramètres qui seront les valeurs à donner aux attributs à la création de l’objet (ici on a aussi donné des valeurs par défaut à ces paramètres) ; le premier paramètre est particulier : ce sera toujours le mot-clé self : ce mot-clef désigne l’instance qui est en train d’être définie au moment où cette fonction s’exécute.\n\n\n\n\n\n\nRemarque\n\n\n\nIl est d’usage, et recommandé, de nommer une classe par un nom commençant par une majuscule.\n\n\nObservons les lignes suivantes dans la console Python :\n&gt;&gt;&gt; rec1 = Rectangle()\n&gt;&gt;&gt; rec2=Rectangle(15, 25)\n&gt;&gt;&gt; rec1.largeur\n2\n&gt;&gt;&gt; rec2.largeur\n15\nrec1 est une instance de l’objet Rectangle. Aucun paramètre n’étant donné lors de sa création, les valeurs par défaut ont été appliquées. rec2 est une autre instance de l’objet Rectangle pour laquelle on a défini les attributs d’instance largeur et hauteur. On accède à ces attributs par la notation pointée."
  },
  {
    "objectID": "01-langagesProgr/POO_cours.html#méthodes",
    "href": "01-langagesProgr/POO_cours.html#méthodes",
    "title": "Programmation orientée objets (Cours)",
    "section": "Méthodes",
    "text": "Méthodes\nUne méthode, c’est ce qui permet à une instance de réaliser des actions. Techniquement se sont des fonctions définies dans le corps de la classe, et qui prennent toujours au moins un premier paramètre qui est self.\nCertaines méthodes sont particulières, leurs noms commencent par un double undescore (le caractère _). On a vu une première de ces méthodes : l’initialiseur __init__.\nDéfinissons ici une méthode permettant de calculer le périmètre d’un rectangle et une autre pour l’aire :\nclass Rectangle:\n    \"\"\"Représente un rectangle\"\"\"\n\n    def __init__(self, largeur=2, hauteur=3):\n        self.largeur = largeur\n        self.hauteur = hauteur\n\n    def perimetre(self):\n        \"\"\"Retourne le périmètre\"\"\"\n        return 2 * (self.largeur + self.hauteur)\n\n    def aire(self):\n        \"\"\"Retourne l'aire\"\"\"\n        return self.largeur * self.hauteur\nUtilisation :\n&gt;&gt;&gt; rec = Rectangle(10, 5)\n&gt;&gt;&gt; rec.perimetre()\n30\n&gt;&gt;&gt; rec.aire()\n50\nUne méthode peut modifier la valeur d’un attribut. Définissons par exemple une méthode permettant de doubler la largeur d’un rectangle.\ndef double_largeur(self):\n    \"\"\"Double la largeur du rectangle)\"\"\"\n    self.largeur *= 2\n&gt;&gt;&gt; rec = Rectangle(10, 5)\n&gt;&gt;&gt; rec.double_largeur()\n&gt;&gt;&gt; rec.largeur\n20\nLa POO encourage à n’exposer que des méthodes vers l’extérieur (on parle d’interface) en masquant les attributs. Il s’agit d’un des quatre éléments constitutifs de l’orienté objet : l’encapsulation.\n\n\n\n\n\n\nRemarque\n\n\n\nNous avons présenté ci-dessus les attributs d’instance, mais il est aussi possible de définir des attributs de classe qui seront donc les mêmes pour toutes les instances d’une même classe créées dans un programme. Ces attributs sont définis à l’intérieur de la classe, sans le préfixe self (puisque celui-ci fait référence à l’instance en train d’être créée).\nPar exemple, dans la définition de la classe Atome ci-dessous, la liste table est un attribut de classe, alors que l’entier np est un attribut d’instance. Dans la méthode __init__, on accède à l’attribut de classe en le préfixant par le nom de la classe Atome.table et on accède à l’attribut d’instance en le préfixant par le nom de l’instance self.np.\nclass Atome:\n\"\"\"atomes simplifiés, choisis parmi les 10 premiers éléments du TP\"\"\"\ntable = [None, ('hydrogène', 0), ('hélium', 2), ('lithium', 4), ('béryllium', 5),\n            ('bore', 6), ('carbone', 6), ('azote', 7), ('oxygène', 8), ('fluor', 10), ('néon', 10)]\n\ndef __init__(self, nat):\n    \"le n° atomique détermine le n. de protons, d'électrons et de neutrons\"\n    self.np, self.ne = nat, nat  # nat = numéro atomique\n    self.nn = Atome.table[nat][1]\n\ndef affiche(self):\n    print()\n    print(\"Nom de l'élément :\", Atome.table[self.np][0])\n    print(f\"{self.np} protons, {self.ne} électrons, {self.nn} neutrons\")\nDe la même façon, il est possible de définir des méthodes de classe."
  },
  {
    "objectID": "01-langagesProgr/POO_cours.html#représentation-simplifiée-dune-classe",
    "href": "01-langagesProgr/POO_cours.html#représentation-simplifiée-dune-classe",
    "title": "Programmation orientée objets (Cours)",
    "section": "Représentation simplifiée d’une classe",
    "text": "Représentation simplifiée d’une classe\nLorsqu’un module comportant plusieurs définitions de classe est développé, on peut réaliser une représentation graphique, appelée diagramme de classes qui permet de visualiser le nom de chaque classe, son interface (c’est-à-dire l’ensemble de ses attributs et méthodes publiques) et les relations éventuelles entre les différentes classes.\nUne présentation détaillée de ce type de diagramme n’est pas au programme, mais de manière simplifiée, le diagramme correspondant à la classe Rectangle pourrait ressembler à ce qui suit :\n\n\n\nDiagramme de classe\n\n\nDans des cases séparées, on place d’abord le nom de la classe, puis ses attributs et enfin ses méthodes. Un codage spécifique permet de préciser le type des différents membres, leur caractère public ou privé (voir les compléments à ce sujet) ou même leur état.\nUn attribut de classe ou une méthode de classe seront soulignés dans un tel diagramme.\nPour en savoir un peu plus sur les diagrammes de classes, je vous conseille ce document ou encore ce cours plus difficile.\n\nDes compléments sur la POO sont proposés à la suite de ce cours."
  },
  {
    "objectID": "01-langagesProgr/POO_exercices.html",
    "href": "01-langagesProgr/POO_exercices.html",
    "title": "Programmation orientée objets (Exercices)",
    "section": "",
    "text": "Les exercices précédés du symbole  sont à faire sur machine, en sauvegardant le fichier si nécessaire.\nLes exercices précédés du symbole  doivent être résolus par écrit."
  },
  {
    "objectID": "01-langagesProgr/POO_exercices.html#exercice-1",
    "href": "01-langagesProgr/POO_exercices.html#exercice-1",
    "title": "Programmation orientée objets (Exercices)",
    "section": " Exercice 1",
    "text": "Exercice 1\nOn considère la classe suivante :\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def deplace(self, dx, dy):\n        self.x = self.x + dx\n        self.y = self.y + dy\n\n    def symetrique(self):\n        return Point(-self.x, -self.y)\n\n    def __repr__(self):\n        return f\"Point({self.x}, {self.y})\"\n\nQuelle instruction entrer dans la console pour créer le point a d’abscisse 2 et d’ordonnée 4 ?\nQuels sont les attributs et les méthodes de cette classe ? Dresser le diagramme de classe de cette classe.\nLa méthode spéciale __repr__ permet de définir comment l’objet sera affiché dans la console Python.\nQu’affichent les instructions suivantes dont la sortie a été effacée ?\n&gt;&gt;&gt; b = Point(1, 2)\n&gt;&gt;&gt; b\n...\n&gt;&gt;&gt; b.deplace(3, 5)\n&gt;&gt;&gt; b\n...\nDéfinir une méthode abscisse qui renvoie l’abscisse du point.\nRecommencer avec la méthode ordonnee."
  },
  {
    "objectID": "01-langagesProgr/POO_exercices.html#exercice-2",
    "href": "01-langagesProgr/POO_exercices.html#exercice-2",
    "title": "Programmation orientée objets (Exercices)",
    "section": " Exercice 2",
    "text": "Exercice 2\nSoit la classe Date définie par le diagramme de classe (Figure 1).\n\n\n\nFigure 1: Diagramme de classe de la classe Date\n\n\n\nImplémenter cette classe en Python.\nCréer deux dates le 20 janvier 2012 et le 14 février 2022.\nDans la méthode d’initialisation d’instance de la classe, prévoir un dispositif pour éviter les dates impossibles (du genre 32/14/2020). Dans ce cas, la création doit provoquer une erreur, chose possible grâce à l’instruction raise (documentation à rechercher !).\nAjouter une méthode __repr__ et une méthode __str__permettant d’afficher la date sous la forme “25 janvier 1989”. Les noms des mois seront définis en tant qu’attribut de classe à l’aide d’une liste.\nAjouter une méthode __lt__ qui permet de comparer deux dates. L’expression d1 &lt; d2 (d1 et d2 étant deux objets de type Date) doit grâce à cette méthode renvoyer True ou False ."
  },
  {
    "objectID": "01-langagesProgr/POO_exercices.html#exercice-3-bac-2022-extrait",
    "href": "01-langagesProgr/POO_exercices.html#exercice-3-bac-2022-extrait",
    "title": "Programmation orientée objets (Exercices)",
    "section": " Exercice 3 (Bac 2022, extrait)",
    "text": "Exercice 3 (Bac 2022, extrait)\nSimon souhaite créer en Python le jeu de cartes « la bataille » pour deux joueurs. Les questions qui suivent demandent de reprogrammer quelques fonctions du jeu. On rappelle ici les règles du jeu de la bataille :\nPréparation :\n\nDistribuer toutes les cartes aux deux joueurs.\nLes joueurs ne prennent pas connaissance de leurs cartes et les laissent en tas face cachée devant eux.\n\nDéroulement :\n\nÀ chaque tour, chaque joueur dévoile la carte du haut de son tas.\nLe joueur qui présente la carte ayant la plus haute valeur emporte les deux cartes qu’il place sous son tas.\nLes valeurs des cartes sont : dans l’ordre de la plus forte à la plus faible : As, Roi, Dame, Valet, 10, 9, 8, 7, 6, 5, 4, 3 et 2 (la plus faible).\n\nSi deux cartes sont de même valeur, il y a “bataille”.\n\nChaque joueur pose alors une carte face cachée, suivie d’une carte face visible sur la carte dévoilée précédemment.\nOn recommence l’opération s’il y a de nouveau une bataille sinon, le joueur ayant la valeur la plus forte emporte tout le tas.\n\nLorsque l’un des joueurs possède toutes les cartes du jeu, la partie s’arrête et ce dernier gagne.\nPour cela Simon crée une classe Python Carte. Chaque instance de la classe a deux attributs : un pour sa valeur et un pour sa couleur. Il donne au valet la valeur 11, à la dame la valeur 12, au roi la valeur 13 et à l’as la valeur 14. La couleur est une chaîne de caractères: “trefle”, “carreau”, “coeur” ou “pique”.\nSimon a écrit la classe Python Carte suivante, ayant deux attributs valeur et couleur, et dont le constructeur prend deux arguments: val et coul.\n\nRecopier et compléter les pointillés des lignes ci-dessous.\nclass Carte:\n    def __init__(self, val, coul):\n        ... .valeur = ...\n        ... . ... = coul\nParmi les propositions ci-dessous quelle instruction permet de créer l’objet « 7 de cœur » sous le nom c7 ?\n\nc7. init (self, 7, \"coeur\")\nc7 = Carte(self, 7, \"coeur\")\nc7 = Carte ( 7, \"coeur\")\nfrom Carte import 7, \"coeur\"\n\nOn souhaite créer le jeu de cartes. Pour cela, on écrit une fonction initialiser() :\n\nsans paramètre\nqui renvoie une liste de 52 objets de la classe Carte représentant les 52 cartes du jeu.\n\nVoici une proposition de code. Recopier et compléter les lignes suivantes pour que la fonction réponde à la demande :\ndef initialiser() :\n    jeu = [] \n    for c in [\"coeur\", \"carreau\", \"trefle\", \"pique\"]:\n        for v in range( ... ) :\n            carte_cree = ...\n            jeu.append(carte_cree)\n    return jeu\nÉcrire une fonction comparer(cartel, carte2) qui prend en paramètres deux objets de la classe Carte. Cette fonction renvoie :\n\n0 si la force des deux cartes est identique,\n1 si la carte cartel est strictement plus forte que carte2\n-1 si la carte carte2 est strictement plus forte que cartel\n\n\nVoir le corrigé"
  },
  {
    "objectID": "01-langagesProgr/POO_exercices.html#exercice-4-bac-2022",
    "href": "01-langagesProgr/POO_exercices.html#exercice-4-bac-2022",
    "title": "Programmation orientée objets (Exercices)",
    "section": " Exercice 4 (Bac 2022)",
    "text": "Exercice 4 (Bac 2022)\nUn fabricant de brioches décide d’informatiser sa gestion des stocks. Il écrit pour cela un programme en langage Python. Une partie de son travail consiste à développer une classe Stock dont la première version est la suivante :\nclass Stock:\n    def __init__(self):\n        self.qt_farine = 0 # quantité de farine initialisée à 0 g\n        self.nb_oeufs = 0 # nombre d’œufs (0 à l’initialisation)\n        self.qt_beurre = 0 # quantité de beurre initialisée à 0 g\n\nÉcrire une méthode ajouter_beurre(self, qt) qui ajoute la quantité qt de beurre à un objet de la classe Stock.\nOn admet que l’on a écrit deux autres méthodes ajouter_farine et ajouter_oeufs qui ont des fonctionnements analogues.\nÉcrire une méthode afficher(self) qui affiche la quantité de farine, d’œufs et de beurre d’un objet de type Stock. L’exemple ci-dessous illustre l’exécution de cette méthode dans la console :\n&gt;&gt;&gt; mon_stock = Stock() \n&gt;&gt;&gt; mon_stock.afficher() \nfarine: 0 \noeuf: 0 \nbeurre: 0 \n&gt;&gt;&gt; mon_stock.ajouter_beurre(560) \n&gt;&gt;&gt; mon_stock.afficher() \nfarine: 0 \noeuf: 0 \nbeurre: 560 \nPour faire une brioche, il faut 350 g de farine, 175 g de beurre et 4 oeufs. Écrire une méthode stock_suffisant_brioche(self) qui renvoie un booléen : VRAI s’il y a assez d’ingrédients dans le stock pour faire une brioche et FAUX sinon.\nOn considère la méthode supplémentaire produire(self) de la classe Stock donnée par le code suivant :\ndef produire(self):\n    res = 0 \n    while self.stock_suffisant_brioche():\n        self.qt_beurre = self.qt_beurre - 175 \n        self.qt_farine = self.qt_farine - 350 \n        self.nb_oeufs = self.nb_oeufs - 4 \n        res = res + 1\n    return res\nOn considère un stock défini par les instructions suivantes :\n&gt;&gt;&gt; mon_stock=Stock()\n&gt;&gt;&gt; mon_stock.ajouter_beurre(1000) \n&gt;&gt;&gt; mon_stock.ajouter_farine(1000) \n&gt;&gt;&gt; mon_stock.ajouter_oeufs(10)\n\nOn exécute ensuite l’instruction : &gt;&gt;&gt; mon_stock.produire(). Quelle valeur s’affiche dans la console ? Que représente cette valeur ?\nOn exécute ensuite l’instruction : &gt;&gt;&gt; mon_stock.afficher(). Que s’affiche-t-il dans la console ?\n\nL’industriel possède n lieux de production distincts et donc n stocks distincts.\nOn suppose que ces stocks sont dans une liste dont chaque élément est un objet de type Stock. Écrire une fonction Python nb_brioches(liste_stocks) possédant pour unique paramètre la liste des stocks et qui renvoie le nombre total de brioches produites.\n\nVoir le corrigé"
  },
  {
    "objectID": "01-langagesProgr/recursivite_cours.html",
    "href": "01-langagesProgr/recursivite_cours.html",
    "title": "Récursivité (Cours)",
    "section": "",
    "text": "Un algorithme est dit récursif s’il s’appelle lui-même directement ou indirectement via l’appel d’une ou de plusieurs autres fonctions qui elles-mêmes finissent par l’appeler.\nLa récursivité est un concept fondamental en informatique qui met naturellement en pratique un mode de pensée puissant qui consiste à pouvoir découper la tâche à réaliser en sous-tâches de mêmes natures mais plus petites qui finalement sont simples à résoudre.\nPrenons par exemple le calcul de la factorielle d’un nombre entier \\(n\\). Par définition pour un \\(n\\) entier strictement positif, \\(n!\\) est égale au produit des entiers strictement positifs inférieurs à \\(n\\). Par convention on a aussi \\(0! = 1\\).\nPar exemple, on a : \\(5!=1\\times 2\\times 3\\times 4\\times 5 = 120\\).\nDonnons le code itératif d’une fonction calculant la factorielle:\n  def fact(n):\n    \"\"\"Renvoie la factorielle de n.\"\"\"\n    res = 1\n    for i in range(1,n+1):\n      res = res * i  \n    return res\nLa définition récursive se base sur le fait que \\(n! = n\\times (n-1)!\\) pour tout \\(n&gt;0\\).\nOn obtient le code:\n  def fact(n):\n    \"\"\"Renvoie la factorielle de n (méthode récursive).\"\"\"\n    if n == 0:\n      res = 1\n    else:\n      res = n*fact(n-1)\n    return res\nPour commencer à comprendre comment fonctionne cette fonction récursive, nous pouvons visualiser le calcul de fact(4) grâce à l’outil Python Tutor ci-dessous."
  },
  {
    "objectID": "01-langagesProgr/recursivite_cours.html#motivation-et-introduction-du-concept",
    "href": "01-langagesProgr/recursivite_cours.html#motivation-et-introduction-du-concept",
    "title": "Récursivité (Cours)",
    "section": "",
    "text": "Un algorithme est dit récursif s’il s’appelle lui-même directement ou indirectement via l’appel d’une ou de plusieurs autres fonctions qui elles-mêmes finissent par l’appeler.\nLa récursivité est un concept fondamental en informatique qui met naturellement en pratique un mode de pensée puissant qui consiste à pouvoir découper la tâche à réaliser en sous-tâches de mêmes natures mais plus petites qui finalement sont simples à résoudre.\nPrenons par exemple le calcul de la factorielle d’un nombre entier \\(n\\). Par définition pour un \\(n\\) entier strictement positif, \\(n!\\) est égale au produit des entiers strictement positifs inférieurs à \\(n\\). Par convention on a aussi \\(0! = 1\\).\nPar exemple, on a : \\(5!=1\\times 2\\times 3\\times 4\\times 5 = 120\\).\nDonnons le code itératif d’une fonction calculant la factorielle:\n  def fact(n):\n    \"\"\"Renvoie la factorielle de n.\"\"\"\n    res = 1\n    for i in range(1,n+1):\n      res = res * i  \n    return res\nLa définition récursive se base sur le fait que \\(n! = n\\times (n-1)!\\) pour tout \\(n&gt;0\\).\nOn obtient le code:\n  def fact(n):\n    \"\"\"Renvoie la factorielle de n (méthode récursive).\"\"\"\n    if n == 0:\n      res = 1\n    else:\n      res = n*fact(n-1)\n    return res\nPour commencer à comprendre comment fonctionne cette fonction récursive, nous pouvons visualiser le calcul de fact(4) grâce à l’outil Python Tutor ci-dessous."
  },
  {
    "objectID": "01-langagesProgr/recursivite_cours.html#mécanisme",
    "href": "01-langagesProgr/recursivite_cours.html#mécanisme",
    "title": "Récursivité (Cours)",
    "section": "2. Mécanisme",
    "text": "2. Mécanisme\nConsidérons la fonction foo ci-dessous :\ndef foo(n):\n    if n == 0:\n        print(\"Cas de base : \", n)\n    else:\n        print(\"Début avec n = \" , n)\n        foo(n-1)\n        print(\"Fin avec n = \" , n)\n\n\nfoo(3)\nCe programme génère la sortie suivante :\nDébut avec n =  3\nDébut avec n =  2\nDébut avec n =  1\nCas de base :  0\nFin avec n =  1\nFin avec n =  2\nFin avec n =  3\nL’observation de ces résultats permet de comprendre que le système, lors de l’exécution de ce programme, utilise une pile d’exécution. Une pile d’exécution permet d’enregistrer des informations sur les fonctions en cours d’exécution dans un programme. On parle de pile, car les exécutions successives “s’empilent” les unes sur les autres, comme une pile d’assiettes, ou de crêpes. Si nous nous intéressons à la pile d’exécution du programme étudié ci-dessus, nous obtenons le schéma suivant :\n\n\n\nPile d’exécution\n\n\nIl est important de bien comprendre que la fonction située au sommet de la pile d’exécution est en cours d’exécution. Toutes les fonctions situées “en dessous” sont mises en pause jusqu’au moment où elles se retrouveront au sommet de la pile. Quand une fonction termine son exécution, elle est automatiquement retirée du sommet de la pile (on dit que la fonction est dépilée).\nLa pile d’exécution permet de retenir la prochaine instruction à exécuter au moment où une fonction sera sortie de son “état de pause” (qu’elle se retrouvera au sommet de la pile d’exécution). Elle enregistre aussi le contexte, c’est-à-dire par exemple ici la valeur de la variable locale \\(n\\) associée à chaque appel de la fonction.\nNous pouvons comprendre que ce sont plusieurs copies (on dira plutôt des instances) de la fonction foo qui sont présentent dans la pile, chacune ayant son propre espace de noms : la variable \\(n\\) de la fonction située en haut de la pile n’est pas la même que la variable \\(n\\) de la fonction située en-dessous.\n\n\n\n\n\n\nLimitation propre à Python\n\n\n\nLe langage Python limite à 1000 le nombre d’appels récursifs d’une fonction, autrement dit la hauteur de la pile.\nRecursionError: maximum recursion depth exceeded while calling a Python object"
  },
  {
    "objectID": "01-langagesProgr/recursivite_cours.html#écrire-un-algorithme-récursif",
    "href": "01-langagesProgr/recursivite_cours.html#écrire-un-algorithme-récursif",
    "title": "Récursivité (Cours)",
    "section": "3. Écrire un algorithme récursif",
    "text": "3. Écrire un algorithme récursif\nLors de l’écriture d’un algorithme récursif, trois règles doivent toujours être vérifiées :\n\n\n\n\n\n\nLes trois règles de récursivité\n\n\n\n\nLa fonction s’appelle elle-même !\nLa fonction comporte un “cas de base” qui correspond à une condition d’arrêt.\nL’algorithme conduit vers le cas de base : il n’y a pas une infinité d’appels récursifs.\n\n\n\nLa troisième règle est assurée par la preuve de terminaison qui se fait souvent en identifiant la construction d’une suite strictement décroissante d’entiers positifs ou nuls."
  },
  {
    "objectID": "01-langagesProgr/recursivite_cours.html#fonction-récursive-et-fonction-itérative",
    "href": "01-langagesProgr/recursivite_cours.html#fonction-récursive-et-fonction-itérative",
    "title": "Récursivité (Cours)",
    "section": "4. Fonction récursive et fonction itérative",
    "text": "4. Fonction récursive et fonction itérative\nLa programmation récursive n’est ni meilleure, ni pire que, la programmation itérative. Toute fonction récursive peut aussi être programmée de façon itérative. Cependant, en cas de nombreux appels récursifs, la mémoire de la machine sera trop fortement sollicitée et l’exécution ralentie, voire impossible.\nLe choix entre une solution récursive ou une solution itérative est donc guidé par le type de problème à résoudre car certains problèmes s’écrivent naturellement de façon récursive."
  },
  {
    "objectID": "01-langagesProgr/recursivite_exercices.html",
    "href": "01-langagesProgr/recursivite_exercices.html",
    "title": "Récursivité (Exercices)",
    "section": "",
    "text": "Les exercices précédés du symbole  sont à faire sur machine, en sauvegardant le fichier si nécessaire.\nLes exercices précédés du symbole  doivent être résolus par écrit."
  },
  {
    "objectID": "01-langagesProgr/recursivite_exercices.html#exercice-1-factorielle",
    "href": "01-langagesProgr/recursivite_exercices.html#exercice-1-factorielle",
    "title": "Récursivité (Exercices)",
    "section": " Exercice 1 : factorielle",
    "text": "Exercice 1 : factorielle\nOn rappelle l’exemple du premier paragraphe du cours concernant le calcul de la factorielle \\(n!=1\\times 2\\times 3\\times\\ldots\\times n\\) d’un entier naturel \\(n\\), dans sa version récursive.\n  def fact(n):\n    \"\"\"Renvoie la factorielle de n (méthode récursive).\"\"\"\n    if n == 0:\n      res = 1\n    else:\n      res = n*fact(n-1)\n    return res\n\nDans cette fonction, quel est le cas de base ?\nDémontrer que l’algorithme se termine (preuve de terminaison) dès lors que l’argument \\(n\\) donné initialement est un entier naturel.\nQue se passe-t-il si on appelle la fonction fact avec \\(n=-2\\) ? Proposer une modification de la fonction pour traiter ce type de cas.\nPour démontrer que cet algorithme renvoie bien \\(n!\\) lorsque \\(n\\) est un entier naturel, on peut procéder par un raisonnement par récurrence.\n\nCas de base : pour \\(n=0\\), la fonction renvoie-t-elle \\(0!\\) ?\nHypothèse : on suppose que, pour une certaine valeur de l’entier naturel non nul \\(n\\), fact(n-1) renvoie \\((n-1)!\\). Montrer que, sous cette hypothèse, fac(n) renvoie bien \\(n!\\).\nConclusion : en déduire que fac(n) renvoie \\(n!\\) pour tout entier naturel \\(n\\).\n\nPour évaluer la complexité de cet algorithme, nous allons compter le nombre de multiplications et de comparaisons effectuées. Démontrer, à l’aide d’un raisonnement pas récurrence, que la complexité de cet algorithme est en \\(\\mathcal{O}(n)\\).\n\n\n\n\n\n\n\nÀ retenir …\n\n\n\n\nLe principe de la preuve de terminaison.\nLe principe du raisonnement pas récurrence"
  },
  {
    "objectID": "01-langagesProgr/recursivite_exercices.html#exercice-2-suite-de-fibonacci",
    "href": "01-langagesProgr/recursivite_exercices.html#exercice-2-suite-de-fibonacci",
    "title": "Récursivité (Exercices)",
    "section": "  Exercice 2 : suite de Fibonacci",
    "text": "Exercice 2 : suite de Fibonacci\nLa suite de Fibonacci est une suite de nombres entiers notés \\(F_n\\), définie par \\(F_0=0\\), \\(F_1=1\\) et dans laquelle chaque terme est égal à la somme des deux termes qui le précèdent.\n\nCalculer \\(F_n\\) à la main pour les valeurs de \\(n\\) allant de 2 jusqu’à 5.\nRecopier et compléter le code de la fonction fibo_iter qui retourne \\(F_n\\) en utilisant un algorithme itératif.\ndef fibo_iter(n: int) -&gt; int:\n    \"\"\"Suite de Fibonacci, version itérative\"\"\"\n    if n == 0:\n        return 0\n    else:\n        f0, f1 = 0, 1\n        for k in range(1, n):\n            f0, f1 = ...  # Ligne à compléter ...\n        return f1\n\n\nfor k in range(10):\n    print(fibo_iter(k))\nÉvaluer la complexité en termes de nombre d’additions.\nD’après la définition de la suite, on a, pour tout entier naturel \\(n\\geqslant 2\\) :\n\\[F_{n}=F_{n-2}+F_{n-1}\\]\nEn déduire une version récursive de l’algorithme de calcul de \\(F_n\\). Cet algorithme a ceci de particulier que chaque fonction procède à deux appels récursifs. On pourra recopier et compléter le code ci-dessous.\ndef fibo_rec(n: int) -&gt; int:\n    \"\"\"Suite de Fibonacci version récursive\"\"\"\n    # Cas de base\n    if ...:\n        return n\n    # Récursion\n    else:\n        return ...\n\n\nfor k in range(10):\n    print(fibo_rec(k))\nUtiliser chacune des deux versions pour calculer la valeur de \\(F_{50}\\). Que constate-t-on ? Expliquer.\n\n\n\n\n\n\n\nRemarques et compléments\n\n\n\n\n\nLa version récursive se révèle beaucoup moins efficace. Pour comprendre pourquoi, nous pouvons représenter par un arbre les appels récursifs nécessaires.\n\n\n\n\n\nOn retrouve les cas de base dans les feuilles de l’arbre. Nous pouvons constater que le nombre d’appels récursifs est très grand. Il est possible de démontrer que ce nombre augmente de façon exponentielle. Pour calculer \\(F_{100}\\), il y aurait environ \\(10^{20}\\) opérations. À raison de \\(10^9\\) opérations par seconde, la calcul prendra de l’ordre de \\(10^{11}\\) secondes, soit environ 3 000 ans !\nUn autre constat qui montre l’inefficacité de ce programme : plusieurs calculs identiques sont répétés plusieurs fois. On calcule par exemple \\(F_3\\) deux fois et \\(F_2\\) trois fois. Une solution meilleure serait de garder en mémoire les éléments déjà calculés et de ne calculer que les nouveaux éléments encore jamais rencontrés. Une telle démarche relève de la programmation dynamique qui sera abordée en fin d’année.\nPour satisfaire votre curiosité insatiable, vous pouvez déjà observer et tester le programme ci-dessous :\ndef fibo_dyn(n: int, suite: dict = {0: 0, 1: 1}) -&gt; int:\n    \"\"\"Suite de Fibonacci version dynamique\"\"\"\n    # Cas de base\n    if n == 0 or n == 1:\n        return n\n    # Récursion\n    else:\n        # Si Fn est déjà calculé, on le retourne\n        if n in suite.keys():\n            return suite[n]\n        else:\n            # Sinon, on le calcule et on le garde en mémoire\n            f = fibo_dyn(n-2, suite) + fibo_dyn(n-1, suite)\n            suite[n] = f\n            return f\n\n\nfor k in range(10):\n    print(fibo_dyn(k))\nUne exécution dans PythonTutor est instructive :\n\n\nVoir cet article du blog qui explique comment visualiser le temps d’exécution d’une fonction."
  },
  {
    "objectID": "01-langagesProgr/recursivite_exercices.html#exercice-3-calcul-de-xn",
    "href": "01-langagesProgr/recursivite_exercices.html#exercice-3-calcul-de-xn",
    "title": "Récursivité (Exercices)",
    "section": "  Exercice 3 : calcul de \\(x^n\\)",
    "text": "Exercice 3 : calcul de \\(x^n\\)\nPour tout nombre réel \\(x\\) et tout entier naturel \\(n\\), \\(x^n\\) est défini par \\(x^0=1\\) et, pour \\(n&gt;0\\), \\(x^n=x\\times x\\times x\\times \\ldots \\times x\\) : produit de \\(n\\) facteurs tous égaux à \\(x\\).\nLes règles de calcul sur les exposants permettent d’affirmer que, pour \\(n&gt;0\\), \\(x^n=x\\times x^{n-1}\\).\n\nÉcrire la fonction récursive puissance(x,n) qui calcule le nombre \\(x^n\\) pour tout entier naturel \\(n\\).\nDessiner l’arbre d’appels de cette fonction pour \\(x=3\\) et \\(n=5\\).\nPour les plus rapides\n\n\n\n\n\n\n\nQuestion bonus\n\n\n\nUn autre méthode de calcul de \\(x^n\\) consiste à distinguer le cas où \\(n\\) est pair et celui où \\(n\\) est impair :\n\nsi \\(n=0\\), alors \\(x^n=1\\) ;\nsi \\(n\\) est pair, alors \\(x^n=\\left(x^{n/2}\\right)^2\\) ;\nsi \\(n\\) est impair, alors \\(x^n=x\\times\\left(x^{(n-1)/2}\\right)^2\\).\n\nL’algorithme qui découle de cette définition porte également le nom d’exponentiation rapide. Comme son nom l’indique, il s’agit d’un algorithme particulièrement efficace pour calculer rapidement de grandes puissances entières.\nÉcrire la fonction récursive puissancev2(x,n) qui calcule le nombre \\(x^n\\) pour tout entier naturel n selon la méthode d’exponentiation rapide."
  },
  {
    "objectID": "01-langagesProgr/recursivite_exercices.html#exercice-4-maximum-dune-liste",
    "href": "01-langagesProgr/recursivite_exercices.html#exercice-4-maximum-dune-liste",
    "title": "Récursivité (Exercices)",
    "section": " Exercice 4 : maximum d’une liste",
    "text": "Exercice 4 : maximum d’une liste\nOn considère le programme ci-dessous :\ndef maximum(a, b):\n    if a &gt; b:\n        return a\n    else:\n        return b\n\ndef maximum_tab(tab):\n    if len(tab) == 1:\n        return tab[0]\n    else:\n        return maximum(tab[0], maximum_tab(tab[1:]))\n\nfrom random import randint\n\nmon_tab = []\nfor i in range(20):\n    mon_tab.append(randint(-100, 100))\nprint(mon_tab)\nprint(maximum_tab(mon_tab))\n\nDécrire, en langage usuel, le principe de fonctionnement de la fonction maximum_tab.\nExpliquer en quoi la fonction maximum_tab est récursive. Quel est le cas de base ?\nProuver la terminaison de cette fonction.\nEffectuer par récurrence la preuve de cet algorithme (c’est-à-dire prouver que la fonction retourne bien le maximum du tableau donné en argument).\nDessiner l’arbre d’appels de cette fonction pour l’appel maximum_tab([-4,55,-1,-35,-52,31])."
  },
  {
    "objectID": "01-langagesProgr/recursivite_exercices.html#exercice-5-palindromes",
    "href": "01-langagesProgr/recursivite_exercices.html#exercice-5-palindromes",
    "title": "Récursivité (Exercices)",
    "section": " Exercice 5 : palindromes",
    "text": "Exercice 5 : palindromes\nOn appelle palindrome un mot qui se lit dans les deux sens comme « été » ou « radar ».\nÉcrire une fonction récursive palindrome qui teste si un mot est un palindrome.\n\nEntrée : Un mot (type str).\nSortie : Un booléen égal à True si le mot est un palindrome, False sinon.\n\nOn considérera les deux cas suivant comme cas de base :\n\nsi le mot est la chaîne vide, c’est un palindrome ;\nsi le mot ne contient qu’une seule lettre, c’est un palindrome"
  },
  {
    "objectID": "01-langagesProgr/recursivite_exercices.html#exercice-6-flocon-de-von-koch",
    "href": "01-langagesProgr/recursivite_exercices.html#exercice-6-flocon-de-von-koch",
    "title": "Récursivité (Exercices)",
    "section": "  Exercice 6 : flocon de von Koch",
    "text": "Exercice 6 : flocon de von Koch\nUne image qui a une apparence similaire quelle que soit l’échelle à laquelle on l’observe est appelée une fractale (il y a d’autres types de fractales).\nUn exemple simple de fractale est le flocon de Von Koch, dont voici une représentation (pour un degré 4).\n\n\n\nFlocon de von Koch\n\n\nOn peut la créer à partir d’un segment de droite, en modifiant récursivement chaque segment de droite de la façon suivante :\n\non divise le segment de droite en trois segments de longueurs égales ;\non construit un triangle équilatéral ayant pour base le segment médian de la première étape ;\non supprime le segment de droite qui était la base du triangle de la deuxième étape.\n\nVoici le résultat obtenu en une étape :\n\n\n\nÉtape de construction\n\n\nPour continuer, il suffit de considérer chaque segment de cette dernière figure comme segment de départ.\nfrom turtle import *\n\n\ndef Koch(n, d):\n    if n == 0:\n        forward(d)\n    else:\n        Koch(n-1, d/3)\n        left(60)\n        Koch(n-1, d/3)\n        right(120)\n        Koch(n-1, d/3)\n        left(60)\n        Koch(n-1, d/3)\n    return None\n\n\ndef flocon(n, d):\n    for k in range(3):\n        Koch(n, d)\n        right(120)\n    return None\n\n\nflocon(4, 300)\nexitonclick()\n\nIdentifier le cas de base de la fonction récursive Koch(n, d). Que fait-il ?\nModifier les paramètres n et d lors de l’appel à la fonction flocon et observer l’impact de ces modifications sur le dessin.\nCombien d’appels récursifs sont-ils réalisés lors de l’appel de la fonction Koch(4, 300) ?"
  },
  {
    "objectID": "01-langagesProgr/recursivite_exercices.html#exercice-7-type-bac",
    "href": "01-langagesProgr/recursivite_exercices.html#exercice-7-type-bac",
    "title": "Récursivité (Exercices)",
    "section": " Exercice 7 (type bac)",
    "text": "Exercice 7 (type bac)"
  },
  {
    "objectID": "01-langagesProgr/TPHanoi.html",
    "href": "01-langagesProgr/TPHanoi.html",
    "title": "TP Tours de Hanoï",
    "section": "",
    "text": "Dans ce TP, vous mettrez en œuvre une procédure récursive afin de résoudre le célèbre problème des tours de Hanoï.\n\n\n\n\n\n\nObjectifs\n\n\n\n\nComprendre un algorithme.\nÉcrire une procédure récursive.\nCalculer une complexité.\n\n\n\nL’énoncé au format PDF est disponible ci-dessous.\n\n\n\n\n\n\nCritères d’évaluation\n\n\n\n\nReprésentation correcte des solutions “à la main”.\nLa procédure résout le problème.\nLa procédure fournit l’affichage demandé.\nJustification correcte du calcul de complexité (en nombre de déplacements)."
  },
  {
    "objectID": "01-langagesProgr/TPPOOBataille.html",
    "href": "01-langagesProgr/TPPOOBataille.html",
    "title": "TP - Bataille",
    "section": "",
    "text": "TP : le jeu de la bataille\nDans ce TP, vous mettrez en œuvre la POO pour créer un programme qui joue à la bataille.\n\n\n\nJeu de carte\n\n\n\n\n\n\n\n\nObjectifs\n\n\n\n\nDéfinir une classe et ses membres.\nUtiliser des objets, leurs attributs, leurs méthodes.\nRépondre à un cahier des charges.\n\n\n\nL’énoncé au format PDF est disponible ci-dessous.\n\n\n\n\n\n\nCritères d’évaluation\n\n\n\n\nRespect du cahier de charges.\nDocumentation, spécification des méthodes créées.\nLe jeu se déroule sans erreur.\nBonus : tenir compte des compléments sur la POO.\n\n\n\nFichier Python à télécharger et à compléter : bataille_eleves.py"
  },
  {
    "objectID": "02-structures/bilan.html",
    "href": "02-structures/bilan.html",
    "title": "Bilan de la séquence - Structures de données abstraites",
    "section": "",
    "text": "Cours :\n\nInterfaces et implémentation. : savoir différencier un type abstrait de données et un de ses implémentations, notion d’interface et d’API.\nListes., Piles. et Files. : connaître pour chacune de ces structures, sa définition, son fonctionnement, ses méthodes primitives et une ou deux implémentations différentes. Connaître des situations typiques d’utilisation de ces structures.\nDictionnaires. : connaître la définition, le fonctionnement et les méthodes primitives associées. En particulier, maîtriser l’utilisation des dictionnaires en Python. Connaître l’avantage des dictionnaires dur les listes en termes de performance.\n\nExercices de base faits et corrigés durant la séquence :\n\nFiche sur les listes, piles et files. : exercices 1, 2, 3, 4, 6, 7.\nFiche sur les dictionnaires. : exercices 1, 2, 3, 4. Correction de l’exercice 4.\n\nProblèmes, T.P. et mini projets étudiés durant la séquence :\n\nParenthésage correct. : exercice 5. Corrigé.\nT.P. Carnet d’adresses sur les dictionnaires. Corrigé.\nProjet détecteur de langue : utilisation de dictionnaires. corrigé.\nNotation polonaise inverse : énoncé et corrigé.\n2021 Métropole Jour 1 : exo 2 : énoncé et corrigé.\n2022 Centres étrangers Jour 1 : exo 1 : énoncé et corrigé.\n2022 Centres étrangers Jour 1 : exo 2 : énoncé et corrigé.\n\nProblèmes supplémentaires tirés des annales :\n\n2021 Centres étrangers Jour 2 : exo 1.\n2021 Centres étrangers Jour 1 : exo 5.\n2021 Amérique du Nord Jour1 : exo 5.\n2021 Sujet zéro : exo 1.\n2022 Métropole Jour 1 : exo 1.\n2022 Métropole Jour 2 : exo 2.\n2022 Mayotte Liban Jour 1 : exo 1.\n2022 Mayotte Liban Jour 2 : exo 1.\n2022 Amérique du Nord Jour 1 : exo 5.\n2022 Centres étrangers Jour 2 : exo 2.\n2021 Centres étrangers Jour 1 : exo 2.\n2021 Métropole Septembre Jour 2 : exo 2."
  },
  {
    "objectID": "02-structures/dictionnaires_cours.html",
    "href": "02-structures/dictionnaires_cours.html",
    "title": "Dictionnaires (Cours)",
    "section": "",
    "text": "Nous allons maintenant étudier un autre type abstrait de données : les dictionnaires aussi appelés tableaux associatifs.\n\n\n\n\n\n\nDéfinition\n\n\n\nUn dictionnaire est une structure de donnée permettant d’indexer des objets par leur nom plutôt que par un nombre.\n\n\nOn retrouve une structure qui ressemble, à première vue, beaucoup à un tableau (à chaque élément on associe un indice de position). Mais au lieu d’associer chaque élément à un indice de position, dans un dictionnaire, on associe chaque élément (on parle de valeur dans un dictionnaire) à une clé, on dit qu’un dictionnaire contient des couples clé:valeur (chaque clé est associée à une valeur).\nUn dictionnaire associe une clé à une valeur. On peut voir les tableaux comme un dictionnaire où les clés sont des entiers allant de 0 à la longueur de la liste moins 1.\nMais cela peut être bien plus général :\n\nles clés peuvent être des mots et les valeurs un nombre. Cela permet par exemple de compter le nombre de fois où un chaque mot d’un texte apparaît.\nassocier un nom (valeur) à un numéro de téléphone (clé) sans avoir besoin d’une liste allant de 0 à numéro max de téléphone.\n\nLes clés ne doivent pas changer une fois créées, sinon la serrure fabriquée dans le dictionnaire ne fonctionne plus. On ne doit donc utiliser que des objets non modifiables pour créer des clés d’un dictionnaire Python. Comme :\n\ndes entiers\ndes réels\ndes chaines de caractères\ndes tuples\n\n\n\n\n\n\n\nExemple\n\n\n\nExemples de couples clé:valeur :\n\nprenom:Kevin, nom:Durand, naissance:17-05-2005.\nprenom, nom et naissance sont des clés ; Kevin, Durand et 17-05-2005 sont des valeurs.\n\n\n\nLes méthodes primitives permettant de définir l’interface de la structure de dictionnaire peuvent être les suivantes :\n\ncréer() : création d’un nouveau dictionnaire vide ;\najouter(dict, clé, valeur) : on associe une nouvelle valeur à une nouvelle clé ;\nmodifier(dict, clé, valeur) : on modifie un couple clé:valeur en remplaçant la valeur courante par une autre valeur (la clé restant identique) ;\nsupprimer(dict, clé) : on supprime une clé (et donc la valeur qui lui est associée) ;\nrechercher(dict, clé) : on recherche une valeur à l’aide de la clé associée à cette valeur.\n\n\n\n\n\n\n\nExemple\n\n\n\nSoit le dictionnaire D composé des couples clé:valeur suivants : prenom:Kevin, nom:Durand, naissance:17-05-2005. Pour chaque exemple ci-dessous on repart du dictionnaire d’origine :\najouter(D, tel, 06060606)\nmodifier(D,nom,Dupont)\nsupprimer(D, naissance)\nrechercher(D, prenom)\n\nLigne 1 : le dictionnaire D est maintenant composé des couples suivants : prenom:Kevin, nom:Durand, date-naissance:17-05-2005, tel:06060606 ;\nLigne 2 : le dictionnaire D est maintenant composé des couples suivants : prenom:Kevin, nom:Dupont, date-naissance:17-05-2005 ;\nLigne 3 : le dictionnaire D est maintenant composé des couples suivants : prenom:Kevin, nom:Durand ;\nLigne 4 : la fonction renvoie Kevin.\n\n\n\nL’utilisation de la structure dictionnaire en Python a été étudiée en première. Il faut donc revoir le cours correspondant."
  },
  {
    "objectID": "02-structures/dictionnaires_cours.html#du-point-de-vue-utilisateur-interface",
    "href": "02-structures/dictionnaires_cours.html#du-point-de-vue-utilisateur-interface",
    "title": "Dictionnaires (Cours)",
    "section": "",
    "text": "Nous allons maintenant étudier un autre type abstrait de données : les dictionnaires aussi appelés tableaux associatifs.\n\n\n\n\n\n\nDéfinition\n\n\n\nUn dictionnaire est une structure de donnée permettant d’indexer des objets par leur nom plutôt que par un nombre.\n\n\nOn retrouve une structure qui ressemble, à première vue, beaucoup à un tableau (à chaque élément on associe un indice de position). Mais au lieu d’associer chaque élément à un indice de position, dans un dictionnaire, on associe chaque élément (on parle de valeur dans un dictionnaire) à une clé, on dit qu’un dictionnaire contient des couples clé:valeur (chaque clé est associée à une valeur).\nUn dictionnaire associe une clé à une valeur. On peut voir les tableaux comme un dictionnaire où les clés sont des entiers allant de 0 à la longueur de la liste moins 1.\nMais cela peut être bien plus général :\n\nles clés peuvent être des mots et les valeurs un nombre. Cela permet par exemple de compter le nombre de fois où un chaque mot d’un texte apparaît.\nassocier un nom (valeur) à un numéro de téléphone (clé) sans avoir besoin d’une liste allant de 0 à numéro max de téléphone.\n\nLes clés ne doivent pas changer une fois créées, sinon la serrure fabriquée dans le dictionnaire ne fonctionne plus. On ne doit donc utiliser que des objets non modifiables pour créer des clés d’un dictionnaire Python. Comme :\n\ndes entiers\ndes réels\ndes chaines de caractères\ndes tuples\n\n\n\n\n\n\n\nExemple\n\n\n\nExemples de couples clé:valeur :\n\nprenom:Kevin, nom:Durand, naissance:17-05-2005.\nprenom, nom et naissance sont des clés ; Kevin, Durand et 17-05-2005 sont des valeurs.\n\n\n\nLes méthodes primitives permettant de définir l’interface de la structure de dictionnaire peuvent être les suivantes :\n\ncréer() : création d’un nouveau dictionnaire vide ;\najouter(dict, clé, valeur) : on associe une nouvelle valeur à une nouvelle clé ;\nmodifier(dict, clé, valeur) : on modifie un couple clé:valeur en remplaçant la valeur courante par une autre valeur (la clé restant identique) ;\nsupprimer(dict, clé) : on supprime une clé (et donc la valeur qui lui est associée) ;\nrechercher(dict, clé) : on recherche une valeur à l’aide de la clé associée à cette valeur.\n\n\n\n\n\n\n\nExemple\n\n\n\nSoit le dictionnaire D composé des couples clé:valeur suivants : prenom:Kevin, nom:Durand, naissance:17-05-2005. Pour chaque exemple ci-dessous on repart du dictionnaire d’origine :\najouter(D, tel, 06060606)\nmodifier(D,nom,Dupont)\nsupprimer(D, naissance)\nrechercher(D, prenom)\n\nLigne 1 : le dictionnaire D est maintenant composé des couples suivants : prenom:Kevin, nom:Durand, date-naissance:17-05-2005, tel:06060606 ;\nLigne 2 : le dictionnaire D est maintenant composé des couples suivants : prenom:Kevin, nom:Dupont, date-naissance:17-05-2005 ;\nLigne 3 : le dictionnaire D est maintenant composé des couples suivants : prenom:Kevin, nom:Durand ;\nLigne 4 : la fonction renvoie Kevin.\n\n\n\nL’utilisation de la structure dictionnaire en Python a été étudiée en première. Il faut donc revoir le cours correspondant."
  },
  {
    "objectID": "02-structures/dictionnaires_cours.html#du-point-de-vue-concepteur-implémentation",
    "href": "02-structures/dictionnaires_cours.html#du-point-de-vue-concepteur-implémentation",
    "title": "Dictionnaires (Cours)",
    "section": "2. Du point de vue concepteur : Implémentation",
    "text": "2. Du point de vue concepteur : Implémentation\nL’implémentation du type abstrait dictionnaire est complexe et dépasse le cadre du programme de NSI. Cette implémentation utilise des fonctions de hachage.\n\n\n\n\n\nL’utilisation des tables et des fonctions de hachages est omniprésente en informatique, il est donc utile pour votre “culture générale informatique”, de connaître le principe des fonctions de hachages. Voici un texte qui vous permettra de comprendre le principe des fonctions de hachages : c’est quoi le hachage ? . Pour avoir quelques idées sur le principe des tables de hachages, je vous recommande le visionnage de cette vidéo : les tables de hachage.\nOn peut retenir que\n\n\n\n\n\n\nÀ retenir\n\n\n\nLa complexité de recherche, d’ajout et de suppression d’un élément dans un dictionnaire est en \\(\\mathcal{O}(1)\\) : elle ne dépend pas du nombre d’éléments présents dans le dictionnaire.\nEn comparaison, la complexité de l’algorithme de recherche dans un tableau non trié est \\(\\mathcal{O}(n)\\).\nLa structure de dictionnaire est donc une structure très efficace ! N’hésitez pas à l’utiliser car son temps moyen d’exécution est très rapide."
  },
  {
    "objectID": "02-structures/dictionnaires_exercices.html",
    "href": "02-structures/dictionnaires_exercices.html",
    "title": "Dictionnaires (Exercices)",
    "section": "",
    "text": "Les exercices précédés du symbole  sont à faire sur machine, en sauvegardant le fichier si nécessaire.\nLes exercices précédés du symbole  doivent être résolus par écrit."
  },
  {
    "objectID": "02-structures/dictionnaires_exercices.html#exercice-1",
    "href": "02-structures/dictionnaires_exercices.html#exercice-1",
    "title": "Dictionnaires (Exercices)",
    "section": " Exercice 1",
    "text": "Exercice 1\nSoit le programme Python suivant :\ninventaire = {'pommes': 430, 'bananes': 312,'oranges' : 274, 'poires' : 137}\n\nstock = 0\nfor fruit in inventaire.keys():\n  if fruit != 'bananes':\n    stock = stock + inventaire[fruit]\nQuelle est la valeur de la variable stock après l’exécution de ce programme ?"
  },
  {
    "objectID": "02-structures/dictionnaires_exercices.html#exercice-2",
    "href": "02-structures/dictionnaires_exercices.html#exercice-2",
    "title": "Dictionnaires (Exercices)",
    "section": " Exercice 2",
    "text": "Exercice 2\nSoit le programme Python suivant :\nP = [{\"nom\":\"Turing\",\"prenom\":\"Alan\",\"age\":28},{\"nom\":\"Lovelace\",\"prenom\":\"Ada\",\"age\":27}]\nQu’obtient-on si on tape P[1]['age'] dans une console Python ?"
  },
  {
    "objectID": "02-structures/dictionnaires_exercices.html#exercice-3",
    "href": "02-structures/dictionnaires_exercices.html#exercice-3",
    "title": "Dictionnaires (Exercices)",
    "section": " Exercice 3",
    "text": "Exercice 3\nSoit le programme Python suivant :\ndef ajoute(stock,element,quantite):\n  if element in stock:\n    stock[element] = stock[element] + quantite\n  else:\n    stock[element] = quantite\n\nstock = { 'clous': 14, 'vis': 27, 'boulons': 8, 'écrous': 24 }\najoute(stock,'vis',5)\najoute(stock,'chevilles',3)\nQuelle est la valeur de la variable stock à la fin de cette exécution ?"
  },
  {
    "objectID": "02-structures/dictionnaires_exercices.html#exercice-4",
    "href": "02-structures/dictionnaires_exercices.html#exercice-4",
    "title": "Dictionnaires (Exercices)",
    "section": " Exercice 4",
    "text": "Exercice 4\nÉcrire une fonction occurrences(texte) répondant aux spécifications ci-dessous :\ndef occurrences(texte: str) -&gt; dict:\n    \"\"\"\n    Retourne un dictionnaire indiquant le nombre d'apparitions de chaque mot dans le texte\n\n    Parameters\n    ----------\n    texte : str\n        chaîne de caractère à étudier\n\n    Returns\n    -------\n    occurrences : dict\n        dictionnaire, clés : str, valeurs = int\n    \"\"\"\nIndication : la méthode split des chaînes de caractères sera fort utile.\nExemple d’exécution en console :\n&gt;&gt;&gt; phrase = \"coucou les gars coucou les filles\"\n&gt;&gt;&gt; occurrences(phrase)\n{'coucou': 2, 'les': 2, 'gars': 1, 'filles': 1}"
  },
  {
    "objectID": "02-structures/dictionnaires_exercices.html#exercices-tombés-au-bac",
    "href": "02-structures/dictionnaires_exercices.html#exercices-tombés-au-bac",
    "title": "Dictionnaires (Exercices)",
    "section": " Exercices tombés au bac",
    "text": "Exercices tombés au bac\n\n2022 Centres étrangers Jour 1 : exo 1 et exo 3.\n2022 Centres étrangers Jour 2 : exo 2.\n2021 Centres étrangers Jour 1 : exo 2.\n2021 Métropole Septembre Jour 2 : exo 2."
  },
  {
    "objectID": "02-structures/files_cours.html",
    "href": "02-structures/files_cours.html",
    "title": "Files (Cours)",
    "section": "",
    "text": "Définition\n\n\n\nLa file, comme la liste et la pile, permet de stocker des données et d’y accéder. La différence se situe au niveau de l’ajout et du retrait d’éléments.\n\nLe prochain élément auquel on peut accéder est le premier élément ajouté à la structure ;\nLes nouveaux éléments viennent en bout de file : on ne pourra y accéder que lorsque tous les éléments ayant été ajoutés avant eux seront sortis de la file.\n\n\n\nOn parle de mode FIFO (First in, First out, en anglais, premier arrivé, premier sorti), c’est-à-dire que le premier élément ayant été ajouté à la structure sera le prochain élément auquel on accédera. Les derniers éléments ajoutés devront « attendre » que tous les éléments ayant été ajoutés avant eux soient sortis de la file. Contrairement aux listes, on ne peut donc pas accéder à n’importe quelle valeur de la structure (pas d’index).\nPour gérer cette contrainte, la pile est caractérisée par deux « emplacements » :\n\nla tête de file, sortie de la file (début de la structure), où les éléments sont retirés ;\nle bout de file, entrée de la file (fin de la structure), où les éléments sont ajoutés.\n\nOn peut s’imaginer une file d’attente, dans un cinéma par exemple. Les premières personnes à pouvoir acheter leur place sont les premières arrivées, et les nouveaux arrivants se placent au bout de la file.\n\n\n\n\n\nUne file est une collection de données. On appelle tête de file le premier élément de la structure et bout de file le dernier élément. Quand un élément est ajouté à la file, on l’ajoute en bout de file et il devient le nouveau bout de file c’est-à-dire l’élément « suivant » l’élément situé précédemment en bout de file. Quand un élément est retiré de la file, on le sélectionne à la tête de la file et la nouvelle tête est l’élément qui suivait l’ancienne tête. Lorsqu’on ajoute un élément à une file vide, celui-ci est donc à la fois la tête et le bout de la file.\n\n\n\n\n\n6 primitives constituent l’interface permettant de définir le type abstrait de données “file” :\n\ncreer(), qui crée une file vide ;\ntaille(file), qui permet de connaître le nombre d’éléments contenus dans la file ;\nest_vide(file), qui renvoie vrai si la file est vide, faux sinon ;\nenfiler(file, element), qui ajoute un élément au bout de la file (et devient le nouveau bout de file) ;\ndefiler(file), qui retire et renvoie l’élément situé à la tête de la file (la nouvelle tête devient l’élément qui suivait l’ancienne tête) ;\ntete(file), qui renvoie l’élément situé à la tête de la file (sans le retirer).\n\nEnfiler se dit enqueue en anglais et défiler se dit dequeue.\n\n\n\n\n\n\nLa file est utile dans différents types de problèmes\n\n\n\n\npour une imprimante, gestion de la file d’attente des documents à imprimer ;\nmodélisation du jeu de la bataille (on révèle la carte au-dessus du paquet et on place celles gagnées en dessous…) ;\ngestion de mémoires tampon, pour gérer les flux de lecture et d’écriture dans un fichier, par exemple ;\nmatérialisation d’une file d’attente, pour un logiciel (visioconférence par exemple) ou un jeu (gestion des connexions des utilisateurs, des tours de jeu…),…\nalgorithme du parcours en largeur pour les arbres et les graphes, par exemple, pour trouver le plus court trajet sur une carte, ou récupérer les valeurs d’une structure dans l’ordre croissant.. (voir séquence 6).\n\n\n\n\n\n\n\n\n\nExemple\n\n\n\nSupposons implémenté le type abstrait file. Nous disposons d’une interface composée des six primitives décrites ci-dessus. On considère une file F composée des éléments suivants : 12, 14, 8, 7, 19 et 22 (la tête = premier élément entré dans la file est 22, le dernier élément entré est 12). On exécute le code suivant ligne par ligne :\n    enfiler(F,42)\n    defiler(F)\n    defiler(F)\n    taille(F)\n    estVide(F)\n    tete(F)\n\nL’exécution de la ligne 1 ajoute l’élément 42 au bout de la file qui contient alors 42, 12, 14, 8, 7, 19, 22 ;\nL’exécution de la ligne 2 affiche 22 et retire cet élément de la file qui contient maintenant 42, 12, 14, 8, 7, 19 ;\nL’exécution de la ligne 3 affiche 19 et retire cet élément de la file qui contient maintenant 42, 12, 14, 8, 7 ;\nLa ligne 4 renvoie la taille de F : 5 ;\nLa file n’est pas vide, on obtient dont False."
  },
  {
    "objectID": "02-structures/files_cours.html#du-point-de-vue-utilisateur-interface",
    "href": "02-structures/files_cours.html#du-point-de-vue-utilisateur-interface",
    "title": "Files (Cours)",
    "section": "",
    "text": "Définition\n\n\n\nLa file, comme la liste et la pile, permet de stocker des données et d’y accéder. La différence se situe au niveau de l’ajout et du retrait d’éléments.\n\nLe prochain élément auquel on peut accéder est le premier élément ajouté à la structure ;\nLes nouveaux éléments viennent en bout de file : on ne pourra y accéder que lorsque tous les éléments ayant été ajoutés avant eux seront sortis de la file.\n\n\n\nOn parle de mode FIFO (First in, First out, en anglais, premier arrivé, premier sorti), c’est-à-dire que le premier élément ayant été ajouté à la structure sera le prochain élément auquel on accédera. Les derniers éléments ajoutés devront « attendre » que tous les éléments ayant été ajoutés avant eux soient sortis de la file. Contrairement aux listes, on ne peut donc pas accéder à n’importe quelle valeur de la structure (pas d’index).\nPour gérer cette contrainte, la pile est caractérisée par deux « emplacements » :\n\nla tête de file, sortie de la file (début de la structure), où les éléments sont retirés ;\nle bout de file, entrée de la file (fin de la structure), où les éléments sont ajoutés.\n\nOn peut s’imaginer une file d’attente, dans un cinéma par exemple. Les premières personnes à pouvoir acheter leur place sont les premières arrivées, et les nouveaux arrivants se placent au bout de la file.\n\n\n\n\n\nUne file est une collection de données. On appelle tête de file le premier élément de la structure et bout de file le dernier élément. Quand un élément est ajouté à la file, on l’ajoute en bout de file et il devient le nouveau bout de file c’est-à-dire l’élément « suivant » l’élément situé précédemment en bout de file. Quand un élément est retiré de la file, on le sélectionne à la tête de la file et la nouvelle tête est l’élément qui suivait l’ancienne tête. Lorsqu’on ajoute un élément à une file vide, celui-ci est donc à la fois la tête et le bout de la file.\n\n\n\n\n\n6 primitives constituent l’interface permettant de définir le type abstrait de données “file” :\n\ncreer(), qui crée une file vide ;\ntaille(file), qui permet de connaître le nombre d’éléments contenus dans la file ;\nest_vide(file), qui renvoie vrai si la file est vide, faux sinon ;\nenfiler(file, element), qui ajoute un élément au bout de la file (et devient le nouveau bout de file) ;\ndefiler(file), qui retire et renvoie l’élément situé à la tête de la file (la nouvelle tête devient l’élément qui suivait l’ancienne tête) ;\ntete(file), qui renvoie l’élément situé à la tête de la file (sans le retirer).\n\nEnfiler se dit enqueue en anglais et défiler se dit dequeue.\n\n\n\n\n\n\nLa file est utile dans différents types de problèmes\n\n\n\n\npour une imprimante, gestion de la file d’attente des documents à imprimer ;\nmodélisation du jeu de la bataille (on révèle la carte au-dessus du paquet et on place celles gagnées en dessous…) ;\ngestion de mémoires tampon, pour gérer les flux de lecture et d’écriture dans un fichier, par exemple ;\nmatérialisation d’une file d’attente, pour un logiciel (visioconférence par exemple) ou un jeu (gestion des connexions des utilisateurs, des tours de jeu…),…\nalgorithme du parcours en largeur pour les arbres et les graphes, par exemple, pour trouver le plus court trajet sur une carte, ou récupérer les valeurs d’une structure dans l’ordre croissant.. (voir séquence 6).\n\n\n\n\n\n\n\n\n\nExemple\n\n\n\nSupposons implémenté le type abstrait file. Nous disposons d’une interface composée des six primitives décrites ci-dessus. On considère une file F composée des éléments suivants : 12, 14, 8, 7, 19 et 22 (la tête = premier élément entré dans la file est 22, le dernier élément entré est 12). On exécute le code suivant ligne par ligne :\n    enfiler(F,42)\n    defiler(F)\n    defiler(F)\n    taille(F)\n    estVide(F)\n    tete(F)\n\nL’exécution de la ligne 1 ajoute l’élément 42 au bout de la file qui contient alors 42, 12, 14, 8, 7, 19, 22 ;\nL’exécution de la ligne 2 affiche 22 et retire cet élément de la file qui contient maintenant 42, 12, 14, 8, 7, 19 ;\nL’exécution de la ligne 3 affiche 19 et retire cet élément de la file qui contient maintenant 42, 12, 14, 8, 7 ;\nLa ligne 4 renvoie la taille de F : 5 ;\nLa file n’est pas vide, on obtient dont False."
  },
  {
    "objectID": "02-structures/files_cours.html#du-point-de-vue-concepteur-implémentations",
    "href": "02-structures/files_cours.html#du-point-de-vue-concepteur-implémentations",
    "title": "Files (Cours)",
    "section": "2. Du point de vue concepteur : implémentation(s)",
    "text": "2. Du point de vue concepteur : implémentation(s)\nL’implémentation utilisant des listes Python est possible, mais l’opération defiler() est inefficace dans ce cas (on a une complexité en \\(\\mathcal{O}(n)\\)).\nNous allons tout d’abord étudier une implémentation utilisant deux piles.\n\nImplémentation utilisant deux piles\nComme le programme le suggère, il est possible d’implanter une file en utilisant deux piles. Le procédé est le suivant :\n\nla file est, au départ, composée de deux piles vides ;\nla première pile est une pile dite « d’entrée » et la seconde « de sortie » ;\nquand on ajoute un élément dans la file, on le place dans la pile « d’entrée » ;\nQuand on retire (ou qu’on accède) au premier élément de la file, on a deux cas :\n\nsoit la pile « de sortie » est vide et on dépile chaque élément de la pile « d’entrée » pour les empiler immédiatement dans la pile « de sortie » ;\nsoit il y a au moins un élément dans la pile « de sortie », auquel cas on ne fait rien de plus.\nEnfin, on sélectionne le sommet de la pile « de sortie » ;\n\ncomme il y a deux piles, la taille de la file (et le fait qu’elle soit vide ou non) doit se baser sur les éléments contenus dans les deux piles.\n\n\n\n\n\n\nDans notre implémentation, on propose de matérialiser la file sous la forme d’un tuple contenant deux piles, crées (et manipulées) avec les méthodes du module modélisant le type abstrait de données pile en utilisant les listes Python, définit plus tôt dans la section sur les piles. Ce module, nommé piles.py sera importé dans le présent fichier. On introduit également une nouvelle méthode « transferer » qui sert à effectuer le transfert entre les piles (si nécessaire) avant de retirer ou de récupérer le premier élément de la file.\nimport piles\n\n\"\"\"Implémentation du type abstrait \"file\" avec deux piles\"\"\"\n\n\ndef creer_file():\n    \"\"\"Retourne une file vide\"\"\"\n    pile_in = piles.creer()\n    pile_out = piles.creer()\n    return (pile_in, pile_out)\n\n\ndef taille_file(file):\n    \"\"\"Retourne le nombre d'éléments dans la file\"\"\"\n    return piles.taille(file[0]) + piles.taille(file[1])\n\n\ndef est_vide_file(file):\n    \"\"\"Retourne True si la file est vide, False sinon\"\"\"\n    return piles.est_vide(file[0]) and piles.est_vide(file[1])\n\n\ndef enfiler(file, element):\n    \"\"\"Ajoute un nouvel élément à l'arrière de la file\"\"\"\n    piles.empiler(file[0], element)\n\n\ndef transferer(file):\n    \"\"\"Transfère les éléments de la pile d'entrée vers la pile de sortie\"\"\"\n    while piles.taille(file[0]) != 0:\n        item = piles.depiler(file[0])\n        piles.empiler(file[1], item)\n\n\ndef defiler(file):\n    \"\"\"Retourne l'élément situé en tête de la file et le supprime de la file\"\"\"\n    if taille_file(file) == 0:\n        return None\n    else:\n        if piles.sommet(file[1]) is None:\n            transferer(file)\n        return file[1].pop()\n\n\ndef tete_file(file):\n    \"\"\"Retourne l'élément situé en tête de la file\"\"\"\n    if taille_file(file) == 0:\n        return None\n    else:\n        if piles.sommet(file[1]) is None:\n            transferer(file)\n        return piles.sommet(file[1])\nCette implémentation sera testée en exercices.\n\n\nImplémentation utilisant la POO\nOn reprend l’idée du chaînon, mais cette fois-ci, un chaînon est lié à son élément précédent dans la file, et non à son élément suivant : en effet, quand un élément sort de la file, c’est le précédent qui prend la tête.\n\"\"\"\"Implémentation du type abstrait file en POO\"\"\"\n\n\nclass Chainon:\n    def __init__(self, element=None, precedent=None):\n        \"\"\"element est la valeur du chainon et precedent est le chainon qui suit\"\"\"\n        self.element = element\n        self.precedent = precedent\n\n\nclass File():\n    def __init__(self):\n        self.front = None\n        self.back = None\n\n    def taille(self) -&gt; int:\n        \"\"\"Retourne le nombre d'éléments dans la file\"\"\"\n        long = 0\n        chainon = self.front\n        while chainon is not None:\n            chainon = chainon.precedent\n            long = long + 1\n        return long\n\n    def est_vide(self) -&gt; bool:\n        \"\"\"Retourne True si la file est vide et False sinon\"\"\"\n        return self.front is None\n\n    def enfiler(self, element):\n        \"\"\"Ajoute un nouvel élément à l'arrière de la file\"\"\"\n        new_back = Chainon(element, None)   # Création d'un nouveau chaînon\n        if self.taille() == 0:\n            # dans ce cas la file est vide et la tête est la queue\n            self.front = new_back\n        else:\n            self.back.precedent = new_back    # On relie l'ancien dernier élément au nouveau\n        self.back = new_back    # On définit le nouveau dernier élément\n\n    def defiler(self):\n        \"\"\"Retourne l'élément situé en tête de la file et le supprime de la file\"\"\"\n        item = self.front.element\n        self.front = self.front.precedent\n        return item\n\n    def tete(self):\n        \"\"\"Retourne l'élément situé en tête de la file\"\"\"\n        return self.front.element\n\n    def __str__(self):\n        chainon = self.front\n        res = str(chainon.element)\n        while chainon.precedent is not None:\n            res = \" &lt;-- \" + res\n            chainon = chainon.precedent\n            res = str(chainon.element) + res\n        return res\nLa méthode enfiler demande un peu d’attention et doit être bien comprise.\nExemple d’utilisation de cette interface en console :\n&gt;&gt;&gt; a = File()\n&gt;&gt;&gt; a.taille()\n0\n&gt;&gt;&gt; a.est_vide()\nTrue\n&gt;&gt;&gt; for k in range(5):\n        a.enfiler(10*k)\n&gt;&gt;&gt; a.est_vide()\nFalse\n&gt;&gt;&gt; a.taille()\n5\n&gt;&gt;&gt; print(a)\n40 &lt;-- 30 &lt;-- 20 &lt;-- 10 &lt;-- 0\n&gt;&gt;&gt; a.tete()\n0\n&gt;&gt;&gt; a.defiler()\n0\n&gt;&gt;&gt; a.defiler()\n10\n&gt;&gt;&gt; a.taille()\n3\n\n\n\n\n\n\nRemarque (extrait de la documentation Python)\n\n\n\nIl est également possible d’utiliser une liste comme une file, où le premier élément ajouté est le premier récupéré (« premier entré, premier sorti » ou FIFO pour first-in, first-out) ; toutefois, les listes ne sont pas très efficaces pour réaliser ce type de traitement. Alors que les ajouts et suppressions en fin de liste sont rapides, les insertions ou les retraits en début de liste sont lents (car tous les autres éléments doivent être décalés d’une position).\nPour implémenter une file, utilisez plutôt la classe collections.deque qui a été conçue spécialement pour réaliser rapidement les opérations d’ajout et de retrait aux deux extrémités. Par exemple :\n&gt;&gt;&gt; from collections import deque\n&gt;&gt;&gt; queue = deque([\"Eric\", \"John\", \"Michael\"])\n&gt;&gt;&gt; queue.append(\"Terry\")           # Terry arrives\n&gt;&gt;&gt; queue.append(\"Graham\")          # Graham arrives\n&gt;&gt;&gt; queue.popleft()                 # The first to arrive now leaves\n'Eric'\n&gt;&gt;&gt; queue.popleft()                 # The second to arrive now leaves\n'John'\n&gt;&gt;&gt; queue                           # Remaining queue in order of arrival\ndeque(['Michael', 'Terry', 'Graham'])"
  },
  {
    "objectID": "02-structures/index.html",
    "href": "02-structures/index.html",
    "title": "Programme",
    "section": "",
    "text": "Points du programme traités dans cette séquence :\n\n\n\n\n\n\n\n\nContenus\nCapacités attendues\nCommentaires\n\n\n\n\nStructures de données, interface et implémentation.\nSpécifier une structure de données par son interface. Distinguer interface et implémentation. Écrire plusieurs implémentations d’une même structure de données.\nL’abstraction des structures de données est introduite après plusieurs implémentations d’une structure simple comme la file (avec un tableau ou avec deux piles)\n\n\nListes, piles, files : structures linéaires. Dictionnaires, index et clé.\nDistinguer des structures par le jeu des méthodes qui les caractérisent. Choisir une structure de données adaptée à la situation à modéliser. Distinguer la recherche d’une valeur dans une liste et dans un dictionnaire.\nOn distingue les modes FIFO (first in first out) et LIFO (last in first out) des piles et des files."
  },
  {
    "objectID": "02-structures/interface/index.html",
    "href": "02-structures/interface/index.html",
    "title": "Interface et implémentation",
    "section": "",
    "text": "Nous allons dans ce chapitre nous intéresser aux structures de données comme les listes, les piles, les files et les dictionnaires.\nLes dictionnaires ont déjà été rencontrés en première. Plus précisément, c’est l’implémentation du type abstrait “dictionnaire” en Python qui a été utilisée.\nToutes ces structures de données sont des types abstraits qui doivent être définis dans un langage de programmation pour pouvoir être utilisés.\n\n\n\n\n\n\nDéfinition\n\n\n\nImplémenter un algorithme, c’est le traduire dans un langage de programmation.\n\n\nPour un type abstrait donné, disons les dictionnaires, plusieurs implémentations sont possibles. Elles peuvent se différencier par leur rapidité d’exécution ou leur capacité à travailler avec des données de grande taille par exemple.\nUne fois implémenté, le type abstrait doit pouvoir être utilisé par un programmeur (utilisateur). Cet utilisateur n’a pas besoin de connaître comment le type “dictionnaire” a été concrètement implémenté dans le langage de programmation qu’il utilise. Par contre, il faut qu’il connaisse précisément les actions qu’i peut réaliser sur ce type de données.\nPar exemple, un dictionnaire associe à un ensemble de clés un ensemble de valeurs (ce sont les données) et permet notamment les opérations :\n\nd’ajout d’un couple clé-valeur ;\nde suppression d’une clé, et donc de la valeur correspondante ;\nde modification de la valeur associée à une clé et ;\nde recherche de la valeur correspondant à une clé.\n\nL’ensemble des fonctions (méthodes) associées à un type abstrait constitue son interface. Ces fonctions, et leurs spécifications, permettent à l’utilisateur d’utiliser le type abstrait dans son programme.\nQuand on utilise une bibliothèque contenant l’implémentation de structures de données, l’ensemble de ces spécifications est nommée API (Application Programming Interface, Interface de Programmation en français).\n\n\n\n\n\n\nDéfinition (d’après Wikipedia)\n\n\n\nEn informatique, une interface de programmation (souvent désignée par le terme API pour Application Programming Interface) est un ensemble normalisé de classes, de méthodes, de fonctions et de constantes qui sert de façade par laquelle un logiciel offre des services à d’autres logiciels. Elle est offerte par une bibliothèque logicielle ou un service web, le plus souvent accompagnée d’une description qui spécifie comment des programmes consommateurs peuvent se servir des fonctionnalités du programme fournisseur.\n\n\nL’usage des bibliothèques permet à chaque programmeur d’ajouter des structures réalisant des types abstraits de données, cette implémentation n’étant pas nécessairement connue de l’utilisateur de la structure. Cette méthode de conception logicielle, utilisant l’encapsulation, permet à la fois :\n\nle développement séparé de l’application et de l’implémentation de la structure ;\nla modification de l’implémentation sans modification de ses utilisations (on préserve l’interface) ;\nl’utilisation facile de l’implémentation de la structure dans des programmes à venir ;\nla limitation des erreurs ;\nl’ajout :\n\nde vérifications sous forme d’assertions ;\nd’outils de correction des problèmes de programmation ;\n\nune meilleure lisibilité du code de l’application.\n\nDans la suite de ce chapitre, nous allons étudier successivement les listes, les piles, les files et les dictionnaire du point de vue du concepteur (implémentation) et de l’utilisateur (interface)."
  },
  {
    "objectID": "02-structures/interfaces_cours.html",
    "href": "02-structures/interfaces_cours.html",
    "title": "Interfaces et implémentations (Cours)",
    "section": "",
    "text": "Nous allons dans ce chapitre nous intéresser aux structures de données comme les listes, les piles, les files et les dictionnaires.\nLes dictionnaires ont déjà été rencontrés en première. Plus précisément, c’est l’implémentation du type abstrait “dictionnaire” en Python qui a été utilisée.\nToutes ces structures de données sont des types abstraits qui doivent être définis dans un langage de programmation pour pouvoir être utilisés.\n\n\n\n\n\n\nDéfinition\n\n\n\nImplémenter un algorithme, c’est le traduire dans un langage de programmation.\n\n\nPour un type abstrait donné, disons les dictionnaires, plusieurs implémentations sont possibles. Elles peuvent se différencier par leur rapidité d’exécution ou leur capacité à travailler avec des données de grande taille par exemple.\nUne fois implémenté, le type abstrait doit pouvoir être utilisé par un programmeur (utilisateur). Cet utilisateur n’a pas besoin de connaître comment le type “dictionnaire” a été concrètement implémenté dans le langage de programmation qu’il utilise. Par contre, il faut qu’il connaisse précisément les actions qu’i peut réaliser sur ce type de données.\nPar exemple, un dictionnaire associe à un ensemble de clés un ensemble de valeurs (ce sont les données) et permet notamment les opérations :\n\nd’ajout d’un couple clé-valeur ;\nde suppression d’une clé, et donc de la valeur correspondante ;\nde modification de la valeur associée à une clé et ;\nde recherche de la valeur correspondant à une clé.\n\nL’ensemble des fonctions (méthodes) associées à un type abstrait constitue son interface. Ces fonctions et leurs spécifications, permettent à l’utilisateur d’utiliser le type abstrait dans son programme.\nQuand on utilise une bibliothèque contenant l’implémentation de structures de données, l’ensemble de ces spécifications est nommée API (Application Programming Interface, Interface de Programmation en français).\n\n\n\n\n\n\nDéfinition (d’après Wikipedia)\n\n\n\nEn informatique, une interface de programmation (souvent désignée par le terme API pour Application Programming Interface) est un ensemble normalisé de classes, de méthodes, de fonctions et de constantes qui sert de façade par laquelle un logiciel offre des services à d’autres logiciels. Elle est offerte par une bibliothèque logicielle ou un service web, le plus souvent accompagnée d’une description qui spécifie comment des programmes consommateurs peuvent se servir des fonctionnalités du programme fournisseur.\n\n\nL’usage des bibliothèques permet à chaque programmeur d’ajouter des structures réalisant des types abstraits de données, cette implémentation n’étant pas nécessairement connue de l’utilisateur de la structure. Cette méthode de conception logicielle, utilisant l’encapsulation, permet à la fois :\n\nle développement séparé de l’application et de l’implémentation de la structure ;\nla modification de l’implémentation sans modification de ses utilisations (on préserve l’interface) ;\nl’utilisation facile de l’implémentation de la structure dans des programmes à venir ;\nla limitation des erreurs ;\nl’ajout :\n\nde vérifications sous forme d’assertions ;\nd’outils de correction des problèmes de programmation ;\n\nune meilleure lisibilité du code de l’application.\n\nDans la suite de ce chapitre, nous allons étudier successivement les listes, les piles, les files et les dictionnaires du point de vue du concepteur (implémentation) et de l’utilisateur (interface)."
  },
  {
    "objectID": "02-structures/listes_cours.html",
    "href": "02-structures/listes_cours.html",
    "title": "Listes (Cours)",
    "section": "",
    "text": "Attention !\n\n\n\nEn Première, nous avons utilisé le type de données list de Python pour représenter des tableaux de d’éléments de même type. Le vocabulaire propre à Python peut induire en erreur et amener à penser que le type “liste” est déjà connu. La structure list de Python réalise en fait l’implémentation du type abstrait de données “tableau dynamique” et doit être laissée de côté, malgré l’utilisation du même vocabulaire.\nCela ne nous empêchera pas d’implémenter le type abstrait de données liste en utilisant des structures de type list en Python."
  },
  {
    "objectID": "02-structures/listes_cours.html#du-point-de-vue-utilisateur-interface",
    "href": "02-structures/listes_cours.html#du-point-de-vue-utilisateur-interface",
    "title": "Listes (Cours)",
    "section": "1. Du point de vue utilisateur : interface",
    "text": "1. Du point de vue utilisateur : interface\n\n\n\n\n\n\nDéfinition\n\n\n\nUne liste est une structure de données qui permet de stocker des données et d’y accéder directement.\nC’est un type abstrait de données :\n\nlinéaire : les données sont stockées dans une structure unidimensionnelle ;\nindexé : chaque donnée est associée à une valeur ;\nordonné : les données sont présentées les unes après les autres.\n\n\n\nUne liste est une collection finie de données. On appelle tête le premier élément de la liste et queue la liste privée de son premier élément. Il est seulement possible d’ajouter et de lire une donnée en tête de la liste.\nL’interface minimale permettant de définir le type abstrait de données “liste” comporte cinq fonctions, qui sont appelées primitives :\n\ncreer(), qui crée une liste vide ;\najouter(element, liste), qui ajoute un élément en tête de liste ; ces deux première primitives peuvent parfois se regrouper en une seule ;\ntete(liste), qui renvoie la valeur de l’élément en tête de liste ;\nqueue(liste), qui renvoie la liste privée de son premier élément ;\nest_vide(liste), qui renvoie vrai si la liste est vide, faux sinon.\n\nCe type abstrait de données est non mutable (il n’y a pas de primitive permettant de modifier la valeur d’un élément de la liste).\nRemarque : on peut selon les besoins ajouter d’autres fonctions permettant par exemple de renvoyer la longueur d’une liste, de rechercher un élément ou d’accéder au ième élément …\n\n\n\n\n\n\nExemple\n\n\n\nSupposons implémenté le type abstrait liste. Nous disposons d’une interface composée des cinq primitives décrites ci-dessus. On exécute le code suivant ligne par ligne :\nL = creer()\nest_vide(L)\nL1 = ajouter(12, L)\nest_vide(L1)\nL1 = ajouter(15, L1)\nL1 = ajouter(1, ajouter(11,L1))\ntete(L1)\nL2 = queue(L1)\n\nLa ligne 1 créée une liste vide L ;\nLa ligne 2 affiche True car la liste L est vide ;\nAprès exécution de la ligne 3, la liste L1 contient l’élément unique 12 ;\nLa ligne 4 affiche False car la liste L1 n’est pas vide ;\nAprès exécution de la ligne 5, la liste L1 contient les éléments 12 et 15 ;\nLa ligne 6 montre que l’on peut composer les ajouts pour ajouter en une seule fois plusieurs éléments. Après exécution de la ligne 6, la liste L1 contient les éléments 12, 15, 11 et 1 ;\nLa ligne 7 affiche 1 : c’est la tête de la liste (il s’agit du dernier élément ajouté) ;\nLa ligne 8 définit une liste L2 égale à la queue de la liste L1. L2 contient donc les éléments 12, 15 et 11."
  },
  {
    "objectID": "02-structures/listes_cours.html#du-point-de-vue-concepteur-implémentations",
    "href": "02-structures/listes_cours.html#du-point-de-vue-concepteur-implémentations",
    "title": "Listes (Cours)",
    "section": "2. Du point de vue concepteur : implémentation(s)",
    "text": "2. Du point de vue concepteur : implémentation(s)\nNous allons implémenter le type abstrait “liste” en Python de deux façons différentes.\n\nImplémentation avec des tuples\nNous allons ici utiliser des tuples et la programmation fonctionnelle (rappel : fonctions pures, pas d’affectations, pas de boucles).\n\"\"\" Implémentation du type abstrait \"liste\" avec des tuples\"\"\"\n\n\ndef creer() -&gt; tuple:\n    \"\"\"Retourne une liste vide\"\"\"\n    return ()\n\n\ndef ajouter(element: all, liste: tuple) -&gt; tuple:\n    \"\"\"Retourne la liste avec l'élément ajouté en tête de liste\"\"\"\n    return (element, liste)\n\n\ndef est_vide(liste: tuple) -&gt; bool:\n    \"\"\"Retourne True si la liste est vide et False sinon\"\"\"\n    return liste == ()\n\n\ndef tete(liste: tuple) -&gt; all:\n    \"\"\"Retourne la tête de la liste\"\"\"\n    assert not est_vide(liste), \"Erreur : liste vide\"\n    return liste[0]\n\n\ndef queue(liste: tuple) -&gt; tuple:\n    \"\"\"Retourne la queue de la liste\"\"\"\n    assert not est_vide(liste), \"Erreur : liste vide\"\n    return liste[1]\n\n\ndef longueur(liste: tuple) -&gt; int:\n    \"\"\"Retourne le nombre d'éléments de la liste\"\"\"\n    if est_vide(liste):\n        return 0\n    else:\n        return 1 + longueur(liste[1])\nAvec cette représentation une liste est toujours un tuple à deux éléments dont le premier est la tête de la liste (le dernier élément ajouté) et le deuxième est la queue (c’est donc une liste).\n\\[L=(1, (11, (15, (12, ()))))\\]\nOn remarquera que la fonction longueur est codée sans boucle, mais de façon récursive, afin de correspondre au paradigme fonctionnel.\n\n\nImplémentation en POO\nConformément au programme, on se limite à une version naïve de la POO. On pourra à titre d’exercice reprendre cette implémentation en respectant les règles plus strictes édictées dans les compléments de cours sur la POO.\nOn définit ci-dessous une liste chaînée : chaque chaînon est constitué de l’élément qui fait partie de la liste et de la référence à l’élément suivant. C’est la classe Chainon qui implémente cette structure. L’objet Liste est défini à partir de son premier élément (tête) et ses primitives sont définies sous forme de méthodes.\n\"\"\"Implémentation du type abstrait liste en POO\"\"\"\n\n\nclass Chainon:\n    def __init__(self, element=None, suivant=None):\n        \"\"\"element est la valeur du chainon et suivant est le chainon qui suit\"\"\"\n        self.element = element\n        self.suivant = suivant\n\n\nclass Liste:\n    def __init__(self):\n        \"\"\"Crée une liste vide\"\"\"\n        self.head = Chainon()\n\n    def est_vide(self) -&gt; bool:\n        \"\"\"Retourne True si la liste est vide et False sinon\"\"\"\n        return self.head.element is None\n\n    def ajouter(self, element):\n        \"\"\"Ajoute element en tête de la liste\"\"\"\n        self.head = Chainon(element, self.head)\n\n    def tete(self):\n        \"\"\"Retourne la valeur de la tête de la liste\"\"\"\n        return self.head.element\n\n    def queue(self):\n        \"\"\"Retourne la queue de la liste, c.-à-d. la liste privée de sa tête\"\"\"\n        new_liste = Liste()\n        new_liste.head = self.head.suivant\n        return new_liste\n\n    def longueur(self):\n        \"\"\"Retourne la longueur de la liste\"\"\"\n        long = 0\n        chainon = self.head\n        while chainon.element is not None:\n            chainon = chainon.suivant\n            long = long + 1\n        return long\nOn peut améliorer l’implémentation en redéfinissant les méthodes spéciales __len__ (qui permettra de taper len(L) au lieu de L.longueur()) et __str__ (qui permettra d’utiliser l’instruction print(L)).\n    def __len__(self):\n        return self.longueur()\n\n    def __str__(self):\n        rep = \"\"\n        chainon = self.head\n        while chainon.element is not None:\n            rep = rep + str(chainon.element) + \" --&gt; \"\n            chainon = chainon.suivant\n        return rep[:-4]\n&gt;&gt;&gt; L=Liste()\n&gt;&gt;&gt; L.ajouter(11)\n&gt;&gt;&gt; L.ajouter(12)\n&gt;&gt;&gt; L.ajouter(13)\n&gt;&gt;&gt; print(L)\n13 --&gt; 12 --&gt; 11"
  },
  {
    "objectID": "02-structures/listes_exercices.html",
    "href": "02-structures/listes_exercices.html",
    "title": "Listes, Piles et Files (Exercices)",
    "section": "",
    "text": "Les exercices précédés du symbole  sont à faire sur machine, en sauvegardant le fichier si nécessaire.\nLes exercices précédés du symbole  doivent être résolus par écrit."
  },
  {
    "objectID": "02-structures/listes_exercices.html#exercice-1-listes",
    "href": "02-structures/listes_exercices.html#exercice-1-listes",
    "title": "Listes, Piles et Files (Exercices)",
    "section": " Exercice 1 (listes)",
    "text": "Exercice 1 (listes)\nOn reprend l’implémentation des listes avec des tuples présentée dans le cours.\nPrévoir l’effet et l’affichage en console des instructions suivantes, puis vérifier en exécutant ces instructions dans la console interactive après avoir créé et importé un fichier contenant le code du cours :\n&gt;&gt;&gt; L = creer()\n&gt;&gt;&gt; est_vide(L)\n&gt;&gt;&gt; L = ajouter(5, ajouter(4, ajouter(3, ajouter(2, ajouter(1, ajouter(0,()))))))\n&gt;&gt;&gt; est_vide(L)\n&gt;&gt;&gt; longueur(L)\n&gt;&gt;&gt; L = ajouter(6,L)\n&gt;&gt;&gt; longueur(L)\n&gt;&gt;&gt; tete(L)\n&gt;&gt;&gt; queue(L)\n&gt;&gt;&gt; longueur(queue(L))"
  },
  {
    "objectID": "02-structures/listes_exercices.html#exercice-2-listes",
    "href": "02-structures/listes_exercices.html#exercice-2-listes",
    "title": "Listes, Piles et Files (Exercices)",
    "section": " Exercice 2 (listes)",
    "text": "Exercice 2 (listes)\nSoit la suite d’instructions suivantes :\nL = creer()\nL = ajouter(2, ajouter(15, ajouter (23, L)))\nL1 = queue(L)\na = tete(L1)\nL1 = ajouter(4, ajouter(3, L1))\nDonnez le contenu des listes L et L1 et la valeur de a."
  },
  {
    "objectID": "02-structures/listes_exercices.html#exercice-3-piles",
    "href": "02-structures/listes_exercices.html#exercice-3-piles",
    "title": "Listes, Piles et Files (Exercices)",
    "section": " Exercice 3 (piles)",
    "text": "Exercice 3 (piles)\nSoit une pile P initialement vide. Soit les instructions suivantes (implémentation des piles avec des listes Python) :\n&gt;&gt;&gt; empiler(P,4)\n&gt;&gt;&gt; empiler(P,7)\n&gt;&gt;&gt; a = depiler(P)\n&gt;&gt;&gt; b = taille(P)\n&gt;&gt;&gt; c = depiler(P)\n&gt;&gt;&gt; empiler(P,3)\n&gt;&gt;&gt; empiler(P,2)\n&gt;&gt;&gt; d = taille(P)\nDonnez le contenu de la pile P, la valeur de a, la valeur de b, la valeur de c et la valeur de d."
  },
  {
    "objectID": "02-structures/listes_exercices.html#exercice-4-piles",
    "href": "02-structures/listes_exercices.html#exercice-4-piles",
    "title": "Listes, Piles et Files (Exercices)",
    "section": " Exercice 4 (piles)",
    "text": "Exercice 4 (piles)\nSoit le programme Python suivant (on utilise l’implémentation des piles en POO) :\npile = Pile()\ntab = [5,8,6,1,3,7]\nfor k in tab:\n    pile.empiler(k)\npile.empiler(5)\npile.empiler(10)\npile.empiler(8)\npile.empiler(15)\nfor k in tab:\n    if k &gt; 5:\n        pile.depiler()\nDonnez l’état de la pile pile après l’exécution de ce programme."
  },
  {
    "objectID": "02-structures/listes_exercices.html#exercice-5-piles",
    "href": "02-structures/listes_exercices.html#exercice-5-piles",
    "title": "Listes, Piles et Files (Exercices)",
    "section": "  Exercice 5 (piles)",
    "text": "Exercice 5 (piles)\nCe problème propose une application concrète des piles. Il s’agit d’écrire une fonction qui contrôle si une expression mathématique, donnée sous forme d’une chaîne de caractères, est bien parenthésée, c’est- à-dire s’il y a autant de parenthèses ouvrantes que de fermantes, et qu’elles sont bien placées\nPar exemple :\n\n(..(..)..) est bien parenthésée\n(…(..(..)…) ne l’est pas\n\nL’algorithme :\n\nOn crée une pile\nOn parcourt l’expression de gauche à droite.\nÀ chaque fois que l’on rencontre une parenthèse ouvrante “(” on l’empile\nSi on rencontre une parenthèse fermante ” ) ” et que la pile n’est pas vide on dépile ( sinon on retourne faux )\nÀ la fin la pile doit être vide…\n\n\nEn utilisant l’une des structures pile du cours, écrire une fonction verification(expr) qui vérifie si une expression mathématique passée en paramètre est correctement parenthésée.\nProposer un jeu de tests unitaires vérifiant le bon fonctionnement de la fonction.\nFaire en sorte que le programme tienne compte également des [."
  },
  {
    "objectID": "02-structures/listes_exercices.html#exercice-6-files",
    "href": "02-structures/listes_exercices.html#exercice-6-files",
    "title": "Listes, Piles et Files (Exercices)",
    "section": " Exercice 6 (files)",
    "text": "Exercice 6 (files)\nSoit une file F initialement vide. Soit les instructions suivantes :\nenfiler(F,6)\nenfiler(F,3)\na = defiler(F)\nenfiler(F,9)\nb = taille_file(F)\nenfiler(F,17)\nc = defiler(F)\nenfiler(F,2)\nd = taille_file(F)\nDonnez le contenu de la file F, la valeur de a, la valeur de b, la valeur de c et la valeur de d."
  },
  {
    "objectID": "02-structures/listes_exercices.html#exercice-7-files",
    "href": "02-structures/listes_exercices.html#exercice-7-files",
    "title": "Listes, Piles et Files (Exercices)",
    "section": " Exercice 7 (files)",
    "text": "Exercice 7 (files)\nSoit le programme Python suivant :\nfile = File()\ntab = [2,78,6,89,3,17]\nfile.enfiler(5)\nfile.enfiler(10)\nfile.enfiler(8)\nfile.enfiler(15)\nfor i in tab:\n    if i &gt; 50:\n        file.defiler()\nDonnez l’état de la file file après l’exécution de ce programme"
  },
  {
    "objectID": "02-structures/listes_exercices.html#exercices-tombés-au-bac",
    "href": "02-structures/listes_exercices.html#exercices-tombés-au-bac",
    "title": "Listes, Piles et Files (Exercices)",
    "section": " Exercices tombés au bac",
    "text": "Exercices tombés au bac\n\n2021 Métropole Jour 1 : exo 2.\n2021 Centres étrangers Jour 2 : exo 1.\n2021 Centres étrangers Jour 1 : exo 5.\n2021 Amérique du Nord Jour1 : exo 5.\n2021 Sujet zéro : exo 1.\n2022 Centres étrangers Jour 1 : exo 2.\n2022 Métropole Jour 1 : exo 1.\n2022 Métropole Jour 2 : exo 2.\n2022 Mayotte Liban Jour 1 : exo 1.\n2022 Mayotte Liban Jour 2 : exo 1.\n2022 Amérique du Nord Jour 1 : exo 5."
  },
  {
    "objectID": "02-structures/piles_cours.html",
    "href": "02-structures/piles_cours.html",
    "title": "Piles (Cours)",
    "section": "",
    "text": "Définition\n\n\n\nLa pile est une structure de données qui permet de stocker des données et d’y accéder. Une pile se comporte comme une pile d’assiettes :\n\non ajoute des nouvelles assiettes au sommet de la pile ;\nquand on veut en retirer une, on est obligé de prendre celle située au sommet.\n\n\n\nOn parle de mode LIFO (Last In, First Out, en anglais, dernier arrivé, premier sorti), c’est-à-dire que le dernier élément ajouté à la structure sera le prochain élément auquel on accédera. Les premiers éléments ayant été ajoutés devront « attendre » que tous les éléments qui ont été ajoutés après eux soient sortis de la pile. Contrairement aux listes, on ne peut donc pas accéder à n’importe quelle valeur de la structure (pas d’index). Pour gérer cette contrainte, on définit le sommet de la pile qui caractérise l’emplacement pour ajouter ou retirer des éléments.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nL’interface suivante permet de définir le type abstrait de données pile :\n\ncreer(), qui crée une pile vide ;\ntaille(pile), qui permet de connaître le nombre d’éléments contenus dans la pile ;\nest_vide(pile), qui renvoie vrai si la pile est vide, faux sinon ;\nempiler(pile, element), qui ajoute un élément au sommet de la pile (qui devient le nouveau sommet) ;\ndepiler(pile), qui retire et renvoie l’élément situé au sommet de la pile (le nouveau sommet devient l’élément qui suivait l’ancien sommet) ;\nsommet(pile), qui renvoie l’élément situé au sommet de la pile (sans le retirer).\n\nL’opération d’empilement se dit “push” en anglais, l’opération de dépilement se dit “pop”.\n\n\n\n\n\n\nLa pile est utile dans différents types de problèmes\n\n\n\n\nalgorithme d’un navigateur pour pouvoir mémoriser les pages web et revenir en arrière (ou ré-avancer) sur certaines pages ;\nstocker des actions et les annuler (ou les réappliquer), sur l’ordinateur (fonction CTRL+Z, et CTRL+Y) ;\ncoder une calculatrice en notation polonaise inversée (voir exercices) ;\nalgorithme du parcours en profondeur pour les arbres et les graphes, par exemple, pour résoudre un labyrinthe, trouver un trajet sur une carte… (voir séquence 6) ;\nécrire des versions itératives de certains algorithmes récursifs (voir séquence 1) ;\nillustration du fonctionnement de la pile d’appels des fonctions lors de l’exécution d’un programme.\n\n\n\n\n\n\n\n\n\nExemple\n\n\n\nSupposons implémenté le type abstrait pile. Nous disposons d’une interface composée des six primitives décrites ci-dessus. On considère une pile P composée des éléments suivants : 12, 14, 8, 7, 19 et 22 (le sommet de la pile est 22). On exécute le code suivant ligne par ligne :\n    depiler(P)\n    empiler(P,42)\n    depiler(P)\n    taille(P)\n    estVide(P)\n\nL’exécution de la ligne 1 renvoie la valeur 22 et la pile est maintenant composée des éléments 12, 14, 8, 7 et 19 ;\nL’exécution de la ligne 2 place l’élément 42 au sommet de la pile ;\nL’exécution de la ligne 3 renvoie la valeur 42 et la pile est maintenant à nouveau composée des éléments 12, 14, 8, 7 et 19 ;\nLa ligne 4 renvoie la taille de P : 5 ;\nLa pile n’est pas vide, on obtient dont False."
  },
  {
    "objectID": "02-structures/piles_cours.html#du-point-de-vue-utilisateur-interface",
    "href": "02-structures/piles_cours.html#du-point-de-vue-utilisateur-interface",
    "title": "Piles (Cours)",
    "section": "",
    "text": "Définition\n\n\n\nLa pile est une structure de données qui permet de stocker des données et d’y accéder. Une pile se comporte comme une pile d’assiettes :\n\non ajoute des nouvelles assiettes au sommet de la pile ;\nquand on veut en retirer une, on est obligé de prendre celle située au sommet.\n\n\n\nOn parle de mode LIFO (Last In, First Out, en anglais, dernier arrivé, premier sorti), c’est-à-dire que le dernier élément ajouté à la structure sera le prochain élément auquel on accédera. Les premiers éléments ayant été ajoutés devront « attendre » que tous les éléments qui ont été ajoutés après eux soient sortis de la pile. Contrairement aux listes, on ne peut donc pas accéder à n’importe quelle valeur de la structure (pas d’index). Pour gérer cette contrainte, on définit le sommet de la pile qui caractérise l’emplacement pour ajouter ou retirer des éléments.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nL’interface suivante permet de définir le type abstrait de données pile :\n\ncreer(), qui crée une pile vide ;\ntaille(pile), qui permet de connaître le nombre d’éléments contenus dans la pile ;\nest_vide(pile), qui renvoie vrai si la pile est vide, faux sinon ;\nempiler(pile, element), qui ajoute un élément au sommet de la pile (qui devient le nouveau sommet) ;\ndepiler(pile), qui retire et renvoie l’élément situé au sommet de la pile (le nouveau sommet devient l’élément qui suivait l’ancien sommet) ;\nsommet(pile), qui renvoie l’élément situé au sommet de la pile (sans le retirer).\n\nL’opération d’empilement se dit “push” en anglais, l’opération de dépilement se dit “pop”.\n\n\n\n\n\n\nLa pile est utile dans différents types de problèmes\n\n\n\n\nalgorithme d’un navigateur pour pouvoir mémoriser les pages web et revenir en arrière (ou ré-avancer) sur certaines pages ;\nstocker des actions et les annuler (ou les réappliquer), sur l’ordinateur (fonction CTRL+Z, et CTRL+Y) ;\ncoder une calculatrice en notation polonaise inversée (voir exercices) ;\nalgorithme du parcours en profondeur pour les arbres et les graphes, par exemple, pour résoudre un labyrinthe, trouver un trajet sur une carte… (voir séquence 6) ;\nécrire des versions itératives de certains algorithmes récursifs (voir séquence 1) ;\nillustration du fonctionnement de la pile d’appels des fonctions lors de l’exécution d’un programme.\n\n\n\n\n\n\n\n\n\nExemple\n\n\n\nSupposons implémenté le type abstrait pile. Nous disposons d’une interface composée des six primitives décrites ci-dessus. On considère une pile P composée des éléments suivants : 12, 14, 8, 7, 19 et 22 (le sommet de la pile est 22). On exécute le code suivant ligne par ligne :\n    depiler(P)\n    empiler(P,42)\n    depiler(P)\n    taille(P)\n    estVide(P)\n\nL’exécution de la ligne 1 renvoie la valeur 22 et la pile est maintenant composée des éléments 12, 14, 8, 7 et 19 ;\nL’exécution de la ligne 2 place l’élément 42 au sommet de la pile ;\nL’exécution de la ligne 3 renvoie la valeur 42 et la pile est maintenant à nouveau composée des éléments 12, 14, 8, 7 et 19 ;\nLa ligne 4 renvoie la taille de P : 5 ;\nLa pile n’est pas vide, on obtient dont False."
  },
  {
    "objectID": "02-structures/piles_cours.html#du-point-de-vue-concepteur-implémentations",
    "href": "02-structures/piles_cours.html#du-point-de-vue-concepteur-implémentations",
    "title": "Piles (Cours)",
    "section": "2. Du point de vue concepteur : implémentation(s)",
    "text": "2. Du point de vue concepteur : implémentation(s)\n\nImplémentation avec listes Python\nPremière solution, on peut implémenter une pile en utilisant des listes Python. Cette solution est très facile, car les méthodes append et pop des objets de type list correspondent exactement aux primitives empiler et dépiler de la structure pile.\n\"\"\"Implémentation des piles avec des listes Python\"\"\"\n\n\ndef creer():\n    \"\"\"Retourne une pile vide\"\"\"\n    return []\n\n\ndef taille(pile):\n    \"\"\"Retourne le nombre d'éléments de la pile\"\"\"\n    return len(pile)\n\n\ndef est_vide(pile):\n    \"\"\"Retourne True si la pile est vide, False sinon\"\"\"\n    return pile == []\n\n\ndef empiler(pile, element):\n    \"\"\"Empile un nouvel élément au sommet de la pile\"\"\"\n    pile.append(element)\n\n\ndef depiler(pile):\n    \"\"\"Retourne l'élément situé au sommet de la pile\n    et le supprime de celle-ci\"\"\"\n    if not est_vide(pile):\n        return pile.pop()\n    else:\n        return None\n\n\ndef sommet(pile):\n    \"\"\"Retourne l'élément situé au sommet de la pile\"\"\"\n    if not est_vide(pile):\n        return pile[-1]\n    else:\n        return None\nCette implémentation sera testée en exercices.\n\n\nImplémentation en POO\nConformément au programme, on se limite à une version naïve de la POO. On pourra à titre d’exercice reprendre cette implémentation en respectant les règles plus strictes édictées dans les compléments de cours sur la POO.\nOn reprend l’idée de chaînon utilisée pour les listes.\n\"\"\"Implémentation du type abstrait pile en POO\"\"\"\n\n\nclass Chainon:\n    def __init__(self, element=None, suivant=None):\n        \"\"\"element est la valeur du chainon et suivant est le chainon qui suit\"\"\"\n        self.element = element\n        self.suivant = suivant\n\n\nclass Pile:\n    def __init__(self):\n        \"\"\"Crée une pile vide\"\"\"\n        self.summit = Chainon()\n\n    def taille(self):\n        \"\"\"Retourne le nombre d'éléments dans la pile\"\"\"\n        long = 0\n        chainon = self.summit\n        while chainon.element is not None:\n            chainon = chainon.suivant\n            long = long + 1\n        return long\n\n    def est_vide(self) -&gt; bool:\n        \"\"\"Retourne True si la pile est vide et False sinon\"\"\"\n        return self.summit.element is None\n\n    def empiler(self, element):\n        \"\"\"Empile element qu sommet de la pile\"\"\"\n        self.summit = Chainon(element, self.summit)\n\n    def depiler(self):\n        \"\"\"Retourne l'élément situé au sommet de la pile\n        et le supprime de celle-ci\"\"\"\n        item = self.summit.element\n        self.summit = self.summit.suivant\n        return item\n\n    def sommet(self):\n        \"\"\"Retourne la valeur du sommet de la pile\"\"\"\n        return self.summit.element\n\nCette implémentation sera testée en exercices.\n\n\n\n\n\n\nComparaison des deux implémentations\n\n\n\nOn peut comparer en termes de temps d’exécution l’efficacité de ces deux implémentations.\nOn utilise pour cela la bibliothèque timeit présentée dans cet article.\nPour cela, on ajoute les lignes suivantes au code de la version “listes Python” :\nimport timeit\n\nma_pile = creer()\nprint(timeit.timeit('empiler(ma_pile,1)', number=10000000, globals=globals()))\non obtient :\n2.2605971000011778\net les lignes suivantes au code de la version “POO” :\nimport timeit\n\nma_pile = Pile()\nprint(timeit.timeit('ma_pile.empiler(1)', number=10000000, globals=globals()))\non obtient :\n7.292327400005888\nOn constate donc que la version utilisant les listes Python est beaucoup plus efficace. Cela s’explique notamment par le fait que l’implantation avec les listes Python repose sur une programmation avancée et optimisée, contrairement à l’implantation objet qui a été construite sans utiliser de structure externe.\nNéanmoins, on peut montrer que, dans les deux implémentations, les opérations d’empilement et de dépilement sont en \\(\\mathcal{O}(1)\\), ce qui signifie que le temps d’exécution ne dépend pas du nombre de données.\nL’utilisation des listes est la plus efficace. Néanmoins, l’implantation objet a pour avantage de montrer et d’assimiler le fonctionnement interne de cette structure. C’est donc un meilleur outil d’apprentissage des concepts."
  },
  {
    "objectID": "02-structures/projet_detecteur_langue.html",
    "href": "02-structures/projet_detecteur_langue.html",
    "title": "Projet - Détecteur de langue",
    "section": "",
    "text": "Tour de Babel\n\n\nL’objectif final de ce projet est de produire un programme qui détecte dans quelle langue un texte est écrit, en s’appuyant sur une analyse fréquentielle des lettres du texte.\nIl s’agit d’un projet : les consignes sont donc volontairement très limitées et seul le résultat attendu est détaillé (cahier des charges). Il vous revient d’organiser votre travail comme vous le voulez : création de fichiers, de bibliothèques, recherches documentaires.\nVous pouvez exercer votre liberté et choisir le style de programmation qui vous plait : impératif, POO, modulaire …\nDes compléments facultatifs sont proposés pour les plus rapides.\n\n\nCréer un programme qui :\n\nlit un fichier texte (encodé en UTF-8) ;\ncrée un dictionnaire dont les clés sont les lettres de l’alphabet de “a” à “z” ;\nanalyse le contenu du fichier caractère par caractère et remplit le dictionnaire avec comme valeur le nombre d’apparitions de chacune des lettres dans le texte. Les lettres autres que les lettres “a” à “z” sont ignorées ;\ncrée un nouveau dictionnaire avec les mêmes clés, mais en valeurs les fréquences d’apparition de chaque lettre ;\naffiche un diagramme en barres de cette répartition de fréquences à l’aide de la librairie MatPlotLib.\n\nRemarques :\n\nil peut être judicieux de décomposer le programme en plusieurs fonctions ;\nvous rechercherez dans la documentation les exemples d’utilisation de MatPlotLib ;\nvoici un fichier texte pour tester votre programme : texte.\n\n\n\n\nLa fréquence d’apparition des lettres dans les différentes langues qui utilisent l’alphabet latin est différente. C’est pour cette raison que les points attribués aux différentes lettres ainsi que le nombre de ces lettres dans le jeu du Scrabble ne sont pas les mêmes dans tous les pays.\nLe tableau disponible sur Wikipédia à cette adresse : -Wikipédia- donne cette fréquence dans les langues les plus courantes.\nNous allons choisir comme signature d’une langue la liste des dix lettres les plus utilisées dans cette langue, de la plus utilisée à la moins utilisée.\nCréer un dictionnaire signature dont les clés sont le nom des langues sous forme de chaîne de caractères et les valeurs sont ces listes de dix lettres.\nPar exemple, l’appel signature[\"Français\"][0] retournera \"e\".\nOn se limitera aux langues suivantes : Français, Anglais, Allemand, Espagnol, Italien, Portugais, Espéranto, Polonais et Néerlandais.\n\n\n\nÀ partir du programme réalisé à l’étape 1, programmer une fonction qui, pour un fichier texte donné, crée une liste signature_texte avec pour éléments les dix lettres les plus utilisées dans ce texte, de la plus utilisée à la moins utilisée.\nÉcrire une fonction detecte_langue(texte) qui, à partir des éléments précédents, retourne le nom de la langue dans laquelle le texte donné en paramètre est le plus probablement écrit. Il vous faudra notamment choisir un moyen de comparer la liste signature_texte avec l’ensemble des listes du dictionnaire signature afin de trouver cette qui est la plus “proche”.\nPour tester votre programme, voici des fichiers texte dans les différentes langues concernées : textes (fichier .zip à décompresser).\nProposer des améliorations possibles.\n\n\n\nProgrammer une fonction detecte_langue(url) qui prend en argument l’adresse d’une page web et qui retourne le nom de la langue dans laquelle la page est le plus probablement écrite. Vous pourrez utiliser la bibliothèque Python BeautifulSoup qui permet d’extraire le texte présent dans les balises HTML d’une page web (voir la documentation)."
  },
  {
    "objectID": "02-structures/projet_detecteur_langue.html#étape-1",
    "href": "02-structures/projet_detecteur_langue.html#étape-1",
    "title": "Projet - Détecteur de langue",
    "section": "",
    "text": "Créer un programme qui :\n\nlit un fichier texte (encodé en UTF-8) ;\ncrée un dictionnaire dont les clés sont les lettres de l’alphabet de “a” à “z” ;\nanalyse le contenu du fichier caractère par caractère et remplit le dictionnaire avec comme valeur le nombre d’apparitions de chacune des lettres dans le texte. Les lettres autres que les lettres “a” à “z” sont ignorées ;\ncrée un nouveau dictionnaire avec les mêmes clés, mais en valeurs les fréquences d’apparition de chaque lettre ;\naffiche un diagramme en barres de cette répartition de fréquences à l’aide de la librairie MatPlotLib.\n\nRemarques :\n\nil peut être judicieux de décomposer le programme en plusieurs fonctions ;\nvous rechercherez dans la documentation les exemples d’utilisation de MatPlotLib ;\nvoici un fichier texte pour tester votre programme : texte."
  },
  {
    "objectID": "02-structures/projet_detecteur_langue.html#étape-2",
    "href": "02-structures/projet_detecteur_langue.html#étape-2",
    "title": "Projet - Détecteur de langue",
    "section": "",
    "text": "La fréquence d’apparition des lettres dans les différentes langues qui utilisent l’alphabet latin est différente. C’est pour cette raison que les points attribués aux différentes lettres ainsi que le nombre de ces lettres dans le jeu du Scrabble ne sont pas les mêmes dans tous les pays.\nLe tableau disponible sur Wikipédia à cette adresse : -Wikipédia- donne cette fréquence dans les langues les plus courantes.\nNous allons choisir comme signature d’une langue la liste des dix lettres les plus utilisées dans cette langue, de la plus utilisée à la moins utilisée.\nCréer un dictionnaire signature dont les clés sont le nom des langues sous forme de chaîne de caractères et les valeurs sont ces listes de dix lettres.\nPar exemple, l’appel signature[\"Français\"][0] retournera \"e\".\nOn se limitera aux langues suivantes : Français, Anglais, Allemand, Espagnol, Italien, Portugais, Espéranto, Polonais et Néerlandais."
  },
  {
    "objectID": "02-structures/projet_detecteur_langue.html#étape-3",
    "href": "02-structures/projet_detecteur_langue.html#étape-3",
    "title": "Projet - Détecteur de langue",
    "section": "",
    "text": "À partir du programme réalisé à l’étape 1, programmer une fonction qui, pour un fichier texte donné, crée une liste signature_texte avec pour éléments les dix lettres les plus utilisées dans ce texte, de la plus utilisée à la moins utilisée.\nÉcrire une fonction detecte_langue(texte) qui, à partir des éléments précédents, retourne le nom de la langue dans laquelle le texte donné en paramètre est le plus probablement écrit. Il vous faudra notamment choisir un moyen de comparer la liste signature_texte avec l’ensemble des listes du dictionnaire signature afin de trouver cette qui est la plus “proche”.\nPour tester votre programme, voici des fichiers texte dans les différentes langues concernées : textes (fichier .zip à décompresser).\nProposer des améliorations possibles."
  },
  {
    "objectID": "02-structures/projet_detecteur_langue.html#complément-facultatif",
    "href": "02-structures/projet_detecteur_langue.html#complément-facultatif",
    "title": "Projet - Détecteur de langue",
    "section": "",
    "text": "Programmer une fonction detecte_langue(url) qui prend en argument l’adresse d’une page web et qui retourne le nom de la langue dans laquelle la page est le plus probablement écrite. Vous pourrez utiliser la bibliothèque Python BeautifulSoup qui permet d’extraire le texte présent dans les balises HTML d’une page web (voir la documentation)."
  },
  {
    "objectID": "02-structures/TPDictionnaire.html",
    "href": "02-structures/TPDictionnaire.html",
    "title": "Dictionnaires (TP)",
    "section": "",
    "text": "T.P. Dictionnaires\nCe T. P. prend la forme d’un notebook Jupyter à compléter.\nTélécharger la notebook en cliquant sur le bouton ci-dessous et l’ouvrir dans Edupython pour le compléter.\nNotebook"
  },
  {
    "objectID": "02-structures/TPDictionnaires.html",
    "href": "02-structures/TPDictionnaires.html",
    "title": "T.P. Dictionnaires",
    "section": "",
    "text": "NSI Terminale"
  },
  {
    "objectID": "02-structures/TPDictionnaires.html#rappels-sur-les-dictionnaires",
    "href": "02-structures/TPDictionnaires.html#rappels-sur-les-dictionnaires",
    "title": "T.P. Dictionnaires",
    "section": "Rappels sur les dictionnaires",
    "text": "Rappels sur les dictionnaires\nDans cette partie, nous allons fabriquer un carnet d’adresse pour stocker des contacts.\n\nFabrication d’un contact\nChaque contact sera un dictionnaire dont les clés seront : - nom : Nom et prénom du contact - tel : N° de téléphone - rue : adresse complète - code : code postal - ville : ville\nCréez un dictionnaire nommé contact correspondant au contact suivant : &gt; Margaret Costa-Royer &gt; 08 06 18 37 28 &gt; 93, avenue Bruneau &gt; 13749 Perrot\n\n# YOUR CODE HERE\n\n\n# Vérification\nassert contact[\"nom\"] == \"Margaret Costa-Royer\"\nassert contact[\"tel\"] == \"08 06 18 37 28\"\nassert contact[\"ville\"] == \"Perrot\"\n\nAjouter une nouvelle entrée “passwd” dans le contact ayant pour valeur ‘s75JWikE&o’\n\n# YOUR CODE HERE\n\n\n# Vérification\nassert contact[\"passwd\"] == 's75JWikE&o'\n\n\n\nGénération automatique d’un contact\nÉcrire une fonction genere_contact() - qui ne prend aucun paramètre - qui renvoie un dictionnaire possédant les mêmes clés que le contact ci-dessus, y compris “passwd”\nOn pourra utiliser le module faker de python dont un exemple d’utilisation est donné dans la cellule ci-dessous.\n\n%pip install faker\n\n\nfrom faker import Faker\n\nfake = Faker(\"fr_FR\") # Générateur de données personnelles pour un français\n\nprint(fake.name())\nprint(fake.phone_number())\nprint(fake.street_address())\nprint(fake.postcode(), fake.city())\nprint(fake.password())\n\nRemarque : Si la cellule ci-dessus provoque une erreur disant que le module faker n’est pas disponible, vous pouvez l’installer dans l’environnement jupyter via la commande\n!pip install faker\n\ndef genere_contact():\n    \"\"\"Fabrique un contact factice et renvoie le contact sous forme d'un dictionnaire\"\"\"\n    # YOUR CODE HERE\n    \n\n\ncontact1 = genere_contact()\nassert type(contact1[\"nom\"]) == str\nassert \"ville\" in contact1"
  },
  {
    "objectID": "02-structures/TPDictionnaires.html#mise-en-pratique",
    "href": "02-structures/TPDictionnaires.html#mise-en-pratique",
    "title": "T.P. Dictionnaires",
    "section": "Mise en pratique",
    "text": "Mise en pratique\n\nFabrication du carnet d’adresse\nTout est à présent en place pour que nous puissions fabriquer notre carnet d’adresse.\n\nPremière implémentation\nDans une première approche, nous allons considérer que le carnet d’adresse sera une liste de contacts, chaque contact étant un dictionnaire dont la structure a été définie à la section précédente.\nFabriquez une fonction genere_carnet1 - prenant en paramètre le nombre n de contacts à générer - renvoyant une liste de n contacts générés aléatoirement.\n\ndef genere_carnet1(n):\n    \"\"\"Renvoie une liste de n contacts aléatoires\"\"\"\n    # YOUR CODE HERE\n    \n\n\n# vérification\n\ncarnet1 = genere_carnet1(10)\nassert type(carnet1) == list\nassert \"nom\" in carnet1[3]\n\nEcrire à présent une fonction est_present - prenant 2 paramètres : un nom et un carnet d’adresse - renvoyant True si le nom figure dans le carnet d’adresse, False sinon\n\ndef est_present(nom, carnet):\n    \"\"\"Teste si nom est présent dans le carnet d'adresse\"\"\"\n    # YOUR CODE HERE\n    \n\n\n# Vérification\n\ncarnet1 = genere_carnet1(10)\nnom = carnet1[-1][\"nom\"]\nassert est_present(nom, carnet1)\nassert not est_present(\"Géo Trouvetout\", carnet1)\n\n\n\nMesure de performance de la recherche\nNous allons regarder ici comment évolue la vitesse de recherche en fonction de la taille du carnet d’adresse. On utilisera pour cela la fonction magique de jupyter : %%timeit. Étudiez la cellule suivante :\n\n# Fabrication d'un carnet de 100 contacts\ncarnet1 = genere_carnet1(100)\nnom = carnet1[-1][\"nom\"]  # On récupère un nom du carnet\nnom\n\n\n%%timeit\n\n# On mesure le temps d'une recherche\nest_present(nom, carnet1) \n\nVous lisez sous la cellule le temps de recherche.\nA présent, on refait l’expérience pour 1000 contacts dans le carnet d’adresse.\n\ncarnet1 = genere_carnet1(1000)\nnom = carnet1[-1][\"nom\"]  # On récupère un nom du carnet\nnom\n\n\n%%timeit\n\n# On mesure le temps d'une recherche dans ce carnet\nest_present(nom, carnet1)\n\n\n\nSeconde implémentation\nVous devez avoir constaté ci-dessus que le temps de recherche est proportionnel à la taille du carnet d’adresse : si celui-ci contient 10 fois plus de contact, la recherche peut être jusqu’à 10 fois plus longue.\nNous allons changer d’approche et fabriquer un carnet d’adresse sous forme d’un dictionnaire dont les clés seront les noms et les valeurs seront les fiches contacts. Ainsi notre carnet d’adresse sera un dictionnaire dont les valeurs seront des dictionnaires !\nFabriquez une fonction genere_carnet2 - prenant en paramètre le nombre n de contacts à générer - renvoyant un dictionnaire de n contacts générés aléatoirement\n\ndef genere_carnet2(n):\n    \"\"\"Renvoie un dictionnaire de n contacts aléatoires\"\"\"\n    # YOUR CODE HERE\n    \n\n\n# Vérification\n\ncarnet2 = genere_carnet2(10)\nassert type(carnet2) == dict\nnom = list(carnet2.keys())[-1]\nassert type(carnet2[nom]) == dict\n\n\n\nMesure de performance de la recherche\nNous allons regarder pour cette nouvelle implémentation comment évolue la vitesse de recherche en fonction de la taille du carnet d’adresse. Validez les 2 cellules suivantes.\n\n# Fabrication d'un carnet de 100 contacts\ncarnet2 = genere_carnet2(100)\nnom = list(carnet2.keys())[-1] # On récupère un nom du carnet\nnom\n\n\n%%timeit\n\nnom in carnet2                 # On le recherche\n\nOn constate déjà que la recherche est plus rapide que pour la première implémentation du carnet à l’aide d’un tableau.\nRefaisons l’expérience avec 100 fois plus de contacts dans le carnet !!\n\n# Fabrication d'un carnet de 10000 contacts\ncarnet2 = genere_carnet2(10000)\nnom = list(carnet2.keys())[-1] # On récupère un nom du carnet\nnom\n\n\n%%timeit\n\nnom in carnet2           # On le recherche"
  },
  {
    "objectID": "02-structures/TPDictionnaires.html#conclusion",
    "href": "02-structures/TPDictionnaires.html#conclusion",
    "title": "T.P. Dictionnaires",
    "section": "Conclusion",
    "text": "Conclusion\nVous le constatez d’après les expériences ci-dessus : le temps de recherche dans le dictionnaire est pratiquement indépendant du nombre d’entrées dans ce dictionnaire, car en multipliant le nombre de contacts par 100, le temps est resté pratiquement identique alors que dans le cas de la recherche dans un tableau, celui-ci est proportionnel à la longueur du tableau.\nLe dictionnaire est donc une structure de données optimisée pour la recherche sur les clés."
  },
  {
    "objectID": "02-structures/TPDictionnaires_CORR.html",
    "href": "02-structures/TPDictionnaires_CORR.html",
    "title": "T.P. Dictionnaires",
    "section": "",
    "text": "NSI Terminale"
  },
  {
    "objectID": "02-structures/TPDictionnaires_CORR.html#rappels-sur-les-dictionnaires",
    "href": "02-structures/TPDictionnaires_CORR.html#rappels-sur-les-dictionnaires",
    "title": "T.P. Dictionnaires",
    "section": "Rappels sur les dictionnaires",
    "text": "Rappels sur les dictionnaires\nDans cette partie, nous allons fabriquer un carnet d’adresse pour stocker des contacts.\n\nFabrication d’un contact\nChaque contact sera un dictionnaire dont les clés seront : - nom : Nom et prénom du contact - tel : N° de téléphone - rue : adresse complète - code : code postal - ville : ville\nCréez un dictionnaire nommé contact correspondant au contact suivant : &gt; Margaret Costa-Royer &gt; 08 06 18 37 28 &gt; 93, avenue Bruneau &gt; 13749 Perrot\n\n# YOUR CODE HERE\ncontact = {\"nom\":\"Margaret Costa-Royer\", \"tel\":\"08 06 18 37 28\", \"rue\":\"93, avenue Bruneau\", \"code\":13749, \"ville\":\"Perrot\"}\n\n\n# Vérification\nassert contact[\"nom\"] == \"Margaret Costa-Royer\"\nassert contact[\"tel\"] == \"08 06 18 37 28\"\nassert contact[\"ville\"] == \"Perrot\"\n\nAjouter une nouvelle entrée “passwd” dans le contact ayant pour valeur ‘s75JWikE&o’\n\n# YOUR CODE HERE\ncontact[\"passwd\"] = \"s75JWikE&o\"\n\n\n# Vérification\nassert contact[\"passwd\"] == 's75JWikE&o'\n\n\n\nGénération automatique d’un contact\nÉcrire une fonction genere_contact() - qui ne prend aucun paramètre - qui renvoie un dictionnaire possédant les mêmes clés que le contact ci-dessus, y compris “passwd”\nOn pourra utiliser le module faker de python dont un exemple d’utilisation est donné dans la cellule ci-dessous.\n\n%pip install faker\n\n\nfrom faker import Faker\n\nfake = Faker(\"fr_FR\") # Générateur de données personnelles pour un français\n\nprint(fake.name())\nprint(fake.phone_number())\nprint(fake.street_address())\nprint(fake.postcode(), fake.city())\nprint(fake.password())\n\nHugues Monnier de Roger\n+33 (0)3 71 66 66 71\n866, boulevard de Texier\n82052 PhilippeBourg\ndy3Ixvj)^V\n\n\nRemarque : Si la cellule ci-dessus provoque une erreur disant que le module faker n’est pas disponible, vous pouvez l’installer dans l’environnement jupyter via la commande\n!pip install faker\n\ndef genere_contact():\n    \"\"\"Fabrique un contact factice et renvoie le contact sous forme d'un dictionnaire\"\"\"\n    # YOUR CODE HERE\n    fake = Faker(\"fr_FR\")\n    contact = {}\n    contact[\"nom\"] = fake.name()\n    contact[\"tel\"] = fake.phone_number()\n    contact[\"rue\"] = fake.street_address()\n    contact[\"code\"] = fake.postcode()\n    contact[\"ville\"] = fake.city()\n    contact[\"passwd\"] = fake.password()\n    return contact\n\n\ncontact1 = genere_contact()\nassert type(contact1[\"nom\"]) == str\nassert \"ville\" in contact1"
  },
  {
    "objectID": "02-structures/TPDictionnaires_CORR.html#mise-en-pratique",
    "href": "02-structures/TPDictionnaires_CORR.html#mise-en-pratique",
    "title": "T.P. Dictionnaires",
    "section": "Mise en pratique",
    "text": "Mise en pratique\n\nFabrication du carnet d’adresse\nTout est à présent en place pour que nous puissions fabriquer notre carnet d’adresse.\n\nPremière implémentation\nDans une première approche, nous allons considérer que le carnet d’adresse sera une liste de contacts, chaque contact étant un dictionnaire dont la structure a été définie à la section précédente.\nFabriquez une fonction genere_carnet1 - prenant en paramètre le nombre n de contacts à générer - renvoyant une liste de n contacts générés aléatoirement.\n\ndef genere_carnet1(n):\n    \"\"\"Renvoie une liste de n contacts aléatoires\"\"\"\n    # YOUR CODE HERE\n    liste = []\n    for k in range(n):\n        liste.append(genere_contact())\n    return liste\n\n\n# vérification\n\ncarnet1 = genere_carnet1(10)\nassert type(carnet1) == list\nassert \"nom\" in carnet1[3]\n\nEcrire à présent une fonction est_present - prenant 2 paramètres : un nom et un carnet d’adresse - renvoyant True si le nom figure dans le carnet d’adresse, False sinon\n\ndef est_present(nom, carnet):\n    \"\"\"Teste si nom est présent dans le carnet d'adresse\"\"\"\n    # YOUR CODE HERE\n    for contact in carnet:\n        if contact[\"nom\"] == nom:\n            return True\n    return False  \n\n\n# Vérification\n\ncarnet1 = genere_carnet1(10)\nnom = carnet1[-1][\"nom\"]\nassert est_present(nom, carnet1)\nassert not est_present(\"Géo Trouvetout\", carnet1)\n\n\n\nMesure de performance de la recherche\nNous allons regarder ici comment évolue la vitesse de recherche en fonction de la taille du carnet d’adresse. On utilisera pour cela la fonction magique de jupyter : %%timeit. Étudiez la cellule suivante :\n\n# Fabrication d'un carnet de 100 contacts\ncarnet1 = genere_carnet1(100)\nnom = carnet1[-1][\"nom\"]  # On récupère un nom du carnet\nnom\n\n'Roger Joseph-Charrier'\n\n\n\n%%timeit\n\n# On mesure le temps d'une recherche\nest_present(nom, carnet1) \n\n2.88 µs ± 14.8 ns per loop (mean ± std. dev. of 7 runs, 100,000 loops each)\n\n\nVous lisez sous la cellule le temps de recherche.\nA présent, on refait l’expérience pour 1000 contacts dans le carnet d’adresse.\n\ncarnet1 = genere_carnet1(1000)\nnom = carnet1[-1][\"nom\"]  # On récupère un nom du carnet\nnom\n\n'Benoît Mahe'\n\n\n\n%%timeit\n\n# On mesure le temps d'une recherche dans ce carnet\nest_present(nom, carnet1)\n\n33.9 µs ± 362 ns per loop (mean ± std. dev. of 7 runs, 10,000 loops each)\n\n\n\n\nSeconde implémentation\nVous devez avoir constaté ci-dessus que le temps de recherche est proportionnel à la taille du carnet d’adresse : si celui-ci contient 10 fois plus de contact, la recherche peut être jusqu’à 10 fois plus longue.\nNous allons changer d’approche et fabriquer un carnet d’adresse sous forme d’un dictionnaire dont les clés seront les noms et les valeurs seront les fiches contacts. Ainsi notre carnet d’adresse sera un dictionnaire dont les valeurs seront des dictionnaires !\nFabriquez une fonction genere_carnet2 - prenant en paramètre le nombre n de contacts à générer - renvoyant un dictionnaire de n contacts générés aléatoirement\n\ndef genere_carnet2(n):\n    \"\"\"Renvoie un dictionnaire de n contacts aléatoires\"\"\"\n    # YOUR CODE HERE\n    dico = {}\n    for k in range(n):\n        contact = genere_contact()\n        nom = contact[\"nom\"]\n        dico[nom] = contact\n    return dico    \n\n\n# Vérification\n\ncarnet2 = genere_carnet2(10)\nassert type(carnet2) == dict\nnom = list(carnet2.keys())[-1]\nassert type(carnet2[nom]) == dict\n\n\n\nMesure de performance de la recherche\nNous allons regarder pour cette nouvelle implémentation comment évolue la vitesse de recherche en fonction de la taille du carnet d’adresse. Validez les 2 cellules suivantes.\n\n# Fabrication d'un carnet de 100 contacts\ncarnet2 = genere_carnet2(100)\nnom = list(carnet2.keys())[-1] # On récupère un nom du carnet\nnom\n\n'Richard Andre'\n\n\n\n%%timeit\n\nnom in carnet2                 # On le recherche\n\n29.2 ns ± 0.196 ns per loop (mean ± std. dev. of 7 runs, 10,000,000 loops each)\n\n\nOn constate déjà que la recherche est plus rapide que pour la première implémentation du carnet à l’aide d’un tableau.\nRefaisons l’expérience avec 100 fois plus de contacts dans le carnet !!\n\n# Fabrication d'un carnet de 10000 contacts\ncarnet2 = genere_carnet2(10000)\nnom = list(carnet2.keys())[-1] # On récupère un nom du carnet\nnom\n\n'Guy Pereira de Blanc'\n\n\n\n%%timeit\n\nnom in carnet2           # On le recherche\n\n30.8 ns ± 0.21 ns per loop (mean ± std. dev. of 7 runs, 10,000,000 loops each)"
  },
  {
    "objectID": "02-structures/TPDictionnaires_CORR.html#conclusion",
    "href": "02-structures/TPDictionnaires_CORR.html#conclusion",
    "title": "T.P. Dictionnaires",
    "section": "Conclusion",
    "text": "Conclusion\nVous le constatez d’après les expériences ci-dessus : le temps de recherche dans le dictionnaire est pratiquement indépendant du nombre d’entrées dans ce dictionnaire, car en multipliant le nombre de contacts par 100, le temps est resté pratiquement identique alors que dans le cas de la recherche dans un tableau, celui-ci est proportionnel à la longueur du tableau.\nLe dictionnaire est donc une structure de données optimisée pour la recherche sur les clés."
  },
  {
    "objectID": "03-BDD/exercices.html",
    "href": "03-BDD/exercices.html",
    "title": "Bases de données (Exercices)",
    "section": "",
    "text": "Les exercices précédés du symbole  sont à faire sur machine, en sauvegardant le fichier si nécessaire.\nLes exercices précédés du symbole  doivent être résolus par écrit."
  },
  {
    "objectID": "03-BDD/exercices.html#exercice-1",
    "href": "03-BDD/exercices.html#exercice-1",
    "title": "Bases de données (Exercices)",
    "section": " Exercice 1",
    "text": "Exercice 1\nVoici un extrait d’une relation référençant des films :\n\n\n\nid\ntitre\nrealisateur\nann_sortie\nnote_sur_10\n\n\n\n\n1\nAlien, le huitième passager\nScott\n1979\n10\n\n\n2\nDune\nLynch\n1985\n5\n\n\n3\n2001 : l’odyssée de l’espace\nKubrick\n1968\n9\n\n\n4\nBlade Runner\nScott\n1982\n10\n\n\n\nListez les différents attributs de cette relation. Donnez le domaine de chaque attribut.\nPour chaque attribut dire si cet attribut peut jouer le rôle de clé primaire, vous n’oublierez pas de justifier vos réponses."
  },
  {
    "objectID": "03-BDD/exercices.html#exercice-2",
    "href": "03-BDD/exercices.html#exercice-2",
    "title": "Bases de données (Exercices)",
    "section": " Exercice 2",
    "text": "Exercice 2\nUn ski-club utilise une base de données constituée de 2 tables :\n\nune table ADHERENTS\nune table STATIONS\n\nDans la table ADHERENTS on trouve un attribut “ref_station” qui permet de connaître les stations de ski préférées des adhérents.\nTable ADHERENTS\n\n\n\nnum_licence\nnom\nprenom\nannee_naissance\nref_station\n\n\n\n\n12558\nDoe\nJohn\n1988\n5\n\n\n13668\nVect\nAlice\n1974\n6\n\n\n1777\nDect\nBob\n1967\n3\n\n\n13447\nBeau\nTristan\n1999\n4\n\n\n1141\nPabeau\nJohn\n1975\n3\n\n\n\ntable STATIONS\n\n\n\nref\nnom\naltitude_max\n\n\n\n\n3\nLe grand Bornand\n2050\n\n\n4\nLa clusaz\n2616\n\n\n5\nFlaine\n2510\n\n\n6\nAvoriaz\n2466\n\n\n\n\nComment appelle-t-on l’attribut ref_station de la table ADHERENTS ?\nÉcrire la requête SQL permettant d’obtenir le nom des stations ayant une altitude maxi strictement supérieure à 2500 m.\nÉcrire une requête SQL permettant d’obtenir le numéro de licence des adhérents nés après 1980 et ayant pour prénom John.\nDonnez le résultat de la requête SQL suivante :\n\nSELECT nom \nFROM ADHERENTS \nWHERE num_licence &gt; 2000 OR  ref_station = 3\n\nDonnez le résultat de la requête SQL suivante :\n\nSELECT STATIONS.nom\nFROM STATIONS\nINNER JOIN ADHERENTS ON ADHERENTS.ref_station = STATIONS.ref\nWHERE annee_naissance &gt; 1975"
  },
  {
    "objectID": "03-BDD/exercices.html#exercice-3-exercices-tirés-des-annales",
    "href": "03-BDD/exercices.html#exercice-3-exercices-tirés-des-annales",
    "title": "Bases de données (Exercices)",
    "section": " Exercice 3 : Exercices tirés des annales",
    "text": "Exercice 3 : Exercices tirés des annales\n\nMétropole 2022 Jour 1 : Exercice 2.\nMétropole 2022 Jour 2 : Exercice 4.\nAmérique du Nord 2022 Jour 1 : Exercice 1.\nAmérique du Nord 2022 Jour 2 : Exercice 3.\nCentres étrangers 2022 Jour 1 : Exercice 4.\nCentres étrangers 2022 Jour 2 : Exercice 3."
  },
  {
    "objectID": "03-BDD/exercices.html#exercice-4",
    "href": "03-BDD/exercices.html#exercice-4",
    "title": "Bases de données (Exercices)",
    "section": " Exercice 4",
    "text": "Exercice 4\nLe CNAM (Conservatoire National des Arts et Métiers) propose en ligne des travaux pratiques sur une base de données concernant les films de cinéma. À titre d’entraînement, ouvrir cet exerciseur (cliquer sur l’image ci-dessous) et essayer de formuler les requêtes correspondant aux suggestions de la colonne de droite. Les réponses sont disponibles sur le site, mais prenez le temps de chercher, d’essayer, et de vous corriger."
  },
  {
    "objectID": "03-BDD/exercices.html#problème",
    "href": "03-BDD/exercices.html#problème",
    "title": "Bases de données (Exercices)",
    "section": " Problème",
    "text": "Problème\nSerious game : meurtre à SQL City …"
  },
  {
    "objectID": "03-BDD/exercices.html#pour-les-plus-rapides",
    "href": "03-BDD/exercices.html#pour-les-plus-rapides",
    "title": "Bases de données (Exercices)",
    "section": " Pour les plus rapides",
    "text": "Pour les plus rapides\nSerious game : SQL Island …"
  },
  {
    "objectID": "03-BDD/index.html",
    "href": "03-BDD/index.html",
    "title": "Programme",
    "section": "",
    "text": "Le développement des traitements informatiques nécessite la manipulation de données de plus en plus nombreuses. Leur organisation et leur stockage constituent un enjeu essentiel de performance.\nLe recours aux bases de données relationnelles est aujourd’hui une solution très répandue. Ces bases de données permettent d’organiser, de stocker, de mettre à jour et d’interroger des données structurées volumineuses utilisées simultanément par différents programmes ou différents utilisateurs. Cela est impossible avec les représentations tabulaires étudiées en classe de première.\nDes systèmes de gestion de bases de données (SGBD) de très grande taille (de l’ordre du pétaoctet) sont au centre de nombreux dispositifs de collecte, de stockage et de production d’informations.\nL’accès aux données d’une base de données relationnelle s’effectue grâce à des requêtes d’interrogation et de mise à jour qui peuvent par exemple être rédigées dans le langage SQL (Structured Query Language). Les traitements peuvent conjuguer le recours au langage SQL et à un langage de programmation.\nIl convient de sensibiliser les élèves à un usage critique et responsable des données.\n\n\n\n\n\n\n\n\nContenus\nCapacités attendues\nCommentaires\n\n\n\n\nModèle relationnel : relation, attribut, domaine, clef primaire, clef étrangère, schéma relationnel.\nIdentifier les concepts définissant le modèle relationnel.\nCes concepts permettent d’exprimer les contraintes d’intégrité (domaine, relation et référence).\n\n\nBase de données relationnelle.\nSavoir distinguer la structure d’une base de données de son contenu. Repérer des anomalies dans le schéma d’une base de données.\nLa structure est un ensemble de schémas relationnels qui respecte les contraintes du modèle relationnel. Les anomalies peuvent être des redondances de données ou des anomalies d’insertion, de suppression, de mise à jour. On privilégie la manipulation de données nombreuses et réalistes.\n\n\nSystème de gestion de bases de données relationnelles.\nIdentifier les services rendus par un système de gestion de bases de données relationnelles : persistance des données, gestion des accès concurrents, efficacité de traitement des requêtes, sécurisation des accès.\nIl s’agit de comprendre le rôle et les enjeux des différents services sans en détailler le fonctionnement.\\"
  },
  {
    "objectID": "03-BDD/partie1.html",
    "href": "03-BDD/partie1.html",
    "title": "Le modèle relationnel (Cours - Partie 1)",
    "section": "",
    "text": "Une donnée est valeur numérisée décrivant de manière élémentaire un fait, une mesure, une réalité\nExemple : le nom de l’auteur, l’âge du capitaine, le titre du livre …\nLes données décrivent des entités du monde réel, elles-mêmes associées les unes aux autres.\nExemple : Nicolas Bouvier est un écrivain suisse auteur de récit de voyage culte “l’usage du monde” paru en 1963 : deux entités, liées par la notion d’auteur.\nUne base de données est un ensemble (potentiellement volumineux, mais pas forcément) de telles informations conformes à une structure prédéfinie au moment de la conception, avec, de plus, une caractéristique essentielle : on souhaite les mémoriser de manière persistante. La persistance désigne la capacité d’une base à exister indépendamment des applications qui la manipulent, ou du système qui l’héberge. On peut arrêter toutes les machines un soir et retrouver la base de données le lendemain. Cela implique qu’une base est toujours stockée sur un support comme les disques magnétiques qui préservent leur contenu même en l’absence d’alimentation électrique.\nOn arrive donc à la définition suivante :\n\n\n\n\n\n\nDéfinition\n\n\n\nUne base de données est ensemble d’informations structurées mémorisées sur un support persistant.\n\n\nUn fichier de base de données a nécessairement une structure qui permet d’une part de distinguer les données les unes des autres, et d’autre part de représenter leurs liens.\nPrenons l’exemple des fichiers CSV, l’une des structures les plus simples et les plus répandues, sur lesquels nous avons travaillé en première. Dans un fichier CSV, les données élémentaires sont représentées par des « champs » délimités par des virgules ou des points-virgule. Les champs sont associés les uns aux autres par le simple fait d’être placés dans une même ligne. Les lignes en revanche sont indépendantes les unes des autres. On peut placer autant de lignes que l’on veut dans un fichier, et même changer leur ordre sans que cela modifie en quoi que ce soit l’information représentée.\nVoici l’exemple de nos données, représentées en CSV.\n\"Bouvier\" ; \"Nicolas\"; \"L'usage du monde\" ; 1963\nOn comprend bien que le premier champ est le nom, le second le prénom, etc. Il paraît donc cohérent d’ajouter de nouvelles lignes comme:\n\"Bouvier\"   ; \"Nicolas\"; \"L'usage du monde\" ; 1963\n\"Stevenson\" ; \"Robert-Louis\"  ; \"Voyage dans les Cévennes avec un âne\" ; 1879\nOn a donné une structure régulière à nos informations, ce qui va permettre de les interroger et de les manipuler avec précision. On les stocke dans un fichier sur disque, et nous sommes donc en cours de constitution d’une véritable base de données. On peut en fait généraliser ce constat : une base de données est toujours un ensemble de fichiers, stockés sur une mémoire externe comme un disque, dont le contenu obéit à certaines règles de structuration.\nPeut-on se satisfaire de cette solution et imaginer que nous pouvons construire des applications en nous appuyant directement sur des fichiers structurés, par exemple des fichiers CSV ? C’est la méthode illustrée par la figure ci-dessous. Dans une telle situation, chaque utilisateur applique des programmes au fichier, pour en extraire des données, pour les modifier, pour les créer.\n\n\n\n\n\nCette approche soulève de nombreuses difficultés, parmi lesquelles :\n\nLourdeur d’accès aux données. En pratique, pour chaque accès, même le plus simple, il faudrait écrire un programme adapté à la structure du fichier. La production et la maintenance de tels programmes seraient extrêmement coûteuses.\nRisques élevés pour l’intégrité et la sécurité. Si tout programmeur peut accéder directement aux fichiers, il est impossible de garantir la sécurité et l’intégrité des données. Quelqu’un peut très bien par exemple, en toute bonne foi, faire une fausse manœuvre qui rend le fichier illisible.\nPas de contrôle de concurrence. Dans un environnement où plusieurs utilisateurs accèdent aux mêmes fichiers, comme sur la Fig. 1, des problèmes de concurrence d’accès se posent, notamment pour les mises à jour. Comment gérer par exemple la situation où deux utilisateurs souhaitent en même temps ajouter une ligne au fichier ?\nPerformances. Tant qu’un fichier ne contient que quelques centaines de lignes, on peut supposer que les performances ne posent pas de problème, mais que faire quand on atteint les Gigaoctets (1,000 Mégaoctets), ou même le Téraoctet (1,000 Gigaoctets) ? Maintenir des performances acceptables suppose la mise en œuvre d’algorithmes ou de structures de données demandant des compétences très avancées, probablement hors de portée du développeur d’application qui a, de toute façon, mieux à faire.\n\nPour surmonter ces problèmes des systèmes complexes capables d’offrir à la fois un accès simple, sécurisé, performant au contenu d’une base, et d’accomplir le tour de force de satisfaire de tels accès pour des dizaines, centaines ou même milliers d’utilisateurs simultanés, le tout en garantissant l’intégrité de la base même en cas de panne sont mis en place. De tels systèmes sont appelés Systèmes de Gestion de Bases de Données, SGBD en bref.\n\n\n\n\n\n\nDéfinition\n\n\n\nUn Système de Gestion de Bases de Données (SGBD) est un système informatique qui assure la gestion de l’ensemble des informations stockées dans une base de données. Il prend en charge, notamment, les deux grandes fonctionnalités suivantes :\n\nAccès aux fichiers de la base, garantissant leur intégrité, contrôlant les opérations concurrentes, optimisant les recherches et mises à jour.\nInteractions avec les applications et utilisateurs, grâce à des langages d’interrogation et de manipulation à haut niveau d’abstraction.\n\n\n\nAvec un SGBD, les applications n’ont plus jamais accès directement aux fichiers, et ne savent d’ailleurs même pas qu’ils existent, quelle est leur structure et où ils sont situés. L’architecture classique est celle illustrée par la figure ci-dessous. Le SGBD apparaît sous la forme d’un serveur, c’est-à-dire d’un processus informatique prêt à communiquer avec d’autres (les « clients ») via le réseau. Ce serveur est hébergé sur une machine (la « machine serveur ») et est le seul à pouvoir accéder aux fichiers contenant les données, ces fichiers étant le plus souvent stockés sur le disque de la machine serveur.\n\n\n\n\n\nLes applications utilisateurs, maintenant, accèdent à la base via le programme serveur auquel elles sont connectés. Elles transmettent des commandes (d’où le nom « d’applications clientes ») que le serveur se charge d’appliquer. Ces applications bénéficient donc des puissants algorithmes implantés par le SGBD dans son serveur, comme la capacité à gérer les accès concurrents, où à satisfaire avec efficacité des recherches portant sur de très grosses bases.\nCette architecture est à peu près universellement adoptée par tous les SGBD. Les notions suivantes et le vocabulaire associé, sont donc très importantes à retenir.\n\n\n\n\n\n\nDéfinitions\n\n\n\nProgramme serveur. Un SGBD est instancié sur une machine sous la forme d’un programme serveur qui gère une ou plusieurs bases de données, chacune constituée de fichiers stockés sur disque. Le programme serveur est seul responsable de tous les accès à une base, et de l’utilisation des ressources (mémoire, disques) qui servent de support à ces accès.\nClients (programmes). Les programmes (ou applications) clients se connectent au programme serveur via le réseau, lui transmettent des requêtes et reçoivent des données en retour. Ils ne disposent d’aucune information directe sur la base.\n\n\nLe fait que le serveur de données s’interpose entre les fichiers et les programmes clients a une conséquence extrêmement importante : ces clients, n’ayant pas accès aux fichiers, ne voient les données que sous la forme que veut bien leur présenter le serveur. Ce dernier peut donc choisir le mode de représentation qui lui semble le plus approprié : pour nous, ce sera sous forme de tables et nous parlerons alors de modèle relationnel.\nUne des propriétés les plus importantes des SGBD est donc la distinction entre plusieurs niveaux d’abstraction pour la représentation des données : le niveau logique et le niveau physique.\n\n\n\n\n\n\nDéfinition\n\n\n\n\nLe niveau physique est celui du codage des données dans des fichiers stockés sur disque.\nLe niveau logique est celui de la représentation les données dans des structures abstraites, proposées aux applications clientes, obtenues par conversion du niveau physique (pour nous ce sont des structures en tables)\n\n\n\nLa figure ci-dessous illustre les niveaux d’abstraction dans l’architecture d’un système de gestion de données. Les programmes clients ne voient que le niveau logique, c’est-à-dire des tables. Le serveur est chargé du niveau physique, de la conversion des données vers le niveau logique, et de toute la machinerie qui permet de faire fonctionner le système : mémoire, disques, algorithmes et structures de données. Tout cela est, encore une fois, invisible (et c’est tant mieux) pour les programmes clients qui peuvent se concentrer sur l’accès à des données présentées le plus simplement possible.\n\n\n\n\n\nPrécisions que les niveaux sont en grande partie indépendants, dans le sens où l’on peut modifier complètement l’organisation du niveau physique sans avoir besoin de changer qui que ce soit aux applications qui accèdent à la base. Cette indépendance logique-physique est très précieuse pour l’administration des bases de données.\nUn langage est nécessaire pour interagir avec les données (insérer, modifier, détruire, déplacer, protéger, etc.). Le langage permet de construire les commandes transmises au serveur.\nLe modèle relationnel s’est construit sur des bases formelles (mathématiques) rigoureuses, ce qui explique en grande partie sa robustesse et sa stabilité depuis l’essentiel des travaux qui l’ont élaboré, dans les années 70-80.\nLe langage SQL est utilisé depuis les années 1970 dans tous les systèmes relationnels.\nLe terme SQL désigne plus qu’un langage d’interrogation, même s’il s’agit de son principal aspect. La norme couvre également les mises à jour, la définition des tables, les contraintes portant sur les données, les droits d’accès. SQL est donc le langage à connaître pour interagir avec un système relationnel."
  },
  {
    "objectID": "03-BDD/partie1.html#introduction",
    "href": "03-BDD/partie1.html#introduction",
    "title": "Le modèle relationnel (Cours - Partie 1)",
    "section": "",
    "text": "Une donnée est valeur numérisée décrivant de manière élémentaire un fait, une mesure, une réalité\nExemple : le nom de l’auteur, l’âge du capitaine, le titre du livre …\nLes données décrivent des entités du monde réel, elles-mêmes associées les unes aux autres.\nExemple : Nicolas Bouvier est un écrivain suisse auteur de récit de voyage culte “l’usage du monde” paru en 1963 : deux entités, liées par la notion d’auteur.\nUne base de données est un ensemble (potentiellement volumineux, mais pas forcément) de telles informations conformes à une structure prédéfinie au moment de la conception, avec, de plus, une caractéristique essentielle : on souhaite les mémoriser de manière persistante. La persistance désigne la capacité d’une base à exister indépendamment des applications qui la manipulent, ou du système qui l’héberge. On peut arrêter toutes les machines un soir et retrouver la base de données le lendemain. Cela implique qu’une base est toujours stockée sur un support comme les disques magnétiques qui préservent leur contenu même en l’absence d’alimentation électrique.\nOn arrive donc à la définition suivante :\n\n\n\n\n\n\nDéfinition\n\n\n\nUne base de données est ensemble d’informations structurées mémorisées sur un support persistant.\n\n\nUn fichier de base de données a nécessairement une structure qui permet d’une part de distinguer les données les unes des autres, et d’autre part de représenter leurs liens.\nPrenons l’exemple des fichiers CSV, l’une des structures les plus simples et les plus répandues, sur lesquels nous avons travaillé en première. Dans un fichier CSV, les données élémentaires sont représentées par des « champs » délimités par des virgules ou des points-virgule. Les champs sont associés les uns aux autres par le simple fait d’être placés dans une même ligne. Les lignes en revanche sont indépendantes les unes des autres. On peut placer autant de lignes que l’on veut dans un fichier, et même changer leur ordre sans que cela modifie en quoi que ce soit l’information représentée.\nVoici l’exemple de nos données, représentées en CSV.\n\"Bouvier\" ; \"Nicolas\"; \"L'usage du monde\" ; 1963\nOn comprend bien que le premier champ est le nom, le second le prénom, etc. Il paraît donc cohérent d’ajouter de nouvelles lignes comme:\n\"Bouvier\"   ; \"Nicolas\"; \"L'usage du monde\" ; 1963\n\"Stevenson\" ; \"Robert-Louis\"  ; \"Voyage dans les Cévennes avec un âne\" ; 1879\nOn a donné une structure régulière à nos informations, ce qui va permettre de les interroger et de les manipuler avec précision. On les stocke dans un fichier sur disque, et nous sommes donc en cours de constitution d’une véritable base de données. On peut en fait généraliser ce constat : une base de données est toujours un ensemble de fichiers, stockés sur une mémoire externe comme un disque, dont le contenu obéit à certaines règles de structuration.\nPeut-on se satisfaire de cette solution et imaginer que nous pouvons construire des applications en nous appuyant directement sur des fichiers structurés, par exemple des fichiers CSV ? C’est la méthode illustrée par la figure ci-dessous. Dans une telle situation, chaque utilisateur applique des programmes au fichier, pour en extraire des données, pour les modifier, pour les créer.\n\n\n\n\n\nCette approche soulève de nombreuses difficultés, parmi lesquelles :\n\nLourdeur d’accès aux données. En pratique, pour chaque accès, même le plus simple, il faudrait écrire un programme adapté à la structure du fichier. La production et la maintenance de tels programmes seraient extrêmement coûteuses.\nRisques élevés pour l’intégrité et la sécurité. Si tout programmeur peut accéder directement aux fichiers, il est impossible de garantir la sécurité et l’intégrité des données. Quelqu’un peut très bien par exemple, en toute bonne foi, faire une fausse manœuvre qui rend le fichier illisible.\nPas de contrôle de concurrence. Dans un environnement où plusieurs utilisateurs accèdent aux mêmes fichiers, comme sur la Fig. 1, des problèmes de concurrence d’accès se posent, notamment pour les mises à jour. Comment gérer par exemple la situation où deux utilisateurs souhaitent en même temps ajouter une ligne au fichier ?\nPerformances. Tant qu’un fichier ne contient que quelques centaines de lignes, on peut supposer que les performances ne posent pas de problème, mais que faire quand on atteint les Gigaoctets (1,000 Mégaoctets), ou même le Téraoctet (1,000 Gigaoctets) ? Maintenir des performances acceptables suppose la mise en œuvre d’algorithmes ou de structures de données demandant des compétences très avancées, probablement hors de portée du développeur d’application qui a, de toute façon, mieux à faire.\n\nPour surmonter ces problèmes des systèmes complexes capables d’offrir à la fois un accès simple, sécurisé, performant au contenu d’une base, et d’accomplir le tour de force de satisfaire de tels accès pour des dizaines, centaines ou même milliers d’utilisateurs simultanés, le tout en garantissant l’intégrité de la base même en cas de panne sont mis en place. De tels systèmes sont appelés Systèmes de Gestion de Bases de Données, SGBD en bref.\n\n\n\n\n\n\nDéfinition\n\n\n\nUn Système de Gestion de Bases de Données (SGBD) est un système informatique qui assure la gestion de l’ensemble des informations stockées dans une base de données. Il prend en charge, notamment, les deux grandes fonctionnalités suivantes :\n\nAccès aux fichiers de la base, garantissant leur intégrité, contrôlant les opérations concurrentes, optimisant les recherches et mises à jour.\nInteractions avec les applications et utilisateurs, grâce à des langages d’interrogation et de manipulation à haut niveau d’abstraction.\n\n\n\nAvec un SGBD, les applications n’ont plus jamais accès directement aux fichiers, et ne savent d’ailleurs même pas qu’ils existent, quelle est leur structure et où ils sont situés. L’architecture classique est celle illustrée par la figure ci-dessous. Le SGBD apparaît sous la forme d’un serveur, c’est-à-dire d’un processus informatique prêt à communiquer avec d’autres (les « clients ») via le réseau. Ce serveur est hébergé sur une machine (la « machine serveur ») et est le seul à pouvoir accéder aux fichiers contenant les données, ces fichiers étant le plus souvent stockés sur le disque de la machine serveur.\n\n\n\n\n\nLes applications utilisateurs, maintenant, accèdent à la base via le programme serveur auquel elles sont connectés. Elles transmettent des commandes (d’où le nom « d’applications clientes ») que le serveur se charge d’appliquer. Ces applications bénéficient donc des puissants algorithmes implantés par le SGBD dans son serveur, comme la capacité à gérer les accès concurrents, où à satisfaire avec efficacité des recherches portant sur de très grosses bases.\nCette architecture est à peu près universellement adoptée par tous les SGBD. Les notions suivantes et le vocabulaire associé, sont donc très importantes à retenir.\n\n\n\n\n\n\nDéfinitions\n\n\n\nProgramme serveur. Un SGBD est instancié sur une machine sous la forme d’un programme serveur qui gère une ou plusieurs bases de données, chacune constituée de fichiers stockés sur disque. Le programme serveur est seul responsable de tous les accès à une base, et de l’utilisation des ressources (mémoire, disques) qui servent de support à ces accès.\nClients (programmes). Les programmes (ou applications) clients se connectent au programme serveur via le réseau, lui transmettent des requêtes et reçoivent des données en retour. Ils ne disposent d’aucune information directe sur la base.\n\n\nLe fait que le serveur de données s’interpose entre les fichiers et les programmes clients a une conséquence extrêmement importante : ces clients, n’ayant pas accès aux fichiers, ne voient les données que sous la forme que veut bien leur présenter le serveur. Ce dernier peut donc choisir le mode de représentation qui lui semble le plus approprié : pour nous, ce sera sous forme de tables et nous parlerons alors de modèle relationnel.\nUne des propriétés les plus importantes des SGBD est donc la distinction entre plusieurs niveaux d’abstraction pour la représentation des données : le niveau logique et le niveau physique.\n\n\n\n\n\n\nDéfinition\n\n\n\n\nLe niveau physique est celui du codage des données dans des fichiers stockés sur disque.\nLe niveau logique est celui de la représentation les données dans des structures abstraites, proposées aux applications clientes, obtenues par conversion du niveau physique (pour nous ce sont des structures en tables)\n\n\n\nLa figure ci-dessous illustre les niveaux d’abstraction dans l’architecture d’un système de gestion de données. Les programmes clients ne voient que le niveau logique, c’est-à-dire des tables. Le serveur est chargé du niveau physique, de la conversion des données vers le niveau logique, et de toute la machinerie qui permet de faire fonctionner le système : mémoire, disques, algorithmes et structures de données. Tout cela est, encore une fois, invisible (et c’est tant mieux) pour les programmes clients qui peuvent se concentrer sur l’accès à des données présentées le plus simplement possible.\n\n\n\n\n\nPrécisions que les niveaux sont en grande partie indépendants, dans le sens où l’on peut modifier complètement l’organisation du niveau physique sans avoir besoin de changer qui que ce soit aux applications qui accèdent à la base. Cette indépendance logique-physique est très précieuse pour l’administration des bases de données.\nUn langage est nécessaire pour interagir avec les données (insérer, modifier, détruire, déplacer, protéger, etc.). Le langage permet de construire les commandes transmises au serveur.\nLe modèle relationnel s’est construit sur des bases formelles (mathématiques) rigoureuses, ce qui explique en grande partie sa robustesse et sa stabilité depuis l’essentiel des travaux qui l’ont élaboré, dans les années 70-80.\nLe langage SQL est utilisé depuis les années 1970 dans tous les systèmes relationnels.\nLe terme SQL désigne plus qu’un langage d’interrogation, même s’il s’agit de son principal aspect. La norme couvre également les mises à jour, la définition des tables, les contraintes portant sur les données, les droits d’accès. SQL est donc le langage à connaître pour interagir avec un système relationnel."
  },
  {
    "objectID": "03-BDD/partie2.html",
    "href": "03-BDD/partie2.html",
    "title": "Le modèle relationnel (Cours - Partie 2)",
    "section": "",
    "text": "Définition\n\n\n\nLe modèle relationnel est une manière de modéliser les relations existantes entre plusieurs informations, et de les ordonner entre elles"
  },
  {
    "objectID": "03-BDD/partie2.html#relation-attributs-et-domaines",
    "href": "03-BDD/partie2.html#relation-attributs-et-domaines",
    "title": "Le modèle relationnel (Cours - Partie 2)",
    "section": "1. Relation, attributs et domaines",
    "text": "1. Relation, attributs et domaines\nUne relation peut être vue comme un tableau composé d’une en-tête (première ligne) et d’un corps.\nChaque ligne de la relation est un p-uplet et chaque colonne est un attribut (l’en-tête contient les intitulés des attributs).\n\n\n\n\n\nPour la relation ci-dessus, on retrouve les données concernant les établissements scolaires du second degré dans le Cantal.\nPour chaque attribut d’une relation, il est nécessaire de définir un domaine : Le domaine d’un attribut donné correspond à un ensemble fini ou infini de valeurs admissibles.\nPar exemple, le domaine de l’attribut “statut” correspond à l’ensemble des deux chaînes {“Public”, “Privé”}. L’attribut “nom” a pour domaine l’ensemble des chaînes de caractères (noté TEXT). L’attribut “codepostal” a pour domaine l’ensemble des entiers (noté INT).\nAu moment de la création d’une relation, il est nécessaire de renseigner le domaine de chaque attribut. Le SGBD s’assure qu’un élément ajouté à une relation respecte bien le domaine de l’attribut correspondant : si par exemple vous essayez d’ajouter un code postal non entier (par exemple 8.5), le SGBD signalera cette erreur et n’autorisera pas l’écriture de cette nouvelle donnée.\n\n\n\n\n\n\nRègles à respecter\n\n\n\nDans une relation, il est nécessaire de respecter les deux règles ci-dessous :\n\nles valeurs des attributs doivent être atomiques, c’est-à-dire d’un type simple et non d’un type construit (pas de listes, de tableaux, de p-uplets, …) ;\nil n’y a pas de doublons : les p-uplets sont tous différents.\n\n\n\nPour s’assurer qu’il n’y a pas de doublons dans une relation on ajoute en pratique un critère d’unicité sur l’un des attributs, la clef."
  },
  {
    "objectID": "03-BDD/partie2.html#clef-primaire-clef-étrangère",
    "href": "03-BDD/partie2.html#clef-primaire-clef-étrangère",
    "title": "Le modèle relationnel (Cours - Partie 2)",
    "section": "2. Clef primaire, clef étrangère",
    "text": "2. Clef primaire, clef étrangère\n\n\n\n\n\n\nDéfinition\n\n\n\nDans une relation, une clef primaire est un attribut (ou un groupes d’attributs) qui définit de manière unique chacun de p-uplets.\n\n\nEn d’autres termes, il s’agit d’un attribut tel que deux p-uplets sont égaux si, et seulement si, ils ont la même clef primaire.\nPar exemple, dans la table des établissements scolaires du Cantal, l’attribut “code” peut être choisi comme clef primaire, car il identifie de façon unique chaque établissement. L’attribut “commune” ne peut pas être choisi comme clef primaire, car plusieurs établissements existent dans une même commune.\nOn pourrait naïvement penser qu’il suffit de créer une unique relation et de tout mettre dedans pour avoir une base de données. En fait, une telle approche est inapplicable et il est indispensable de créer plusieurs relations, associées les unes aux autres.\nPrenons l’exemple des établissements scolaires, un parcours de la table nous montre que certaines informations sont répétées plusieurs fois, comme notamment le nom de la commune :\n\n\n\n\n\nCette duplication de l’information n’est pas souhaitable dans une base de donnée. La solution pour éviter cela est de travailler avec deux relations (deux tables) au lieu d’une, chacune des relations étant munie d’une clef primaire.\nNous allons pour cela considérer la table des communes du Cantal qui contient un attribut nommé “Code commune” qui peut être choisi comme clef primaire. Dans la relation des établissements, nous remplaçons le nom de la commune par la valeur du Code commune correspondante (attribut id_commune). Voici un extrait des deux relations obtenues :\n\n\n\n\n\n\n\n\n\n\nL’attribut id_commune permet de lier les deux relations : les communes sont représentées dans la relation des établissements par leur code dans la relation des communes. On dit que l’attribut id_commune est une clef étrangère.\n\n\n\n\n\n\nDéfinition\n\n\n\nSoient deux relations \\(R\\) et \\(S\\) de clefs primaires respectives \\(c_R\\) et \\(c_S\\).\nUne clef étrangère de \\(S\\) dans \\(R\\) est un attribut \\(ce\\) de \\(R\\) dont la valeur est toujours égale exactement à une des valeurs de \\(c_S\\).\nAutrement dit, \\(ce\\) correspond à un et un seul p-uplet de \\(S\\).\n\n\nDans notre exemple, l’attribut id_commune est une clef étrangère de la relation des communes dans la relation des établissements car c’est un attribut de la relation des établissements dont la valeur est toujours égale à une des valeurs de la clef primaire Code commune de la relation des communes.\nDeux contraintes doivent toujours être vérifiées avec les clefs :\n\n\n\n\n\n\nContraintes liées aux clefs\n\n\n\n\nContrainte d’unicité: une valeur de clef ne peut apparaître qu’une fois dans une relation.\nContrainte d’intégrité référentielle : la valeur d’une clef étrangère doit toujours être également une des valeurs de la clef référencée.\n\n\n\nCes deux contraintes garantissent l’absence totale de redondances et d’incohérences."
  },
  {
    "objectID": "03-BDD/partie2.html#schéma-relationnel",
    "href": "03-BDD/partie2.html#schéma-relationnel",
    "title": "Le modèle relationnel (Cours - Partie 2)",
    "section": "3. Schéma relationnel",
    "text": "3. Schéma relationnel\nLe schéma d’une base de données est constitué d’un ensemble de relations : on parle de schéma relationnel.\nLe schéma relationnel d’une base de données contient les informations suivantes :\n\nLes noms des différentes relations ;\npour chaque relation, la liste des attributs avec leur domaine respectif ;\npour chaque relation, la clef primaire et éventuellement les clefs étrangères\n\nNommons ETABLISSEMENTS et COMMUNES les deux relations utilisées ci-dessus. Le schéma relationnel peut s’écrire :\n\nETABLISSEMENTS(code: TEXT, nom: TEXT, statut: TEXT, codepostal: INT, #id_commune: INT, latitude: FLOAT, longitude: FLOAT)\nCOMMUNES(Code commune: INT, Nom de la commune: TEXT, Population totale: INT)\n\nLes attributs soulignés sont des clefs primaires, le # signifie que l’on a une clef étrangère.\nLe schéma relationnel peut être représenté sous forme graphique (image obtenue ici avec le logiciel DbSchema à partir de la base précédente légèrement modifiée : l’attribut Codepostal a été déplacé dans la relation COMMUNES) :"
  },
  {
    "objectID": "03-BDD/quiz.html#question-2",
    "href": "03-BDD/quiz.html#question-2",
    "title": "Quiz - Le modèle relationnel, SGBD",
    "section": "Question 2",
    "text": "Question 2"
  },
  {
    "objectID": "03-BDD/quiz.html#question-3",
    "href": "03-BDD/quiz.html#question-3",
    "title": "Quiz - Le modèle relationnel, SGBD",
    "section": "Question 3",
    "text": "Question 3"
  },
  {
    "objectID": "03-BDD/quiz.html#question-4",
    "href": "03-BDD/quiz.html#question-4",
    "title": "Quiz - Le modèle relationnel, SGBD",
    "section": "Question 4",
    "text": "Question 4"
  },
  {
    "objectID": "03-BDD/quiz.html#question-5",
    "href": "03-BDD/quiz.html#question-5",
    "title": "Quiz - Le modèle relationnel, SGBD",
    "section": "Question 5",
    "text": "Question 5"
  },
  {
    "objectID": "03-BDD/quiz.html#question-6",
    "href": "03-BDD/quiz.html#question-6",
    "title": "Quiz - Le modèle relationnel, SGBD",
    "section": "Question 6",
    "text": "Question 6"
  },
  {
    "objectID": "03-BDD/quiz.html#question-7",
    "href": "03-BDD/quiz.html#question-7",
    "title": "Quiz - Le modèle relationnel, SGBD",
    "section": "Question 7",
    "text": "Question 7"
  },
  {
    "objectID": "03-BDD/quiz.html#question-8",
    "href": "03-BDD/quiz.html#question-8",
    "title": "Quiz - Le modèle relationnel, SGBD",
    "section": "Question 8",
    "text": "Question 8"
  },
  {
    "objectID": "03-BDD/quiz.html#question-9",
    "href": "03-BDD/quiz.html#question-9",
    "title": "Quiz - Le modèle relationnel, SGBD",
    "section": "Question 9",
    "text": "Question 9"
  },
  {
    "objectID": "03-BDD/sql_cours.html",
    "href": "03-BDD/sql_cours.html",
    "title": "2. Le langage SQL (Cours)",
    "section": "",
    "text": "Version Notebook de ce cours\nNous avons étudié la structure d’une base de données relationnelle, nous allons maintenant apprendre à réaliser des requêtes, c’est-à-dire que nous allons apprendre à créer une base des données, créer des attributs, ajouter des données, modifier des données et enfin, nous allons surtout apprendre à interroger une base de données afin d’obtenir des informations.\nPour réaliser toutes ces requêtes, nous allons devoir apprendre un langage de requêtes : SQL (Structured Query Language). SQL est propre aux bases de données relationnelles.\nDans ce cours nous allons travailler avec SQLite. SQLite est un système de gestion de base de données relationnelle très répandu. Noter qu’il existe d’autres systèmes de gestion de base de données relationnelle comme MySQL ou PostgreSQL. Dans tous les cas, le langage de requête utilisé est le SQL (même si parfois on peut noter quelques petites différences). Ce qui sera vu ici avec SQLite pourra, à quelques petites modifications près, être utilisé avec, par exemple, MySQL.\nNous allons illustrer chacune des instructions SQL du programme avec la base de donnée Cantal.db contenant les deux tables “etablissements” et “communes” déjà rencontrées dans la partie précédente, dont voici un extrait (les noms des attributs ont été un peu modifiés (pas d’espaces) ; la copie d’écran est faite à partir de DB Browser for SqLite). De plus, nous avons déplacé l’attribut “Codepostal” de la table “etablissement” vers la table “communes”, ce qui est plus cohérent.\nSchéma relationnel :\nPour se connecter à cette base de donnée, vous pouvez utiliser le logiciel DB Browser (SqLite) ou bien Edupython (qui propose une version portable du même logiciel)"
  },
  {
    "objectID": "03-BDD/sql_cours.html#requêtes-dinterrogation",
    "href": "03-BDD/sql_cours.html#requêtes-dinterrogation",
    "title": "2. Le langage SQL (Cours)",
    "section": "1. Requêtes d’interrogation",
    "text": "1. Requêtes d’interrogation\n\nRequêtes simples\nQuand on désire extraire des informations d’une table, on effectue une requête d’interrogation à l’aide du mot clé SELECT. Voici un exemple de requête d’interrogation :\nSELECT Nomdelacommune, Populationtotale\nFROM communes\nCette requête va nous permettre d’obtenir le nom de la commune et sa population pour toutes les communes présentes dans la table “communes”.\nVoici le résultat de cette requête dans le logiciel DB Browser for SqLite :\n\n\n\n\n\nD’une façon générale, le mot clé SELECT est suivi par les attributs que l’on désire obtenir. Le mot clé FROM est suivi par la table concernée.\nNoter qu’il est possible d’obtenir tous les attributs sans être obligé de tous les noter grâce au caractère étoile * :\nSELECT *\nFROM communes\nest équivalent à :\nSELECT  Codecommune, Nomdelacommune, Populationtotale, Codepostal\nFROM communes\n\n\nRequêtes conditionnelles\nLa clause WHERE permet d’imposer une (ou des) condition(s) permettant de sélectionner uniquement certaines lignes.\nLa condition doit suivre le mot-clé WHERE.\nSELECT Nomdelacommune\nFROM communes\nWHERE Populationtotale &gt; 2500\nLa requête ci-dessus permettra d’afficher le nom des communes dont la population est strictement supérieure à 2500 habitants.\n\n\n\n\n\nIl est possible de combiner les conditions à l’aide d’un OR ou d’un AND :\nSELECT Nomdelacommune\nFROM communes\nWHERE Populationtotale &gt; 2500 AND Populationtotale &lt; 10000\nCette requête permet d’obtenir le nom des communes dont la population est comprise entre 2500 et 10000 habitants.\n\n\n\n\n\nLa requête ci-dessous permet d’afficher le nom des communes dont la population est supérieure à 5000 habitants OU dont le nom contient la lettre “Z” (noter le symbole “%” qui remplace n’importe quelle séquence de caractères en SQL).\nSELECT Nomdelacommune\nFROM communes\nWHERE Populationtotale &gt; 5000 OR Nomdelacommune LIKE \"%Z%\"\n\n\n\n\n\n\n\nOrdonner les résultats\nLa clause ORDER BY permet d’ordonner les résultats dans l’ordre croissant.\nSELECT Nomdelacommune, Populationtotale\nFROM communes\nWHERE Populationtotale &gt; 5000 ORDER BY Populationtotale\nCette requête affiche le nom et la population des communes de plus de 5000 habitants dans l’ordre croissant de leur population.\n\n\n\n\n\nPour ordonner les résultats dans l’ordre décroissant, on ajoute DESC.\nSi la clause ORDER BY porte sur un attribut de type TEXT, on aura un rangement dans l’ordre alphabétique.\nSELECT Nomdelacommune, Populationtotale\nFROM communes\nWHERE Populationtotale &gt; 5000 ORDER BY Nomdelacommune DESC\nCette requête affiche le nom et la population des communes de plus de 5000 habitants dans l’ordre inverse de l’ordre alphabétique de leur nom.\n\n\n\n\n\n\n\nÉviter les doublons\nPour éviter les doublons dans les résultats d’une requête, on peut ajouter la clause DISTINCT juste après SELECT.\nConsidérons par exemple la relation “communes”, la requête suivante a pour objectif d’afficher, dans l’ordre croissant, la liste des codes postaux des communes du Cantal :\nSELECT codepostal\nFROM communes\nORDER BY codepostal\n\n\n\n\n\nNous voyons que les codes postaux sont répétés autant de fois qu’il y a de communes desservies par ce code postal.\nLa requête suivante, avec la clause DISTINCT, permet de n’afficher qu’une fois chacun des codes postaux considérés :\nSELECT DISTINCT codepostal\nFROM communes\nORDER BY codepostal\n\n\n\n\n\n\n\nLes jointures\nUne requête dans une base de donnée peut nécessiter de regrouper des données provenant de différentes tables.\n\n\n\n\n\n\nDéfinition\n\n\n\nUne requête combinant les données de plusieurs relations (tables) est appelée une jointure.\n\n\nPoursuivons avec l’exemple de la base de données des établissements scolaires du Cantal qui comporte deux tables, dont on rappelle ci-dessous le schéma relationnel :\n\ncommunes(Codecommune: INT, Nomdelacommune: TEXT, Populationtotale: INT, Codepostal: INT)\netablissements(code: TEXT, nom: TEXT, statut: TEXT, #id_commune: INT, latitude: FLOAT, longitude: FLOAT)\n\n\n\n\n\n\nLa requête suivante permet d’obtenir la table des noms d’établissements suivis du nom de leur commune. Il faut pour cela joindre les informations de la table “etablissements” (pour le nom de l’établissement) avec celles de la table “communes” (pour le nom de la commune). L’élément qui permet cette jointure est la clef étrangère “id_commune” de la table “etablissements” qui fait référence à la clef primaire “Codecommune” de la table “communes”.\nSELECT etablissements.nom, communes.Nomdelacommune \nFROM etablissements JOIN communes \nON etablissements.id_commune = communes.Codecommune\nRésultat :\n\n\n\n\n\n\n\n\n\n\n\nRemarque\n\n\n\nLorsqu’on effectue une jointure, plusieurs tables sont en jeu. Pour davantage de clarté, il est recommandé de préfixer chaque attribut par le nom de la table dont il provient. On utilise pour cela un point : “etablissements.nom” est l’attribut nommé “nom” de la relation “etablissements”.\n\n\nIl est possible d’ajouter à la suite de la jointure une clause WHERE afin de ne sélectionner que quelques lignes de la table obtenue :\nSELECT etablissements.nom, communes.Nomdelacommune \nFROM etablissements JOIN communes \nON etablissements.id_commune = communes.Codecommune\nWHERE etablissements.nom LIKE \"Collège%\"\nRésultat la table de tous les collèges avec leur commune :"
  },
  {
    "objectID": "03-BDD/sql_cours.html#requêtes-de-mise-à-jour",
    "href": "03-BDD/sql_cours.html#requêtes-de-mise-à-jour",
    "title": "2. Le langage SQL (Cours)",
    "section": "2.2. Requêtes de mise à jour",
    "text": "2.2. Requêtes de mise à jour\n\nAjouter une entrée\nPour ajouter une entrée, nous utilisons la clause INSERT.\nSupposons par exemple qu’un nouvel établissement soit ouvert à Labrousse (code 85): il s’agit d’un lycée hôtelier public. La requête suivante permet de créer cette nouvelle entrée. Attention, l’ordre des valeurs données doit être strictement le même que l’ordre des attributs cités.\nINSERT INTO etablissements\n(code, nom, statut, id_commune, latitude, longitude)\nVALUES\n(\"0159999Z\", \"Lycée hôtelier du Cantal\", \"Public\", 85, 44.8572222, 2.5427778)\n\n\nModifier une entrée existante\nPour modifier un ou plusieurs attributs d’un p-uplet existant, on utilise la clause UPDATE.\nSupposons par exemple que le nouveau lycée soit en fait un lycée Privé et que son code soit “0158888Z” :\nUPDATE etablissements\nSET code=\"0158888Z\", statut=\"Privé\"\nWHERE code=\"0159999Z\"\nLa clause WHERE permet de spécifier le ou les p-uplets à modifier.\n\n\nSupprimer une entrée\nPour supprimer un p-uplet, on utilise la clause DELETE.\nFinalement, le projet de lycée hôtelier est abandonné :\nDELETE FROM etablissements\nWHERE code=\"0158888Z\"\n\n\n\n\n\n\nAttention !\n\n\n\nLa requête DELETE, sans clause WHERE, supprimera tous les p-uplets de la relation !"
  },
  {
    "objectID": "03-BDD/sql_cours.html#quelques-compléments",
    "href": "03-BDD/sql_cours.html#quelques-compléments",
    "title": "2. Le langage SQL (Cours)",
    "section": "2.3. Quelques compléments",
    "text": "2.3. Quelques compléments\nLe langage SQL propose aussi des fonctions d’agrégation permettant de faire quelques calculs à partir des données d’une table. En voici quelques exemples.\n\nCalculer une somme\nPar exemple, la somme des populations de toutes les communes du Cantal :\nSELECT SUM(Populationtotale)\nFROM communes\nRésultat : 149 664.\n\n\nCalculer une moyenne\nPar exemple, la population moyenne des communes du Cantal dont le code postal est 15250 (AVG = average):\nSELECT AVG(Populationtotale)\nFROM communes\nwhere Codepostal=15250\nRésultat : 1 099, 67\n\n\nCalculer un minimum ou un maximum\nLes fonctions MIN et MAX fonctionnent de la même façon.\nQuel est le nom et la population de la commune du Cantal la moins peuplée ?\nSELECT Nomdelacommune, Populationtotale\nFROM communes\nWHERE Populationtotale = (SELECT MIN(Populationtotale) FROM communes)\nRésultat : VALJOUZE, 23 habitants.\n\n\n\n\n\n\nRemarque\n\n\n\nCe dernier exemple est un peu plus compliqué que les précédents : on a en effet imbriqué deux requêtes l’une dans l’autre : on parle de requêtes composées. La requête “SELECT MIN(Populationtotale) FROM communes” située entre parenthèses retourne la valeur minimale des populations de toutes les communes. On demande ensuite le nom de la ou des communes dont la population est cette valeur minimale. Prenez le temps de bien comprendre cet exemple.\n\n\n\n\nCompter des données\nLa fonction COUNT permet de compter des données.\nCombien y a-t-il d’établissements scolaires dans le Cantal ?\nSELECT COUNT(*)\nFROM etablissements\nRésultat : 203\nCombien de communes possèdent le code postal 15250 ?\nSELECT COUNT(*)\nFROM communes\nWHERE Codepostal=15250\nRésultat : 9\nCombien de noms d’établissements différents parmi les établissements scolaires ?\nSELECT COUNT(DISTINCT nom)\nFROM etablissements\nRésultat : 88\nÀ quelle question répond la requête suivante ?\nSELECT COUNT(*)\nFROM etablissements JOIN communes \nON etablissements.id_commune=communes.Codecommune\nWHERE (etablissements.nom LIKE \"Collège%\") AND communes.Nomdelacommune=\"AURILLAC\"\n\n\n\n\n\n\nRéponse\n\n\n\n\n\nCombien y a-t-il de collèges à Aurillac ? Réponse : 5.\n\n\n\n\n\n\n\n\n\nPour compléter …\n\n\n\n\nExcellentes vidéos sur Lumni :\n\nQu’est-ce qu’une base de données relationnelle ?\nInterrogation d’une base de données relationnelle"
  },
  {
    "objectID": "03-BDD/TP1.html",
    "href": "03-BDD/TP1.html",
    "title": "TP 1 - Créer une base de données",
    "section": "",
    "text": "Objectifs\n\n\n\nUtiliser le logiciel “DB Browser for SqLite” et le langage SQL pour :\n\n créer une base de données ;\n ajouter des données dans une table ;\n écrire et tester différentes requêtes."
  },
  {
    "objectID": "03-BDD/TP1.html#création-dune-bdd-et-insertion-de-valeurs",
    "href": "03-BDD/TP1.html#création-dune-bdd-et-insertion-de-valeurs",
    "title": "TP 1 - Créer une base de données",
    "section": "1. Création d’une BDD et insertion de valeurs",
    "text": "1. Création d’une BDD et insertion de valeurs\nPour créer une base de données et effectuer des requêtes sur cette dernière, nous allons utiliser le logiciel “DB Browser for SQLite” : https://sqlitebrowser.org/. Ce logiciel est intégré dans EduPython.\n\nOuvrez le logiciel, puis cliquez sur “Nouvelle base de données”. Après avoir choisi un nom pour votre base de données (par exemple “db_livres.db”), vous devriez avoir la fenêtre suivante :\n\n\n\n\n\nCliquez alors sur “Annuler”.\nUne nouvelle base de donnée a bien été créée, mais elle ne contient encore aucune table.\n\n\n\n\n\nPour créer une table, cliquez sur l’onglet “Exécuter le SQL”. On obtient alors :\n\n\n\n\n\nCopiez-collez le texte ci-dessous dans la fenêtre “SQL 1” :\nCREATE TABLE LIVRES\n    (id INT, titre TEXT, auteur TEXT, ann_publi INT, note INT, PRIMARY KEY (id));\nCliquez ensuite sur le petit triangle situé au-dessus de la fenêtre SQL 1 (ou appuyez sur F5), vous devriez avoir ceci :\n\n\n\n\n\nComme indiqué dans la fenêtre, “Requête exécutée avec succès” !\nQuelques explications : la commande CREATE TABLE LIVRES permet de créer une nouvelle table nommée “LIVRES”. Elle est suivie d’un p-uplet définissant les noms et les domaines des attributs de la nouvelle table :\n\nid est un entier ;\ntitre est une chaîne de caractères ;\nauteur est une chaîne de caractères ;\nann_pulbi est un entier ;\nnote est un entier ;\n\nL’attribut “id” va jouer le rôle de clé primaire, nous avons donc ajouté dans la requête la mention (PRIMARY KEY (id)). Le système de gestion de base de données nous avertira si l’on tente d’attribuer 2 fois la même valeur à l’attribut “id”.\nNous allons maintenant ajouter des données à la table LIVRES.\nToujours dans l’onglet “Exécuter le SQL”, après avoir effacé la fenêtre SQL 1, copiez-collez dans cette même fenêtre la requête ci-dessous :\nINSERT INTO LIVRES\n    (id,titre,auteur,ann_publi,note)\n    VALUES\n    (1,\"1984\",\"Orwell\",1949,10),\n    (2,\"Dune\",\"Herbert\",1965,8),\n    (3,\"Fondation\",\"Asimov\",1951,9),\n    (4,\"Le meilleur des mondes\",\"Huxley\",1931,7),\n    (5,\"Fahrenheit 451\",\"Bradbury\",1953,7),\n    (6,\"Ubik\",\"K.Dick\",1969,9),\n    (7,\"Chroniques martiennes\",\"Bradbury\",1950,8),\n    (8,\"La nuit des temps\",\"Barjavel\",1968,7),\n    (9,\"Blade Runner\",\"K.Dick\",1968,8),\n    (10,\"Les Robots\",\"Asimov\",1950,9),\n    (11,\"La Planète des singes\",\"Boulle\",1963,8),\n    (12,\"Ravage\",\"Barjavel\",1943,8),\n    (13,\"Le Maître du Haut Château\",\"K.Dick\",1962,8),\n    (14,\"Le monde des Ā\",\"Van Vogt\",1945,7),\n    (15,\"La Fin de l'éternité\",\"Asimov\",1955,8),\n    (16,\"De la Terre à la Lune\",\"Verne\",1865,10);\nUn message devrait vous préciser que votre requête a été exécutée avec succès :\n\n\n\n\n\nLa table LIVRES contient maintenant les données souhaitées (onglet “Parcourir les données”) :\n\n\n\n\n\nSaisissez et exécutez la requête SQL suivante :\nSELECT id, titre, auteur, ann_publi, note\nFROM LIVRES\nAprès un temps plus ou moins long, vous devriez voir s’afficher ceci :\n\n\n\n\n\nEffectuez une requête qui permettra d’obtenir le titre et l’auteur de tous les livres présents dans la table LIVRES.\nSaisissez et testez la requête SQL suivante :\nSELECT titre, ann_publi\nFROM LIVRES\nWHERE auteur='Asimov'\nÀ quelle question répond-elle ?\nÉcrivez et testez une requête permettant d’obtenir uniquement les titres des livres écrits par Philip K.Dick.\nSaisissez et testez la requête SQL suivante :\nSELECT titre, ann_publi\nFROM LIVRES\nWHERE auteur='Asimov' AND ann_publi&gt;1953\nÀ quelle question répond-elle ?\nÉcrivez une requête permettant d’obtenir les titres des livres publiés après 1945 qui ont une note supérieure ou égale à 9.\nÉcrivez une requête SQL permettant d’obtenir les titres et les années de publication des livres de K.Dick classés du plus ancien ou plus récent."
  },
  {
    "objectID": "03-BDD/TP1.html#avec-deux-tables",
    "href": "03-BDD/TP1.html#avec-deux-tables",
    "title": "TP 1 - Créer une base de données",
    "section": "2. Avec deux tables",
    "text": "2. Avec deux tables\nDans la première partie, nous avons une redondance d’information dans l’attribut auteur, un même auteur étant répété plusieurs fois. Pour remédier à cela, nous allons maintenant créer une nouvelle base avec deux tables AUTEURS et LIVRES reliées par une clef étrangère.\n\n\n\n\n\n\nCréez une nouvelle base de données que vous nommerez par exemple db_livres_auteurs.db, puis créez une table AUTEURS à l’aide de la requête SQL suivante :\nCREATE TABLE AUTEURS\n(id INT, nom TEXT, prenom TEXT, ann_naissance INT, langue_ecriture TEXT, PRIMARY KEY (id));\nCréez ensuite une deuxième table (LIVRES) :\nCREATE TABLE LIVRES\n(id INT, titre TEXT, id_auteur INT, ann_publi INT, note INT, PRIMARY KEY (id), FOREIGN KEY (id_auteur) REFERENCES AUTEURS(id));\nDans la création de la table LIVRES, nous avons précisé que l’attribut “id_auteur” jouera le rôle de clé étrangère : liaison entre “id_auteur” de la table LIVRES et “id” de la table AUTEURS (FOREIGN KEY (id_auteur) REFERENCES AUTEURS(id)).\nAjoutez des données à la table AUTEURS à l’aide de la requête SQL suivante :\nINSERT INTO AUTEURS\n(id,nom,prenom,ann_naissance,langue_ecriture)\nVALUES\n(1,\"Orwell\",\"George\",1903,\"anglais\"),\n(2,\"Herbert\",\"Frank\",1920,\"anglais\"),\n(3,\"Asimov\",\"Isaac\",1920,\"anglais\"),\n(4,\"Huxley\",\"Aldous\",1894,\"anglais\"),\n(5,\"Bradbury\",\"Ray\",1920,\"anglais\"),\n(6,\"K.Dick\",\"Philip\",1928,\"anglais\"),\n(7,\"Barjavel\",\"René\",1911,\"français\"),\n(8,\"Boulle\",\"Pierre\",1912,\"français\"),\n(9,\"Van Vogt\",\"Alfred Elton\",1912,\"anglais\"),\n(10,\"Verne\",\"Jules\",1828,\"français\");\nAjoutez des données à la table LIVRES à l’aide de la requête SQL suivante :\nINSERT INTO LIVRES\n(id,titre,id_auteur,ann_publi,note)\nVALUES\n(1,\"1984\",1,1949,10),\n(2,\"Dune\",2,1965,8),\n(3,\"Fondation\",3,1951,9),\n(4,\"Le meilleur des mondes\",4,1931,7),\n(5,\"Fahrenheit 451\",5,1953,7),\n(6,\"Ubik\",6,1969,9),\n(7,\"Chroniques martiennes\",5,1950,8),\n(8,\"La nuit des temps\",7,1968,7),\n(9,\"Blade Runner\",6,1968,8),\n(10,\"Les Robots\",3,1950,9),\n(11,\"La Planète des singes\",8,1963,8),\n(12,\"Ravage\",7,1943,8),\n(13,\"Le Maître du Haut Château\",6,1962,8),\n(14,\"Le monde des Ā\",9,1945,7),\n(15,\"La Fin de l'éternité\",3,1955,8),\n(16,\"De la Terre à la Lune\",10,1865,10);\nSaisissez et testez la requête SQL suivante :\nSELECT titre,nom, prenom\nFROM LIVRES JOIN AUTEURS \nON LIVRES.id_auteur = AUTEURS.id\nRemarque : attention, si un même nom d’attribut est présent dans les 2 tables (par exemple ici l’attribut id), il est nécessaire d’ajouter le nom de la table devant afin de pouvoir les distinguer (AUTEURS.id et LIVRES.id).\nÉcrivez une requête SQL permettant d’obtenir les titres des livres publiés après 1945 ainsi que le nom de leurs auteurs.\nOn souhaite ajouter à la base le livre de Arthur C.Clarke intitulé 2001 : L’Odyssée de l’espace publié en 1968 et noté 7. Arthur C.Clarke est un écrivain britannique né en 1917 et mort en 2008.\nÉcrivez les requêtes nécessaires à cet ajout. Vous n’oublierez pas de définir les clefs primaires pour chacune des nouvelles entrées.\nÉcrivez et testez une requête permettant d’attribuer la note de 10 à tous les livres écrits par Asimov publiés après 1950.\nÉcrivez une requête permettant de supprimer les livres publiés avant 1945. Testez cette requête."
  },
  {
    "objectID": "03-BDD/TP2.html",
    "href": "03-BDD/TP2.html",
    "title": "TP 2 - Le supermarché",
    "section": "",
    "text": "Objectifs\n\n\n\n\n écrire un schéma relationnel ;\n manipuler des requêtes SQL ;\n utiliser un SGBD."
  },
  {
    "objectID": "03-BDD/TP2.html#première-partie-travail-débranché",
    "href": "03-BDD/TP2.html#première-partie-travail-débranché",
    "title": "TP 2 - Le supermarché",
    "section": "Première partie : travail débranché",
    "text": "Première partie : travail débranché\nSans utiliser l’ordinateur, répondre aux questions de la fiche ci-dessous."
  },
  {
    "objectID": "03-BDD/TP2.html#vérifications-avec-db-browser-sqlite-et-compléments",
    "href": "03-BDD/TP2.html#vérifications-avec-db-browser-sqlite-et-compléments",
    "title": "TP 2 - Le supermarché",
    "section": "Vérifications avec DB Browser SqLite et compléments",
    "text": "Vérifications avec DB Browser SqLite et compléments\n\nOuvrir dans le logiciel la table ExerciceSupermarche.db.\nVérifier les requêtes écrites dans la première partie.\nInsérer dans la base de données un nouveau client en utilisant vos propres informations personnelles.\nModifier vos données en vous donnant le prénom “Toto”.\nSupprimer votre enregistrement de la table “Clients”."
  },
  {
    "objectID": "03-BDD/TP3.html",
    "href": "03-BDD/TP3.html",
    "title": "TP 3 - BDD et Python",
    "section": "",
    "text": "Dans ce TP (source : LASSUS (2021)), nous allons créer et interroger une base de données sqlite avec le module sqlite3 de Python."
  },
  {
    "objectID": "03-BDD/TP3.html#création-dune-table",
    "href": "03-BDD/TP3.html#création-dune-table",
    "title": "TP 3 - BDD et Python",
    "section": "Création d’une table",
    "text": "Création d’une table\nimport sqlite3\n\n#Connexion\nconnexion = sqlite3.connect('mynewbase.db')\n\n#Récupération d'un curseur\nc = connexion.cursor()\n\n# ---- début des instructions SQL\n\n#Création de la table\nc.execute(\"\"\"\n    CREATE TABLE IF NOT EXISTS bulletin(\n    Nom TEXT,\n    Prénom TEXT,\n    Note INT);\n    \"\"\")\n\n# ---- fin des instructions SQL\n\n#Validation\nconnexion.commit()\n\n\n#Déconnexion\nconnexion.close()\n\nLe fichier mynewbase.db sera créé dans le même répertoire que le fichier source Python. Si le fichier existe déjà, il est ouvert et peut être modifié.\nIF NOT EXISTS assure de ne pas écraser une table existante qui porterait le même nom. Si une telle table existe, elle n’est alors pas modifiée.\nLa nouvelle table peut être ouverte avec DB Browser pour vérifier sa structure et ses données."
  },
  {
    "objectID": "03-BDD/TP3.html#insertion-denregistrements-dans-la-table",
    "href": "03-BDD/TP3.html#insertion-denregistrements-dans-la-table",
    "title": "TP 3 - BDD et Python",
    "section": "Insertion d’enregistrements dans la table",
    "text": "Insertion d’enregistrements dans la table\nLes morceaux de code ci-dessous sont à positionner entre les balises # ---- début des instructions SQL et # ---- fin des instructions SQL.\n\nInsertion d’un enregistrement unique\nc.execute('''INSERT INTO bulletin VALUES ('Simpson', 'Bart', 17)''')\nPensez à vérifier avec DB Browser si les modifications sont effectives.\n\n\nInsertion d’un enregistrement unique avec variable\ndata = ('Simpson', 'Maggie', 2)\nc.execute('''INSERT INTO bulletin VALUES (?,?,?)''', data)\n\n\nInsertion de multiples enregistrements\nlst_notes = [ ('Simpson', 'Lisa', 19), ('Muntz', 'Nelson', 4), ('Van Houten', 'Milhouse', 12) ]\n\nc.executemany('''INSERT INTO bulletin VALUES (?, ?, ?)''', lst_notes)\nLes différentes valeurs sont stockées au préalable dans une liste de tuples.\n\n\nMini-projet 1\nCréer un programme qui demande à l’utilisateur un nom et une note, en boucle. Les résultats sont stockés au fur et à mesure dans une base de données. Si le nom est égal à «Q» ou «q», le programme s’arrête.\n\n\nExemple d’injection SQL\nL’injection SQL est une technique consistant à écrire du code SQL à un endroit qui n’est pas censé en recevoir.\n\nCréez un fichier contenant le code suivant :\n\nimport sqlite3\n\n#Connexion\nconnexion = sqlite3.connect('mabasecobaye.db')\n\n#Récupération d'un curseur\nc = connexion.cursor()\n\nc.execute(\"\"\"\n    CREATE TABLE IF NOT EXISTS notes(\n    Nom TEXT,\n    Note INT);\n    \"\"\")\n\nwhile True :\n    nom = input('Nom ? ')\n    if nom in ['Q','q'] :\n        break\n    note = input('Note ? ')\n    data = (nom, note)\n    p = \"INSERT INTO notes VALUES ('\" + nom + \"','\" + note + \"')\"\n\n    c.executescript(p)\n\n#Validation\nconnexion.commit()\n\n#Déconnexion\nconnexion.close()\n\nExécutez ce fichier, rentrez quelques valeurs, quittez et ouvrez dans DB Browser la table notes pour bien vérifier que vos valeurs ont bien été stockées.\nLancez à nouveau le fichier, en donnant ensuite comme nom la chaîne de caractères suivante : g','3'); DROP TABLE notes;--\nDonnez une note quelconque (par exemple 12), quittez le programme… et allez observer l’état de la base de données. La table notes n’existe plus !\n\nExplication :\nLa requête qui a été formulée est INSERT INTO notes VALUES ('g','3'); DROP TABLE notes;--','12')\nDans un premier temps, le couple ('g','3') a été inséré.\nPuis l’ordre a été donné de détruire la table notes.\nLe reste du code (qui n’est pas correct) est ignoré car -- est le symbole du commentaire en SQL (l’équivalent du # de Python).\nRemarques : Évidemment, ce code a été fait spécifiquement pour être vulnérable à l’injection SQL. Il suffit d’ailleurs de remplacer le c.executescript(p) par c.execute(p) pour que le code reste fonctionnel, mais refuse l’injection SQL. Ceci dit, de nombreux serveurs sont encore attaqués par cette technique, au prix de manipulations bien sûr plus complexes que celles que nous venons de voir.\nRappelons enfin que ce genre de pratiques est interdit sur un serveur qui ne vous appartient pas."
  },
  {
    "objectID": "03-BDD/TP3.html#lecture-des-enregistrements",
    "href": "03-BDD/TP3.html#lecture-des-enregistrements",
    "title": "TP 3 - BDD et Python",
    "section": "Lecture des enregistrements",
    "text": "Lecture des enregistrements\nimport sqlite3\n\n#Connexion\nconnexion = sqlite3.connect('mynewbase.db')\n\n#Récupération d'un curseur\nc = connexion.cursor()\n\ndata = ('Simpson', )\n\nc.execute(\"SELECT Prénom FROM Bulletin WHERE Nom = ?\", data)\nprint(c.fetchall())  \n\n\n#Déconnexion\nconnexion.close()\nCe code renvoie [('Homer',), ('Lisa',), ('Maggie',)], ou une liste vide s’il n’y a pas de résultat à la requête.\n\nMini-projet 2\nReprendre le mini-projet précédent, en rendant possible à l’utilisateur de rentrer des notes ou bien de les consulter.\nExemple :"
  },
  {
    "objectID": "04-arbres/arbres_cours.html",
    "href": "04-arbres/arbres_cours.html",
    "title": "Arbres (Cours)",
    "section": "",
    "text": "Définition\n\n\n\nEn informatique, un arbre est une structure de données qui peut se représenter sous forme d’une hiérarchie dont chaque élément est appelé nœud, le nœud initial étant appelé racine.\n\n\n\n\n\n\n\n\n\n\n\n\n\nVocabulaire\n\n\n\n\nChaque nœud a exactement un nœud père, sauf le nœud racine (situé en haut) qui n’a pas de père.\nUn nœud peut avoir une nombre quelconque de fils.\nLes nœuds qui n’ont pas de fils sont appelés des feuilles (situées aux extrémités des branches !).\nLes nœuds possèdent une valeur, ou clef, ou encore étiquette.\n\n\n\nPar exemple, dans l’arbre représenté ci-dessus :\n\n\n\n\n\n\nExemple\n\n\n\n\nLa racine possède l’étiquette D.\nLe nœud père D a trois fils U, L et A.\nLe nœud V a pour père le nœud A.\nLes nœuds C, L et X sont des feuilles.\n\n\n\n\n\n\n\nVoici quelques exemples de situations dans lesquelles une structure de données arborescente est utile.\n\n\nDéjà rencontrée dans le chapitre sur les systèmes d’exploitation en première, une arborescence de dossiers dans un disque dur peut être modélisée par un arbre.\n\n\n\n\n\n\n\n\nLE DOM (Document Object Model) est une interface de programmation pour les pages web dans laquelle une page HTML est modélisée sous la forme d’un arbre.\nPar exemple, le code HTML ci-dessous sera modélisé par l’arbre en-dessous (source : w3.org).\n&lt;TABLE&gt;\n    &lt;ROWS&gt; \n      &lt;TR&gt; \n        &lt;TD&gt;Shady Grove&lt;/TD&gt;\n        &lt;TD&gt;Aeolian&lt;/TD&gt; \n      &lt;/TR&gt; \n      &lt;TR&gt;\n        &lt;TD&gt;Over the River, Charlie&lt;/TD&gt;\n        &lt;TD&gt;Dorian&lt;/TD&gt; \n      &lt;/TR&gt; \n    &lt;/ROWS&gt;\n&lt;/TABLE&gt;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDifférents paramètres numériques peuvent être définis concernant un arbre.\n\n\n\n\n\n\nDéfinitions\n\n\n\n\nLa taille d’un arbre est son nombre total de nœuds.\nLa profondeur d’un nœud est le nombre de nœuds de la branche allant de la racine à ce nœud, en comptant les extrémités.\nLa hauteur d’un arbre est la profondeur de son nœud le plus profond. Par convention, si l’arbre est vide, sa hauteur vaut 0, si l’arbre n’est composé que d’un nœud racine, sa hauteur vaut 1.\n\n\n\n\n\n\n\n\n\nExemple\n\n\n\nConsidérons l’arbre ci-dessous :\n\n\n\n\n\n\nLa taille de cet arbre est égale à 7.\nLa profondeur du nœud C est égale à 3, celle de X est égale à 4.\nLa hauteur de cet arbre est égale à 4 : X est le nœud le plus profond."
  },
  {
    "objectID": "04-arbres/arbres_cours.html#introduction",
    "href": "04-arbres/arbres_cours.html#introduction",
    "title": "Arbres (Cours)",
    "section": "",
    "text": "Définition\n\n\n\nEn informatique, un arbre est une structure de données qui peut se représenter sous forme d’une hiérarchie dont chaque élément est appelé nœud, le nœud initial étant appelé racine.\n\n\n\n\n\n\n\n\n\n\n\n\n\nVocabulaire\n\n\n\n\nChaque nœud a exactement un nœud père, sauf le nœud racine (situé en haut) qui n’a pas de père.\nUn nœud peut avoir une nombre quelconque de fils.\nLes nœuds qui n’ont pas de fils sont appelés des feuilles (situées aux extrémités des branches !).\nLes nœuds possèdent une valeur, ou clef, ou encore étiquette.\n\n\n\nPar exemple, dans l’arbre représenté ci-dessus :\n\n\n\n\n\n\nExemple\n\n\n\n\nLa racine possède l’étiquette D.\nLe nœud père D a trois fils U, L et A.\nLe nœud V a pour père le nœud A.\nLes nœuds C, L et X sont des feuilles.\n\n\n\n\n\n\n\nVoici quelques exemples de situations dans lesquelles une structure de données arborescente est utile.\n\n\nDéjà rencontrée dans le chapitre sur les systèmes d’exploitation en première, une arborescence de dossiers dans un disque dur peut être modélisée par un arbre.\n\n\n\n\n\n\n\n\nLE DOM (Document Object Model) est une interface de programmation pour les pages web dans laquelle une page HTML est modélisée sous la forme d’un arbre.\nPar exemple, le code HTML ci-dessous sera modélisé par l’arbre en-dessous (source : w3.org).\n&lt;TABLE&gt;\n    &lt;ROWS&gt; \n      &lt;TR&gt; \n        &lt;TD&gt;Shady Grove&lt;/TD&gt;\n        &lt;TD&gt;Aeolian&lt;/TD&gt; \n      &lt;/TR&gt; \n      &lt;TR&gt;\n        &lt;TD&gt;Over the River, Charlie&lt;/TD&gt;\n        &lt;TD&gt;Dorian&lt;/TD&gt; \n      &lt;/TR&gt; \n    &lt;/ROWS&gt;\n&lt;/TABLE&gt;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDifférents paramètres numériques peuvent être définis concernant un arbre.\n\n\n\n\n\n\nDéfinitions\n\n\n\n\nLa taille d’un arbre est son nombre total de nœuds.\nLa profondeur d’un nœud est le nombre de nœuds de la branche allant de la racine à ce nœud, en comptant les extrémités.\nLa hauteur d’un arbre est la profondeur de son nœud le plus profond. Par convention, si l’arbre est vide, sa hauteur vaut 0, si l’arbre n’est composé que d’un nœud racine, sa hauteur vaut 1.\n\n\n\n\n\n\n\n\n\nExemple\n\n\n\nConsidérons l’arbre ci-dessous :\n\n\n\n\n\n\nLa taille de cet arbre est égale à 7.\nLa profondeur du nœud C est égale à 3, celle de X est égale à 4.\nLa hauteur de cet arbre est égale à 4 : X est le nœud le plus profond."
  },
  {
    "objectID": "04-arbres/arbres_cours.html#arbres-binaires",
    "href": "04-arbres/arbres_cours.html#arbres-binaires",
    "title": "Arbres (Cours)",
    "section": "2. Arbres binaires",
    "text": "2. Arbres binaires\n\n2.1. Définition\n\n\n\n\n\n\nDéfinition\n\n\n\nUn arbre binaire est un arbre dans lequel chaque nœud possède au plus deux fils au niveau inférieur, appelés gauche et droite.\n\n\nL’arbre donné en exemple ci-dessus n’est pas un arbre binaire car le nœud D possède 3 fils.\nL’arbre ci-dessous est un arbre binaire :\n\n\n\n\n\n\n\n2.2. Sous-arbres\nChaque nœud n’ayant que deux fils (au maximum), nous pouvons définir un sous-arbre gauche et un sous-arbre droit qui sont tous les deux également des arbres binaires (éventuellement vides).\n\n\n\n\n\n\n\n\n\n\n\nExemple\n\n\n\nPour l’arbre représenté ci-dessous, nous avons mis en évidence le sous-arbre gauche et le sous-arbre droit du nœud racine C.\nLe nœud Q admet comme sous-arbre gauche le nœud H et comme sous-arbre droit, l’arbre vide.\n\n\nCette notion de sous arbre permet de mettre en évidence la structure récursive d’un arbre binaire : un arbre binaire est un arbre dans lequel chaque nœud possède un arbre fils gauche et un arbre fils droit qui sont tous deux des arbres binaires.\n\n\n2.3. Hauteur d’un arbre binaire\nNous avons défini plus haut les notions de taille et de hauteur d’un arbre.\nNotons ici \\(n\\) la taille d’un arbre binaire et \\(h\\) sa hauteur. Ces deux entiers ne sont pas indépendants l’un de l’autre.\nUn cas extrême est le cas de l’arbre filiforme dans lequel chaque nœud n’a qu’un fils. La figure ci-dessous est réalisée avec \\(n=7\\).\n\n\n\n\n\nDans ce cas, nous avons \\(n=h\\) : la hauteur de l’arbre est égale au nombre de nœuds de l’arbre.\nUn autre cas “extrême” est le cas d’un arbre complet : il s’agit d’un arbre binaire dans lequel tous les nœuds (sauf les feuilles) ont exactement deux fils et toutes les feuilles ont la même profondeur. La figure ci-dessous représente un arbre complet à 7 nœuds.\n\n\n\n\n\nDans un tel arbre, le nombre de nœuds est doublé à chaque niveau. Si la hauteur est \\(h\\), le nombre total de nœuds est donc égal à :\n\\[n=1+2^1+2^2+2^3+\\ldots+2^{h-1}\\]\n(on numérote les niveaux de \\(0\\) à \\(h-1\\))\nOn obtient donc le résultat suivant :\n\n\n\n\n\n\nLien entre hauteur et taille d’un arbre binaire complet\n\n\n\nSoit un arbre binaire complet de taille \\(n\\) et de hauteur \\(h\\).\nOn a alors :\n\\[n=2^h-1\\]\n\n\n\n\n\n\n\n\nPreuve\n\n\n\n\n\nNous avons vu que \\(n=1+2^1+2^2+2^3+\\ldots+2^{h-1}\\). Cette somme est la somme des premiers termes d’une suite géométrique de raison 2.\nOn peut donc utiliser la formule de calcul vue en première en Mathématiques :\n\\[1+2^1+2^2+2^3+\\ldots+2^{h-1} = \\frac{2^h-1}{2-1}=2^h-1\\]\nPour ceux qui n’auraient jamais vu cette formule, sa preuve n’est pas difficile : il suffit de calculer le produit \\((2-1)(1+2^1+2^2+2^3+\\ldots+2^{h-1})\\) en développant :\n\\[(2-1)(1+2^1+2^2+2^3+\\ldots+2^{h-1})= 2^1+2^2+2^3+\\ldots+2^{h} -1-2^1-2^2-2^3-\\ldots-2^{h-1}\\]\nTous les termes s’annulent sauf \\(2^{h}\\) et \\(-1\\), d’où le résultat.\n\n\n\nTout arbre étant situé entre ces deux cas extrêmes, nous pouvons écrire un encadrement du nombre de nœuds \\(n\\) en fonction de la hauteur \\(h\\), valable pour tout arbre binaire :\n\\[h\\leqslant n\\leqslant 2^h-1\\]\nÀ partir de cet encadrement de \\(n\\), on peut déduire un encadrement de \\(h\\). Nous avons déjà de façon évidente \\(h\\leqslant n\\). La seconde inégalité \\(n\\leqslant 2^h-1\\) est équivalente à \\(n+1\\leqslant 2^h\\).\nPour isoler \\(h\\) dans cette inégalité, nous avons besoin de la fonction logarithme binaire. Le logarithme binaire d’un entier positif est son exposant quand on l’écrit sous la forme d’une puissance de 2. Par exemple \\(\\log_2(8)=3\\) car \\(2^3=8\\) et \\(\\log_2(2^h)=h\\). Cette fonction \\(\\log_2\\) étant intuitivement croissante, nous obtenons, en l’appliquant à l’inégalité \\(n+1\\leqslant 2^h\\) : \\(\\log_2(n+1)\\leqslant h\\).\nNous avons finalement l’encadrement suivant :\n\n\n\n\n\n\nEncadrement de la hauteur d’un arbre binaire\n\n\n\nSoit un arbre binaire de taille \\(n\\) et de hauteur \\(h\\).\nOn a alors :\n\\[\\log_2(n+1)\\leqslant h\\leqslant n\\]\n\n\nCet encadrement nous sera utile lors du calcul du coût d’exécution des algorithmes sur les arbres."
  },
  {
    "objectID": "04-arbres/arbres_cours.html#arbres-binaires-de-recherche",
    "href": "04-arbres/arbres_cours.html#arbres-binaires-de-recherche",
    "title": "Arbres (Cours)",
    "section": "3. Arbres binaires de recherche",
    "text": "3. Arbres binaires de recherche\n\n\n\n\n\n\nDéfinition\n\n\n\nUn arbre binaire de recherche (ABR) est un arbre binaire dont les clefs des nœuds (leur valeur) vérifient les propriétés suivantes :\n\nla clef d’un nœud est supérieure à celle de chaque nœud de son sous-arbre gauche.\nla clef d’un nœud est inférieure à celle du chaque nœud de son sous-arbre droit.\n\n\n\nCette définition n’a de sens que dans le cas où les clefs des nœuds sont toujours comparables entre elles. Dans la pratique, nous travaillerons toujours avec des clefs numériques ou alphanumériques (ordre alphabétique).\nNous supposerons toujours que toutes les clefs sont différentes.\n\n\n\n\n\n\n\n\n\n\n\nRemarque\n\n\n\nDans un ABR, pour un nœud donné, tous les nœuds de son sous-arbre gauche ont des clefs inférieures et tous les nœuds de son sous-arbre droit ont des clefs supérieures."
  },
  {
    "objectID": "04-arbres/arbres_exercices.html",
    "href": "04-arbres/arbres_exercices.html",
    "title": "Exercices sur les arbres",
    "section": "",
    "text": "Les exercices précédés du symbole  sont à faire sur machine, en sauvegardant le fichier si nécessaire.\nLes exercices précédés du symbole  doivent être résolus par écrit."
  },
  {
    "objectID": "04-arbres/arbres_exercices.html#exercice-1",
    "href": "04-arbres/arbres_exercices.html#exercice-1",
    "title": "Exercices sur les arbres",
    "section": " Exercice 1",
    "text": "Exercice 1\nOn considère l’arbre binaire ci-dessous :\n\n\n\n\n\n\nDéterminer la profondeur du nœud 6.\nDéterminer la hauteur de cet arbre.\nExpliquer pourquoi cet arbre n’est pas un arbre binaire de recherche.\nModifier l’arbre (en conservant les mêmes clefs) pour en faire un ABR."
  },
  {
    "objectID": "04-arbres/arbres_exercices.html#exercice-2",
    "href": "04-arbres/arbres_exercices.html#exercice-2",
    "title": "Exercices sur les arbres",
    "section": " Exercice 2",
    "text": "Exercice 2\nOn considère l’arbre binaire ci-dessous :\n\n\n\n\n\n\nJustifier qu’il s’agit bien d’un arbre binaire.\nDonner la clef de la racine.\nDonner le sous-arbre droit du nœud A.\nLe nœud C est-il une feuille ? Justifier.\nDonner la taille de cet arbre.\nDonner la profondeur du nœud B.\nDonner la hauteur de cet arbre."
  },
  {
    "objectID": "04-arbres/arbres_exercices.html#exercice-3",
    "href": "04-arbres/arbres_exercices.html#exercice-3",
    "title": "Exercices sur les arbres",
    "section": " Exercice 3",
    "text": "Exercice 3\nSoit les valeurs suivantes : 14, 22, 8, 47, 42, 13, 1, 24, 33, 74.\nConstruire un arbre binaire de recherche à partir de ces valeurs."
  },
  {
    "objectID": "04-arbres/implementationArbres.html",
    "href": "04-arbres/implementationArbres.html",
    "title": "Implémentation des arbres en Python",
    "section": "",
    "text": "L’objectif de cette partie est d’implémenter la structure d’arbre binaire en Python. Nous allons pour cela utiliser la Programmation Orientée Objet et construire un module réutilisable proposant à l’utilisateur une interface (API) permettant de travailler avec les arbres binaires."
  },
  {
    "objectID": "04-arbres/implementationArbres.html#arbres-binaires",
    "href": "04-arbres/implementationArbres.html#arbres-binaires",
    "title": "Implémentation des arbres en Python",
    "section": "1. Arbres binaires",
    "text": "1. Arbres binaires\nUne interface souhaitable devrait permettre de :\n\nCréer un arbre vide ;\nAccéder au sous-arbre gauche et au sous-arbre droit d’un nœud ;\nAccéder à une clef ;\nTester si un nœud est une feuille ;\nTester si un arbre est vide ;\nRetourner la taille ;\nRetourner la hauteur.\n\nDe plus, il serait souhaitable de parvenir à afficher un arbre de façon visuelle.\nNous avons vu que la structure d’arbre binaire est une structure récursive : cette propriété est exploitée dans l’implémentation que nous allons présenter. Pour définir un arbre, il suffit de définir un nœud racine ainsi que les deux sous-arbres gauche et droite qui sont eux-même des arbres binaires. Cela revient à assimiler un arbre à sa racine associée à un lien vers ses deux fils.\nNous définissons ci-dessous un objet ArbreBinaire possédant trois attributs clef, gauche, droit. Pour respecter les principes de la POO, et notamment la notion d’encapsulation, nous avons défini des méthodes d’accès aux attributs (elles commencent par get) et des méthodes de modification des attributs (elles commencent par set) et on s’interdira tout accès ou affectation direct(e) du type arbre.racine = ....\nLa méthode setRacine, qui permet de définir la clef d’un nœud assure que chaque nœud a toujours un sous-arbre gauche et un sous-arbre droit, éventuellement vides, ce qui facilite le traitement des arbres dans les algorithmes suivants. On matérialise ici l’aspect récursif de la structure.\nclass ArbreBinaire:\n    \"\"\" Implémentation de la structure d'arbre binaire \"\"\"\n\n    def __init__(self):\n        self.racine = None\n        # les sous-arbres gauche et droit doivent être des \n        # instances de l'objet ArbreBinaire\n        self.gauche = None\n        self.droit = None\n\n    def setRacine(self, racine):\n        \"\"\"définit la clef de la racine de l'instance\n         et crée les sous arbres vides gauches et droits\"\"\"\n        self.racine = racine\n        if self.gauche is None:\n            self.gauche = ArbreBinaire()\n        if self.droit is None:\n            self.droit = ArbreBinaire()\n    \n    def getRacine(self):\n        \"\"\"retourne la clef de la racine de l'arbre\"\"\"\n        return self.racine\n\n    def getSousArbreGauche(self):\n        return self.gauche\n\n    def setSousArbreGauche(self, arbre):\n        if isinstance(arbre, ArbreBinaire):\n            self.gauche = arbre\n\n    def getSousArbreDroit(self):\n        return self.droit\n\n    def setSousArbreDroit(self, arbre):\n        if isinstance(arbre, ArbreBinaire):\n            self.droit = arbre\n\n    def estVide(self) -&gt; bool:\n        return self.racine is None\n\n    def estFeuille(self) -&gt; bool:\n        if self.estVide():\n            return False\n        else:\n            return self.gauche.estVide() and self.droit.estVide()\n\n    def __str__(self):\n        if self.estVide():\n            return \"()\"\n        elif self.estFeuille():\n            return f\"('{self.racine}', (), ())\"\n        else:\n            return f\"('{self.racine}', {self.gauche.__str__()}, {self.droit.__str__()})\"\nLa classe est complétée par une méthode estVide permettant de tester si un arbre est vide ou non et une méthode estFeuille permettant de tester si un nœud est une feuille ou non (on confond un nœud avec un arbre de hauteur 1).\nLa dernière méthode est la méthode spéciale __str__ qui définit la façon dont un arbre va être affiché par la fonction print. Ici, on a choisi un affichage sous forme de tuple du type (clef, sous-arbre gauche, sous-arbre droit).\nPour créer un module, on enregistre le code ci-dessus dans un fichier nommé par exemple structures.py.\nOn peut ensuite utiliser notre nouvelle structure dans un autre fichier Python (dans le même dossier), ou dans la console interactive, en important le module :\nfrom structures import *\n\na = ArbreBinaire()\na.setRacine(8)\na.getSousArbreGauche().setRacine(3)\na.getSousArbreDroit().setRacine(9)\nb = a.getSousArbreGauche()\nc = a.getSousArbreDroit()\nb.getSousArbreGauche().setRacine(7)\nb.getSousArbreDroit().setRacine(5)\nc.getSousArbreDroit().setRacine(1)\nprint(a)\nOn obtient en sortie :\n&gt;&gt;&gt; (8, (3, (7, (), ()), (5, (), ())), (9, (), (1, (), ())))\nCela correspond à l’arbre représenté ci-dessous :\n\n\n\n\n\nOn peut tester les autres méthodes dans la console :\nprint(c)\n&gt;&gt;&gt; (9, (), (1, (), ()))\nc.getSousArbreGauche().estVide()\n&gt;&gt;&gt; True\nc.estFeuille()\n&gt;&gt;&gt; False\nc.getSousArbreDroit().estFeuille()\n&gt;&gt;&gt; True\nNous pouvons maintenant ajouter au fichier structures.py les deux fonctions suivantes (en dehors de la classe ArbreBinaire car ce ne sont pas des méthodes) qui retournent respectivement la taille et la hauteur d’un arbre binaire.\ndef taille(arbre) -&gt; int:\n    \"\"\"Retourne la taille de l'arbre, càd son nombre de noeuds\"\"\"\n    if arbre.racine is None:\n        return 0\n    else:\n        return 1 + taille(arbre.gauche) + taille(arbre.droit)\n\ndef hauteur(arbre) -&gt; int:\n    \"\"\"Retourne la hauteur de l'arbre\"\"\"\n    if arbre.racine is None:\n        return 0\n    else:\n        return 1 + max(hauteur(arbre.gauche), hauteur(arbre.droit))\nPrendre le temps de bien comprendre comment fonctionnent ces deux fonctions …\ntaille(a)\n&gt;&gt;&gt; 6\nhauteur(a)\n&gt;&gt;&gt; 3\nCe module structures sera utilisé en exercices et plus tard dans l’année lorsque nous étudierons les algorithmes sur les arbres."
  },
  {
    "objectID": "04-arbres/implementationArbres.html#arbres-binaires-de-recherche-abr",
    "href": "04-arbres/implementationArbres.html#arbres-binaires-de-recherche-abr",
    "title": "Implémentation des arbres en Python",
    "section": "2. Arbres binaires de recherche (ABR)",
    "text": "2. Arbres binaires de recherche (ABR)\nLes ABR sont des arbres binaires. Nous pouvons donc créer une classe ABR fille de la classe ArbreBinaire en utilisant la notion d’héritage et de polymorphisme de la POO (voir les compléments de cours à ce sujet). Nous définissons une méthode spécifique : l’insertion d’une clef. Cette méthode ajoute une clef à un ABR existant en s’assurant que l’arbre obtenu est toujours un ABR (le nouveau nœud est toujours une feuille).\nclass ABR(ArbreBinaire):\n    \"\"\" Implémentation de la structure d'arbre binaire de recherche \"\"\"\n\n    def __init__(self):\n        super().__init__()\n\n    def setRacine(self, racine):\n        \"\"\"définit la clef de la racine de l'instance\n         et crée les sous arbres vides gauches et droits\n         Provoque une erreur si la racine casse la structure d'ABR\"\"\"\n        self.racine = racine\n        if self.gauche is None:\n            self.gauche = ABR()\n        if self.droit is None:\n            self.droit = ABR()\n        if not estABR(self):\n            raise Exception(\"Cette affectation de clef casse la structure ABR !!!\")\n\n    def insere(self, racine):\n        \"\"\"insère une clef dans l'arbre en préservant la structure ABR\"\"\"\n        if self.racine is None:\n            self.racine = racine\n            self.gauche = ABR()\n            self.droit = ABR()\n        else:\n            if racine &lt; self.racine:\n                self.gauche.insere(racine)\n            else:\n                self.droit.insere(racine)\nPour définir un arbre binaire de recherche valide, on utilisera toujours la méthode insere car elle permet de s’assurer de toujours conserver un ABR.\nPour faciliter la vérification, nous définissons une fonction estABR qui peut s’appliquer aussi bien à un arbre binaire quelconque qu’à un ABR et qui retourne True si l’arbre est un ABR et False sinon.\ndef estABR(arbre, mini=-float(\"inf\"), maxi=+float(\"inf\")) -&gt; bool:\n    if arbre.getRacine() is None:\n        return True\n    else:\n        return estABR(arbre.getSousArbreGauche(), mini, arbre.getRacine()) and \n               estABR(arbre.getSousArbreDroit(), arbre.getRacine(), maxi) and \n               mini &lt; arbre.racine &lt; maxi\nPrendre le temps de bien comprendre cette fonction …\nUtilisation :\nfrom structures import *\n\na = ABR()\na.setRacine(8)\na.insere(5)\na.insere(3)\na.insere(12)\na.insere(10)\na.insere(15)\nprint(a)\nprint(estABR(a))\n# Affectation directe à proscrire :\n# a.getSousArbreDroit().setRacine(1) ## provoque une erreur\nSortie :\n(8, (5, (3, (), ()), ()), (12, (10, (), ()), (15, (), ())))\nTrue\nL’arbre correspond à :\n\n\n\n\n\nLe module structure.py est à conserver : il sera utilisé en exercices et dans les chapitres suivants.\n\n\n\n\n\n\nComplément\n\n\n\nOn peut ajouter une fonctionnalité de représentation graphique d’un arbre en utilisant les bibliothèques networkx et matplotlib. Ajouter la fonction ci-dessous au fichier structures.py :\nimport networkx as nx\nimport matplotlib.pyplot as plt\n\ndef afficheArbre(arbre, size=(4,4), null_node=False):\n\"\"\"\nsize : tuple de 2 entiers. Si size est int -&gt; (size, size)\nnull_node : si True, trace les liaisons vers les sous-arbres vides\n\"\"\"\narbreAsTuple = eval(arbre.__str__())\ndef parkour(arbre, noeuds, branches, labels, positions, profondeur, \n            pos_courante, pos_parent, null_node):\n    if arbre != ():\n        noeuds[0].append(pos_courante)\n        positions[pos_courante] = (pos_courante, profondeur)\n        profondeur -= 1\n        labels[pos_courante] = str(arbre[0])\n        branches[0].append((pos_courante, pos_parent))\n        pos_gauche = pos_courante - 2 ** profondeur\n        parkour(arbre[1], noeuds, branches, labels, positions, profondeur, \n                pos_gauche, pos_courante, null_node)\n        pos_droit = pos_courante + 2 ** profondeur\n        parkour(arbre[2], noeuds, branches, labels, positions, profondeur, \n                pos_droit, pos_courante, null_node)\n    elif null_node:\n        noeuds[1].append(pos_courante)\n        positions[pos_courante] = (pos_courante, profondeur)\n        branches[1].append((pos_courante, pos_parent))\n\nif arbreAsTuple == ():\n    return\n\nbranches = [[]]\nprofondeur = hauteur(arbre)\npos_courante = 2 ** profondeur\nnoeuds = [[pos_courante]]\npositions = {pos_courante: (pos_courante, profondeur)}\nlabels = {pos_courante: str(arbreAsTuple[0])}\n\nif null_node:\n    branches.append([])\n    noeuds.append([])\n\nprofondeur -= 1\nparkour(arbreAsTuple[1], noeuds, branches, labels, positions, profondeur, \n        pos_courante - 2 ** profondeur, pos_courante, null_node)\nparkour(arbreAsTuple[2], noeuds, branches, labels, positions, profondeur, \n        pos_courante + 2 ** profondeur, pos_courante, null_node)\n\nmon_arbre = nx.Graph()\n\nif type(size) == int:\n    size = (size, size)\nplt.figure(figsize=size)\n\nnx.draw_networkx_nodes(mon_arbre, positions, nodelist=noeuds[0], \n                       node_color=\"white\", node_size=550, edgecolors=\"blue\")\nnx.draw_networkx_edges(mon_arbre, positions, edgelist=branches[0], \n                       edge_color=\"black\", width=2)\nnx.draw_networkx_labels(mon_arbre, positions, labels)\n\nif null_node:\n    nx.draw_networkx_nodes(mon_arbre, positions, nodelist=noeuds[1], \n                           node_color=\"white\", node_size=50, edgecolors=\"grey\")\n    nx.draw_networkx_edges(mon_arbre, positions, edgelist=branches[1], \n                           edge_color=\"grey\", width=1)\n\nax = plt.gca()\nax.margins(0.1)\nplt.axis(\"off\")\nplt.show()\nplt.close()\nUtilisation :\nfrom structures import *\n\na = ABR()\na.setRacine(8)\na.insere(5)\na.insere(3)\na.insere(12)\na.insere(10)\na.insere(15)\n\nafficheArbre(a)\nSortie :"
  },
  {
    "objectID": "04-arbres/index.html",
    "href": "04-arbres/index.html",
    "title": "Programme",
    "section": "",
    "text": "Contenus\nCapacités attendues\nCommentaires\n\n\n\n\nArbres : structures hiérarchiques. Arbres binaires : nœuds, racines, feuilles, sous-arbres gauches, sous-arbres droits.\nIdentifier des situations nécessitant une structure de données arborescente. Évaluer quelques mesures des arbres binaires (taille, encadrement de la hauteur, etc.).\nOn fait le lien avec la rubrique « algorithmique »."
  },
  {
    "objectID": "04-arbres/index.html#programme",
    "href": "04-arbres/index.html#programme",
    "title": "Programme",
    "section": "",
    "text": "Contenus\nCapacités attendues\nCommentaires\n\n\n\n\nArbres : structures hiérarchiques. Arbres binaires : nœuds, racines, feuilles, sous-arbres gauches, sous-arbres droits.\nIdentifier des situations nécessitant une structure de données arborescente. Évaluer quelques mesures des arbres binaires (taille, encadrement de la hauteur, etc.).\nOn fait le lien avec la rubrique « algorithmique »."
  },
  {
    "objectID": "04-arbres/TParbres.html",
    "href": "04-arbres/TParbres.html",
    "title": "TP - Manipulation d’arbres",
    "section": "",
    "text": "Ce T.P. est à réaliser et à rendre dans Capytale.\n\nOuvrez le lien ci-dessus ;\nConnectez-vous avec vos identifiants ENT ;\nEntrez le code du TP : 15c9-991659\nCliquez sur “Go !”."
  },
  {
    "objectID": "04-arbres/TParbres.html#t.p.-arbres-binaires-quelques-compléments-utiles",
    "href": "04-arbres/TParbres.html#t.p.-arbres-binaires-quelques-compléments-utiles",
    "title": "TP - Manipulation d’arbres",
    "section": "",
    "text": "Ce T.P. est à réaliser et à rendre dans Capytale.\n\nOuvrez le lien ci-dessus ;\nConnectez-vous avec vos identifiants ENT ;\nEntrez le code du TP : 15c9-991659\nCliquez sur “Go !”."
  },
  {
    "objectID": "05-archiSE/index.html",
    "href": "05-archiSE/index.html",
    "title": "Programme",
    "section": "",
    "text": "Contenus\nCapacités attendues\nCommentaires\n\n\n\n\nGestion des processus et des ressources par un système d’exploitation.\nDécrire la création d’un processus, l’ordonnancement de plusieurs processus par le système. Mettre en évidence le risque de l’interblocage (deadlock).\nÀ l’aide d’outils standard, il s’agit d’observer les processus actifs ou en attente sur une machine. Une présentation débranchée de l’interblocage peut être proposée."
  },
  {
    "objectID": "05-archiSE/index.html#programme",
    "href": "05-archiSE/index.html#programme",
    "title": "Programme",
    "section": "",
    "text": "Contenus\nCapacités attendues\nCommentaires\n\n\n\n\nGestion des processus et des ressources par un système d’exploitation.\nDécrire la création d’un processus, l’ordonnancement de plusieurs processus par le système. Mettre en évidence le risque de l’interblocage (deadlock).\nÀ l’aide d’outils standard, il s’agit d’observer les processus actifs ou en attente sur une machine. Une présentation débranchée de l’interblocage peut être proposée."
  },
  {
    "objectID": "05-archiSE/processus_cours.html",
    "href": "05-archiSE/processus_cours.html",
    "title": "Processus : cours",
    "section": "",
    "text": "Toute machine est dotée d’un système d’exploitation qui a pour fonction de charger les programmes depuis la mémoire de masse et de lancer leur exécution en leur créant des processus, de gérer l’ensemble des ressources, de traiter les interruptions ainsi que les entrées-sorties et enfin d’assurer la sécurité globale du système.\n\n\n\n\n\n\nDéfinition d’un processus\n\n\n\nUn programme écrit à l’aide d’un langage de haut de niveau (on parle de “code source”) est transformé en langage machine afin de pouvoir être exécuté par un ordinateur.\nOn appelle processus un programme en cours d’exécution, c’est donc une instance d’exécution du programme.\n\n\nAttention, il ne faut pas confondre le code source du programme et un processus qui correspond à l’exécution de ce programme par un ordinateur. Pour prendre une image assez classique, si une recette de cuisine correspond au code source du programme, le cuisinier en train de préparer cette recette dans sa cuisine correspond à un processus.\nUn processus est caractérisé par :\n\nl’ensemble des instructions qu’il va devoir accomplir (écrites dans le fichier exécutable obtenu par la compilation du code-source du programme)\nles ressources que le programme va mobiliser (fichier en ouverture, carte son…)\nl’état des registres du processeur."
  },
  {
    "objectID": "05-archiSE/processus_cours.html#vocabulaire",
    "href": "05-archiSE/processus_cours.html#vocabulaire",
    "title": "Processus : cours",
    "section": "",
    "text": "Toute machine est dotée d’un système d’exploitation qui a pour fonction de charger les programmes depuis la mémoire de masse et de lancer leur exécution en leur créant des processus, de gérer l’ensemble des ressources, de traiter les interruptions ainsi que les entrées-sorties et enfin d’assurer la sécurité globale du système.\n\n\n\n\n\n\nDéfinition d’un processus\n\n\n\nUn programme écrit à l’aide d’un langage de haut de niveau (on parle de “code source”) est transformé en langage machine afin de pouvoir être exécuté par un ordinateur.\nOn appelle processus un programme en cours d’exécution, c’est donc une instance d’exécution du programme.\n\n\nAttention, il ne faut pas confondre le code source du programme et un processus qui correspond à l’exécution de ce programme par un ordinateur. Pour prendre une image assez classique, si une recette de cuisine correspond au code source du programme, le cuisinier en train de préparer cette recette dans sa cuisine correspond à un processus.\nUn processus est caractérisé par :\n\nl’ensemble des instructions qu’il va devoir accomplir (écrites dans le fichier exécutable obtenu par la compilation du code-source du programme)\nles ressources que le programme va mobiliser (fichier en ouverture, carte son…)\nl’état des registres du processeur."
  },
  {
    "objectID": "05-archiSE/processus_cours.html#états-dun-processus",
    "href": "05-archiSE/processus_cours.html#états-dun-processus",
    "title": "Processus : cours",
    "section": "2. États d’un processus",
    "text": "2. États d’un processus\nTous les systèmes d’exploitation “modernes” (Linux, Windows, macOS, Android, iOS…) sont capables de gérer l’exécution de plusieurs processus en même temps. Mais pour être précis, cela n’est pas un véritable “en même temps”, mais plutôt un “chacun son tour” car un processeur ne peut gérer qu’un processus à la fois. Pour gérer ce “chacun son tour”, les systèmes d’exploitation attribuent des “états” au processus.\n\n\n\n\n\n\nRemarque\n\n\n\nDe nos jours, les ordinateurs ont toujours plusieurs coeurs, donc plusieurs processeurs qui travaillent simultanément (véritable en même temps) et donc plusieurs processus qui sont vraiment traités simultanément. Cependant, le nombre de processus est toujours supérieur au nombre de processeurs et l’ordonnancement des processus par le système d’exploitation est bien toujours nécessaire.\n\n\n\n\n\nÉtats d’un processus\n\n\nIl y a trois états fondamentaux dans lesquels un processus peut se retrouver :\n\nprêt (suspendu par le système d’exploitation)\nélu (en exécution)\nbloqué (en attente d’un événement quelconque pour poursuivre)\n\nIl y a quatre transitions possibles entre ces états.\n\nLorsqu’un processus est en train de s’exécuter (qu’il utilise le microprocesseur), on dit que le processus est dans l’état élu.\nUn processus qui se trouve dans l’état élu peut demander à accéder à une ressource pas forcément disponible instantanément (par exemple lire une donnée sur le disque dur). Le processus ne peut pas poursuivre son exécution tant qu’il n’a pas obtenu cette ressource. En attendant de recevoir cette ressource, il passe de l’état élu à l’état bloqué. (blocage)\nLorsque le processus finit par obtenir la ressource attendue, celui-ci peut potentiellement reprendre son exécution. Mais comme les systèmes d’exploitation permettent de gérer plusieurs processus “en même temps”, un seul processus peut se trouver dans un état élu (le microprocesseur ne peut “s’occuper” que d’un seul processus à la fois). Ainsi, quand un processus passe d’un état élu à un état bloqué, un autre processus peut alors “prendre sa place” et passer dans l’état élu. Un processus qui quitte l’état bloqué ne repasse donc pas forcément à l’état élu, il peut attendre que “la place se libère” et passer dans l’état prêt (déblocage).\nLa transition de élu à prêt survient lorsque le processus en cours a épuisé la tranche de temps qui lui avait été allouée ; il perd alors le processeur, redevient aussitôt prêt (suspension).\n\nLe va-et-vient des transitions entre élu et prêt est issu de l’ordonnanceur (scheduler) de processus du système d’exploitation qui partage le temps entre tous les processus présents dans la mémoire. C’est le « chef d’orchestre » qui décide quel processus tourne sur le processeur et qui « donne leur tour » à chaque processus.\nLa procédure de sauvegarde des variables utilisées par le processus permet à celui-ci d’être placé dans la file d’attente des processus du système.\nUn processus qui utilise une ressource R doit la “libérer” une fois qu’il a fini de l’utiliser afin de la rendre disponible pour les autres processus. Pour libérer une ressource, un processus doit obligatoirement être dans un état “élu”.\n\nExemple d’ordonnancement\nL’ordonnanceur (qui fait partie du système d’exploitation), divise le temps de processeur disponible en petits laps de temps (quantum de temps) et, à chaque intervalle, il peut faire passer un processus de l’état elu à prêt ou inversement.\n\n\n\nprocessus\n\n\nUn bilan : la vidéo ci-dessous permet de résumer ce qui précède et d’approfondir ces notions.\nhttps://www.youtube.com/watch?v=bFqud0gcCHM"
  },
  {
    "objectID": "05-archiSE/processus_cours.html#les-processus-sous-linux",
    "href": "05-archiSE/processus_cours.html#les-processus-sous-linux",
    "title": "Processus : cours",
    "section": "3. Les processus sous Linux",
    "text": "3. Les processus sous Linux\nLa gestion des processus est dépendante du système d’exploitation et de son usage.\nUn processus peut appeler d’autres processus que l’on appelle sous-processus. On appelle le processus créateur le père et les processus créés, les fils. Les processus peuvent donc se structurer sous la forme d’une arborescence.\n\n\n\narbre des processus\n\n\nAu lancement du système, il n’existe qu’un seul processus (init), qui est l’ancêtre de tous les autres.\nPar exemple, init démarre tous les processus nécessaires pour permettre aux terminaux branchés au système d’établir une connexion et de lancer le shell de base servant à la lecture des commandes de l’utilisateur. (Bash est l’interpréteur par défaut de la plupart des systèmes d’exploitation GNU/Linux)\nLes commandes provenant alors des terminaux créent d’autres processus qui se greffent à l’arbre unique des processus du système.\nLinux crée et maintient un certain nombre d’informations sur les processus en cours d’utilisation dans l’ordinateur.\nDans cette table des processus, on retrouve presque toujours :\n\nun identificateur unique : le PID (Process Identification). Ce PID est un nombre. Le premier processus créé au démarrage du système à pour PID 0, le second 1, le troisième 2… Le système d’exploitation utilise un compteur qui est incrémenté de 1 à chaque création de processus, le système utilise ce compteur pour attribuer les PID aux processus.\nle PPID (Parent Process Identification) qui permet de connaitre le processus parent du processus.\nle niveau de priorité du processus ;\nl’état du processus (en exécution, suspendu, etc.) ;\nla table de pointeurs sur les ressources utilisées.\n\nDans un terminal Linux, la commande ps permet d’afficher la liste des processus actifs.\n\n\n\nterminal\n\n\nParmi les colonnes affichées, on repère :\n\nCMD : nom de la commande qui a créé le processus (par ordre chronologique) ;\nPID : Process Identification ;\nPPID: Parent Process Identification\n\nLa commande pstree permet d’afficher les processus sous forme d’arbre :\n\n\n\npstree\n\n\nLa commande top, quant à elle, affiche les processus en temps réel, classés par défaut par ordre décroissant de consommation de processeur.\n\n\n\ntop\n\n\nEnfin, la commande kill permet de fermer un processus en le désignant par son PID. Dans la situation de la dernière capture d’écran, la commande kill 2669 fermera Firefox."
  },
  {
    "objectID": "05-archiSE/processus_cours.html#notion-dinterblocage",
    "href": "05-archiSE/processus_cours.html#notion-dinterblocage",
    "title": "Processus : cours",
    "section": "4. Notion d’interblocage",
    "text": "4. Notion d’interblocage\nL’exécution d’un processus nécessite un ensemble de ressources (espace mémoire centrale, espace disque, fichier, périphériques, …) qui lui sont attribuées par le système d’exploitation.\n\n\n\n\n\n\nDéfinition\n\n\n\nUn ensemble de processus est en interblocage (deadlock) si chaque processus attend un évènement que seul un autre processus de l’ensemble peut engendrer.\n\n\n\n\n\n\n\n\nExemple d’interblocage\n\n\n\n\n\n\ninterblocage\n\n\n\nun processus Proc1 détient une ressource R1 et attend autre ressource R2 qui est utilisée par un autre processus Proc2\nle processus Proc2 détient la ressource R2 et attend la ressource R1.\n\n→ On a une situation d’interblocage : (Proc1 attend Proc2 et Proc2 attend Proc1).\nLes deux processus vont attendre indéfiniment.\n\n\nPour éviter cela, il est nécessaire :\n\nD’éviter l’interblocage en allouant les ressources avec précaution. Si l’allocation d’une ressource peut conduire à un interblocage, elle est retardée jusqu’à ce qu’il n’y ait plus de risque.\nLes détecter et y remédier.\n\nPour compléter et approfondir, lire les pages 218 à 225 du manuel (vous y apprendrez comment visualiser les processus sous Windows) et pages 230-231 pour l’interblocage."
  },
  {
    "objectID": "05-archiSE/processus_exos.html",
    "href": "05-archiSE/processus_exos.html",
    "title": "Exercices type bac - Processus",
    "section": "",
    "text": "Les exercices précédés du symbole  sont à faire sur machine, en sauvegardant le fichier si nécessaire.\nLes exercices précédés du symbole  doivent être résolus par écrit."
  },
  {
    "objectID": "05-archiSE/processus_exos.html#exercice-1",
    "href": "05-archiSE/processus_exos.html#exercice-1",
    "title": "Exercices type bac - Processus",
    "section": " Exercice 1",
    "text": "Exercice 1\n2021, sujet Amérique du Nord (extrait)\nUn constructeur automobile utilise des ordinateurs pour la conception de ses véhicules. Ceux-ci sont munis d’un système d’exploitation ainsi que de nombreuses applications parmi lesquelles on peut citer :\n\nun logiciel de traitement de texte ;\nun tableur ;\nun logiciel de Conception Assistée par Ordinateur (CAO) ;\nun système de gestion de base de données (SGBD)\n\nChaque ordinateur est équipé des périphériques classiques : clavier, souris, écran et est relié à une imprimante réseau.\n\nUn ingénieur travaille sur son ordinateur et utilise les quatre applications citées au début de l’énoncé.\nPendant l’exécution de ces applications, des processus mobilisent des données et sont en attente d’autres données mobilisées par d’autres processus.\nOn donne ci-dessous un tableau indiquant à un instant précis l’état des processus en cours d’exécution et dans lequel D1, D2, D3, D4 et D5 sont des données.\nLa lettre M signifie que la donnée est mobilisée par l’application ; la lettre A signifie que l’application est en attente de cette donnée.\nLecture du tableau : le logiciel de traitement de texte mobilise (M) la donnée D1 et est en attente (A) de la donnée D2.\n\n\n\n\nD1\nD2\nD3\nD4\nD5\n\n\n\n\nTraitement de texte\nM\nA\n-\n-\n-\n\n\nTableur\nA\n-\n-\n-\nM\n\n\nSGBD\n-\nM\nA\nA\n-\n\n\nCAO\n-\n-\nA\nM\nA\n\n\n\nMontrer que les applications s’attendent mutuellement. Comment s’appelle cette situation ?"
  },
  {
    "objectID": "05-archiSE/processus_exos.html#exercice-2",
    "href": "05-archiSE/processus_exos.html#exercice-2",
    "title": "Exercices type bac - Processus",
    "section": " Exercice 2",
    "text": "Exercice 2\n2021, Métropole sujet 1\nPartie A Cette partie est un questionnaire à choix multiples (QCM). Pour chacune des questions, une seule des quatre réponses est exacte.\n\nParmi les commandes ci-dessous, laquelle permet d’afficher les processus en cours d’exécution ?\n\n\ndir\n\n\nps\n\n\nman\n\n\nls\n\n\nQuelle abréviation désigne l’identifiant d’un processus dans un système d’exploitation de type UNIX ?\n\n\nPIX\n\n\nSIG\n\n\nPID\n\n\nSID\n\n\nComment s’appelle la gestion du partage de processeur entre les différents processus ?\n\n\nL’interblocage\n\n\nL’ordonnancement\n\n\nLa planification\n\n\nLa priorisation\n\n\nQuelle commande permet d’interrompre un processus dans un système d’exploitation de type UNIX ?\n\n\nstop\n\n\ninterrupt\n\n\nend\n\n\nkill\n\n\n\nPartie B\nQ1. Un processeur choisit à chaque cycle d’exécution le processus qui doit être exécuté. Le tableau ci-dessous donne pour trois processus P1, P2, P3 :\n\nla durée d’exécution (en nombre de cycles),\nl’instant d’arrivée sur le processeur (exprimé en nombre de cycles à partir de 0),\nle numéro de priorité.\n\nLe numéro de priorité est d’autant plus petit que la priorité est grande. On suppose qu’à chaque instant, c’est le processus qui a le plus petit numéro de priorité qui est exécuté, ce qui peut provoquer la suspension d’un autre processus, lequel reprendra lorsqu’il sera le plus prioritaire.\n\n\n\nimage\n\n\nReproduire le tableau ci-dessous sur la copie et indiquer dans chacune des cases le processus exécuté à chaque cycle.\n\n\n\nimage\n\n\nQ2. On suppose maintenant que les trois processus précédents s’exécutent et utilisent une ou plusieurs ressources parmi R1, R2 et R3. Parmi les scénarios suivants, lequel provoque un interblocage ? Justifier.\n\n\n\nimage"
  },
  {
    "objectID": "05-archiSE/processus_exos.html#exercice-3",
    "href": "05-archiSE/processus_exos.html#exercice-3",
    "title": "Exercices type bac - Processus",
    "section": " Exercice 3",
    "text": "Exercice 3\n2021, Métropole sujet 2\nPartie A\nDans un bureau d’architectes, on dispose de certaines ressources qui ne peuvent être utilisées simultanément par plus d’un processus, comme l’imprimante, la table traçante, le modem. Chaque programme, lorsqu’il s’exécute, demande l’allocation des ressources qui lui sont nécessaires. Lorsqu’il a fini de s’exécuter, il libère ses ressources.\n\n\n\nimage\n\n\nOn appelle p1, p2 et p3 les processus associés respectivement aux programmes 1, 2 et 3\n\nLes processus s’exécutent de manière concurrente. Justifier qu’une situation d’interblocage peut se produire.\nModifier l’ordre des instructions du programme 3 pour qu’une telle situation ne puisse pas se produire. Aucune justification n’est attendue.\nSupposons que le processus p1 demande la table traçante alors qu’elle est en cours d’utilisation par le processus p3. Parmi les états suivants, quel sera l’état du processus p1 tant que la table traçante n’est pas disponible :\n\n\nélu\n\n\nbloqué\n\n\nprêt\n\n\nterminé\n\n\n\nPartie B\nAvec une ligne de commande dans un terminal sous Linux, on obtient l’affichage suivant :\n\n\n\nimage\n\n\nLa documentation Linux donne la signification des différents champs :\n\nUID : identifiant utilisateur effectif ;\nPID : identifiant de processus ;\nPPID : PID du processus parent ;\nC : partie entière du pourcentage d’utilisation du processeur par rapport au temps de vie des processus ;\nSTIME : l’heure de lancement du processus ;\nTTY : terminal de contrôle\nTIME : temps d’exécution\nCMD : nom de la commande du processus\n\nQ1. Parmi les quatre commandes suivantes, laquelle a permis cet affichage ?\n\n\nls -l\n\n\nps -ef\n\n\ncd ..\n\n\nchmod 741 processus.txt\n\n\nQ2. Quel est l’identifiant du processus parent à l’origine de tous les processus concernant le navigateur Web (chromium-browser) ?\nQ3. Quel est l’identifiant du processus dont le temps d’exécution est le plus long ?"
  },
  {
    "objectID": "05-archiSE/processus_exos.html#exercice-4",
    "href": "05-archiSE/processus_exos.html#exercice-4",
    "title": "Exercices type bac - Processus",
    "section": " Exercice 4",
    "text": "Exercice 4\n2021, Métropole Candidats Libres sujet 2\nQ1. Les états possibles d’un processus sont : prêt, élu, terminé et bloqué.\nQ1.a. Expliquer à quoi correspond l’état élu.\nQ1.b. Proposer un schéma illustrant les passages entre les différents états.\nQ2. On suppose que quatre processus C₁, C₂, C₃ et C₄ sont créés sur un ordinateur, et qu’aucun autre processus n’est lancé sur celui-ci, ni préalablement ni pendant l’exécution des quatre processus. L’ordonnanceur, pour exécuter les différents processus prêts, les place dans une structure de données de type file. Un processus prêt est enfilé et un processus élu est défilé.\nQ2.a. Parmi les propositions suivantes, recopier celle qui décrit le fonctionnement des entrées/sorties dans une file :\n\ni.Premier entré, dernier sorti\n\nPremier entré, premier sorti\n\n\nDernier entré, premier sorti\n\n\nQ2.b. On suppose que les quatre processus arrivent dans la file et y sont placés dans l’ordre C₁, C₂, C₃ et C₄.\n\nLes temps d’exécution totaux de C₁, C₂, C₃ et C₄ sont respectivement 100 ms, 150 ms, 80 ms et 60 ms.\nAprès 40 ms d’exécution, le processus C₁ demande une opération d’écriture disque, opération qui dure 200 ms. Pendant cette opération d’écriture, le processus C₁ passe à l’état bloqué.\nAprès 20 ms d’exécution, le processus C₃ demande une opération d’écriture disque, opération qui dure 10 ms. Pendant cette opération d’écriture, le processus C₃ passe à l’état bloqué.\nSur la frise chronologique ci-dessous, les états du processus C₂ sont donnés. Compléter la frise avec les états des processus C₁, C₃ et C₄.\n\n\n\nimage"
  },
  {
    "objectID": "05-archiSE/processus_python.html",
    "href": "05-archiSE/processus_python.html",
    "title": "Processus sous Linux et Python",
    "section": "",
    "text": "La méthode Python fork(), du module os permet de créer des processus enfants en utilisant les processus par lesquels elle a été appelée. Cette commande n’est disponible que lorsque Python fonctionne sous Linux.\nVoici les principales propriétés de la méthode fork() :\nLors de l’exécution de l’instruction Python fork(), trois types de valeurs entières sont retournées :"
  },
  {
    "objectID": "05-archiSE/processus_python.html#premier-exemple",
    "href": "05-archiSE/processus_python.html#premier-exemple",
    "title": "Processus sous Linux et Python",
    "section": "Premier exemple",
    "text": "Premier exemple\nOn considère le programme ci-dessous :\nimport os\n \n# Création de processus fils\nos.fork()\nos.fork()\n \n# La ligne suivante sera exécutée par le processus père et ses deux enfants\nprint(\"Coucou !\")\nSortie obtenue :\n\n\n\nsortie\n\n\n\n\n\n\n\n\nquestion\n\n\n\nPourquoi l’affichage s’est-il produit 4 fois ?"
  },
  {
    "objectID": "05-archiSE/processus_python.html#deuxième-exemple",
    "href": "05-archiSE/processus_python.html#deuxième-exemple",
    "title": "Processus sous Linux et Python",
    "section": "Deuxième exemple",
    "text": "Deuxième exemple\nOn considère le programme suivant :\nimport os\n \nval = os.fork()\n \nif val == 0:\n    pid = os.getpid()\n    print(f\"Coucou ! Je suis le processus fils et mon PID est {pid}.\")\nelif val &gt; 0:\n    pid = os.getpid()\n    print(f\"Coucou ! Je suis le processus père, mon PID est {pid} et celui de mon fils est {val}.\")\nelse:\n    print(\"Oups ! La création de processus fils a échoué ...\")\nSortie obtenue :\n\n\n\nsortie\n\n\n\nUn exemple plus complexe\nConsidérons le code ci-dessous :\nimport os\nimport time\n\nprint(\"Processus père : mon PID est\", os.getpid())\nfor i in range(3):\n    newpid = os.fork()\n    print(\"Processus\", os.getpid(), \"actif\")\n    print(\"Processus\", os.getpid(), i)\n    if newpid == 0:\n        print(\"Processus\", os.getpid(), \": mon père est\", os.getppid())\ntime.sleep(20)\nSortie partielle :\nProcessus père : mon PID est 91152\nProcessus 91152 actif\nProcessus 91152 0\nProcessus 91152 actif\nProcessus 91152 1\nProcessus 91153 actif\nProcessus 91154 actif\nProcessus 91152 2\nProcessus 91154 1\nProcessus 91153 0\nProcessus 91154 : mon père est 91152\nProcessus 91153 : mon père est 91152\n...\n\n\n\nps\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nExpliquer la sortie et la copie d’écran.\n\n\nEn exécutant plusieurs fois ce programme, nous constatons que les sorties ne se font pas toujours dans le même ordre. En général, l’ordre d’exécution ne peut pas être prévu à l’avance et plus il y a de processus, avec une durée longue, plus l’entrelacement est important. On dit que l’ordonnancement est non déterministe."
  },
  {
    "objectID": "05-archiSE/processus_TP.html",
    "href": "05-archiSE/processus_TP.html",
    "title": "T.P. - Processus sous Linux",
    "section": "",
    "text": "Pour ce T.P., nous travaillons avec les vieilles machines sous Linux : elles doivent être respectées (vu leur grand âge) et accepter leur lenteur !\n\n\n\nlinux\n\n\n\nOuvrir l’émulateur de terminal pour travailler en ligne de commandes.\nAu lancement du système, il n’existe qu’un seul processus (init), qui est l’ancêtre de tous les autres. On peut voir l’arborescence avec la commande « pstree ».\nQuel processus est à la racine de l’arbre affiché ?\nReconnaître et noter les noms de quelques processus liés aux entrées/sorties,\nCréer un fichier TPlinuxTNSI.odt avec le traitement de texte LibreOffice Writer.\nEn utilisant la touche « imprime écran », faire une copie d’écran de l’arbre obtenu dans le terminal et coller dans la page.\nObservation des processus\n\nLa commande ps -aef permet de lister tous les processus.\nDans le terminal, taper la commande suivante : ps -aef (attention à l’espace après ps).\nS’affichent plusieurs informations sur les processus en cours sur votre ordinateur du type :\n\n\n\npas -aef\n\n\n\nUID nom de l’utilisateur qui a lancé le processus\nPID : numéro du processus\nPPID : numéro du processus parent\nC : facteur de priorité : plus la valeur est grande, plus le processus est prioritaire\nSTIME : heure de lancement du processus\nTTY : correspond au nom du terminal depuis lequel le processus a été lancé\nTIME : durée de traitement du processus\nCMD : nom du processus.\n\n4.1. Faire une copie d’écran (ou plusieurs si besoin) à coller à la suite de votre page.\n4.2. Reconnaître les processus liés à l’ouverture du logiciel LibreOffice.\n4.3. Donner le PID et le PPID de chacun, faire un lien père/fils et remonter dans le tableau pour suivre la branche de l’arbre. (le plus loin possible !). Faire un schéma.\n4.4. Quelle remarque peut-on faire sur le nom de l’utilisateur qui a lancé le processus ?\n4.5. Quel est le PID de la commande ps -aef ? Remonter le chemin dans l’arbre. Pourquoi passe-t-on par un processus dont le nom est « bash » ?\n4.6. Recopier la ligne du tableau dont le PID est 1 et reconnaître le processus init.\nLa commande ps ne permet pas de suivre en temps réel les processus (affichage figé). Pour avoir un suivi en temps réel, on peut utiliser la commande top.\nLa commande top donne beaucoup de détails, en temps réel, sur les processus qui tournent sur une machine :\n\n\n\n\n\n\nPID : numéro du processus\nUTIL ou USER nom de l’utilisateur qui a lancé le processus\nPR : facteur de priorité : plus la valeur est grande, plus le processus est prioritaire\nVIRT : Taille virtuelle du processus, mémoire qu’il utilise réellement\nRES : Quantité de mémoire physique occupée par le processus\nS : Statut du processus. Valeurs possibles :\n\nR en cours d’exécution ;\nT processus stoppé ;\nI processus endormi (&gt;20s) ;\nS processus endormi (&lt;20s) ;\nZ processus zombie ;\nD processus non interruptible ;\nW processus swappé sur disque.\n\n%CPU : consommation du CPU\n%MEM : consommation de la RAM\nTEMPS+ ou TIME+ : temps d’utilisation CPU depuis que le processus est lancé\nCOMMAND : nom du processus.\n\n4.7. Analyser en quelques lignes ce qu’on observe à l’écran.\n4.8. Taper Ctrl Z pour arrêter.\nPour en savoir plus sur la commande top, consultez la page : http://debian-facile.org/doc:systeme:top\n\nOuvrir le navigateur Firefox et chercher avec le moteur de recherche proposé par le navigateur la signification du mot daemon pour Linux. On privilégiera Wikipédia.\nDe même chercher sur Wikipédia la signification de processus zombie et de processus swappé sur disque. Donner des éléments de définition pour ces trois mots ou expressions.\nDans le terminal, taper la commande ps -aef pour visualiser les processus liés à Firefox.\nComment est le sous arbre (suivre la trace des PID et PPID jusqu’à init) ? Le construire ci-dessous en notant les PID.\nFermer Firefox, et retaper la commande dans le terminal, que remarque-t-on ?\nRéouvrir le navigateur, puis noter à quel processus il correspond dans la table du terminal.\nDans le terminal, utiliser la commande kill qui permet d’arrêter le processus (kill suivi du numéro de PID) pour tuer ce processus.\nQue remarque-t-on ?\n\nPour lancer un processus en tâche de fond (en arrière-plan), on peut faire suivre la commande du symbole &. Cela ordonne au processus parent de “reprendre la main”, sans attendre la fin du processus “fils”\nExemple\n\nLancer la commande xeyes dans le terminal, les yeux apparaissent… bouger la souris, mais le terminal est « bloqué » : il attend que le processus xeyes soit terminé. (taper Ctrl Z pour arrêter)\nLancer xeyes &, les yeux apparaissent, et on a toujours la main dans le terminal.\n« Tuer » ce processus avec la commande kill en relevant le numéro du processus avec la commande « top » et observer les processus dans le terminal.\n\nRemarque : En utilisant pkill, il suffit de mettre le nom du processus au lieu de son PID.\nLa commande cat /proc/cpuinfo permet d’avoir des informations détaillées sur le processeur.\n\nSous Linux, les détails sur chacun des processus sont stockés dans les sous répertoires de « /proc ». On peut ainsi explorer le contenu de ces fichiers pour avoir plus d’informations sur un processus en particulier.\nObserver les résultats sur les vieux ordinateurs du lycée et proposer une raison pour laquelle les ordinateurs utilisés sont considérés comme obsolètes et les logiciels ne sont plus mis à jour pour ce type d’appareil ?"
  },
  {
    "objectID": "06-algo/algo_arbres_cours.html",
    "href": "06-algo/algo_arbres_cours.html",
    "title": "Algorithmes sur les arbres",
    "section": "",
    "text": "Nous avons déjà rencontré ces algorithmes, sous la forme de programmes Python, dans le chapitre sur les arbres binaires. On s’intéresse ici à leur étude algorithmique.\nD’une façon générale, la structure d’arbre binaire est particulièrement adaptée à la mise en œuvre d’algorithmes récursifs. Dans la suite tous les arbres sont binaires.\n\n\nLa taille d’un arbre est son nombre total de nœuds.\n\n\n\n\n\n\nAlgorithme de calcul de la taille d’un arbre\n\n\n\n\nfonction taille(arbre : arbre binaire) : entier si arbre est vide alors retourner 0 sinon retourner 1 + taille(sous-arbre gauche de arbre) + taille(sous-arbre droit de arbre) fin si\n\n\n\n\n\n\nLa hauteur d’un arbre est la profondeur de son nœud le plus profond. Par convention, si l’arbre est vide, sa hauteur vaut 0, si l’arbre n’est composé que d’un nœud racine, sa hauteur vaut 1.\n\n\n\n\n\n\nAlgorithme de calcul de la hauteur d’un arbre\n\n\n\n\nfonction hauteur(arbre : arbre binaire) : entier si arbre est vide alors retourner 0 sinon retourner 1 + max(hauteur(sous-arbre gauche de arbre), hauteur(sous-arbre droit de arbre)) fin si"
  },
  {
    "objectID": "06-algo/algo_arbres_cours.html#calculer-la-taille-et-la-hauteur-dun-arbre-binaire",
    "href": "06-algo/algo_arbres_cours.html#calculer-la-taille-et-la-hauteur-dun-arbre-binaire",
    "title": "Algorithmes sur les arbres",
    "section": "",
    "text": "Nous avons déjà rencontré ces algorithmes, sous la forme de programmes Python, dans le chapitre sur les arbres binaires. On s’intéresse ici à leur étude algorithmique.\nD’une façon générale, la structure d’arbre binaire est particulièrement adaptée à la mise en œuvre d’algorithmes récursifs. Dans la suite tous les arbres sont binaires.\n\n\nLa taille d’un arbre est son nombre total de nœuds.\n\n\n\n\n\n\nAlgorithme de calcul de la taille d’un arbre\n\n\n\n\nfonction taille(arbre : arbre binaire) : entier si arbre est vide alors retourner 0 sinon retourner 1 + taille(sous-arbre gauche de arbre) + taille(sous-arbre droit de arbre) fin si\n\n\n\n\n\n\nLa hauteur d’un arbre est la profondeur de son nœud le plus profond. Par convention, si l’arbre est vide, sa hauteur vaut 0, si l’arbre n’est composé que d’un nœud racine, sa hauteur vaut 1.\n\n\n\n\n\n\nAlgorithme de calcul de la hauteur d’un arbre\n\n\n\n\nfonction hauteur(arbre : arbre binaire) : entier si arbre est vide alors retourner 0 sinon retourner 1 + max(hauteur(sous-arbre gauche de arbre), hauteur(sous-arbre droit de arbre)) fin si"
  },
  {
    "objectID": "06-algo/algo_arbres_cours.html#parcourir-un-arbre",
    "href": "06-algo/algo_arbres_cours.html#parcourir-un-arbre",
    "title": "Algorithmes sur les arbres",
    "section": "2. Parcourir un arbre",
    "text": "2. Parcourir un arbre\nRemarque : en anglais les parcours en profondeur sont appelés depth-first search (DFS) et les parcours en largeur sont appelés breadth-first search (BFS).\nTous ces algorithmes de parcours ont en commun de visiter tous les sommets d’un arbre, mais pas dans le même ordre. La structure récursive de la structure de données arbre binaire permet de définir très naturellement ces algorithmes de façon récursive. Chacun des algorithmes de parcours sont définis sous forme de fonctions qui comportent deux appels récursifs et qui visitent à chaque fois un seul sommet. Si on note \\(n\\) la taille de l’arbre (le nombre de sommets), on aura donc pour tous ces algorithmes une complexité en \\(\\mathcal{O}(n)\\).\n\n2.1. Parcours en profondeur avec ordre préfixe\n\n\n\n\n\n\nDéfinition : ordre préfixe\n\n\n\nOn appelle parcours préfixe un parcours dans lequel chaque noeud est visité, puis chacun de ses fils :\n\non visite la racine ;\nensuite on visite récursivement le sous-arbre gauche ;\nenfin on visite récursivement le sous-arbre droit.\n\nLe parcours est dans l’ordre noeud - gauche - droit\n\n\n\n\n\n\n\n\nExemple\n\n\n\n\n\n\nOrdre préfixe\n\n\nOrdre de parcours des sommets : C-Z-U-R-G-Q-H.\n\n\n\n\n\n\n\n\nAlgorithme de parcours préfixe en pseudo-code\n\n\n\n\nfonction parcoursPrefixe(arbre : arbre binaire) si arbre n’est pas vide alors afficher racine de arbre parcoursPrefixe(sous-arbre gauche de arbre) parcoursPrefixe(sous-arbre droit de arbre) fin si\n\n\n\nImplémentation en Python : Trois versions sont proposées ci-dessous. La première version est récursive et reprend à l’identique la structure de l’algorithme en pseudo-code. La seconde est également récursive et a été légèrement modifiée pour retourner les sommets visités sous forme d’une liste, ce qui peut être utile pour un traitement ultérieur. La troisième version, plus difficile, est itérative et retourne également les sommets visités sous forme d’une liste. Elle utilise une structure de pile (sous forme de liste).\n\nVersion récursive avec simple affichageVersion récursive avec retour listeVersion itérative avec retour liste\n\n\ndef parcoursPrefixe(arbre: ArbreBinaire):\n    if not arbre.estVide():\n        print(arbre.getRacine())\n        parcoursPrefixe(arbre.getSousArbreGauche())\n        parcoursPrefixe(arbre.getSousArbreDroit())\n\n\ndef parcoursPrefixe(arbre: ArbreBinaire, liste = []):\n    if not arbre.estVide():\n        liste.append(arbre.getRacine())\n        parcoursPrefixe(arbre.getSousArbreGauche(), liste)\n        parcoursPrefixe(arbre.getSousArbreDroit(), liste)\n        return liste\n\n\ndef parcoursPrefixe(arbre: ArbreBinaire) -&gt; list:\n    # Si l'arbre est vide, on arrête le parcours\n    if arbre.estVide():\n        return []\n    # Liste pour stocker les valeurs des noeuds\n    valeurs = []\n    # Parcours de l'arbre en utilisant une pile\n    pile = [arbre]\n    while pile != []:\n        noeud = pile.pop()\n        valeurs.append(noeud.getRacine())\n        # On ajoute les enfants dans la pile dans l'ordre inverse pour\n        # obtenir le parcours en profondeur préfixe\n        if not noeud.getSousArbreDroit().estVide():\n            pile.append(noeud.getSousArbreDroit())\n        if not noeud.getSousArbreGauche().estVide():\n            pile.append(noeud.getSousArbreGauche())\n    # Renvoie la liste des valeurs des noeuds parcourus\n    return valeurs\n\n\n\nDérouler à la main, en mode papier-crayon, l’exécution de ces trois programmes est un très bon exercice !\n\n\n2.1. Parcours en profondeur avec ordre infixe\n\n\n\n\n\n\nDéfinition : ordre infixe\n\n\n\nOn appelle parcours infixe un parcours dans lequel chaque noeud est visité entre les noeuds de son sous arbre gauche et ceux de son sous arbre droit :\n\non visite récursivement le sous-arbre gauche ;\nensuite on visite la racine ;\nenfin on visite récursivement le sous-arbre droit.\n\nLe parcours est dans l’ordre gauche - noeud - droit\n\n\n\n\n\n\n\n\nExemple\n\n\n\n\n\n\nOrdre infixe\n\n\nOrdre de parcours des sommets : U-Z-R-G-C-H-Q.\n\n\n\n\n\n\n\n\nAlgorithme de parcours infixe en pseudo-code\n\n\n\n\nfonction parcoursInfixe(arbre : arbre binaire) si arbre n’est pas vide alors parcoursInfixe(sous-arbre gauche de arbre) afficher racine de arbre parcoursInfixe(sous-arbre droit de arbre) fin si\n\n\n\nImplémentation en Python : Trois versions sont proposées ci-dessous. La première version est récursive et reprend à l’identique la structure de l’algorithme en pseudo-code. La seconde est également récursive et a été légèrement modifiée pour retourner les sommets visités sous forme d’une liste, ce qui peut être utile pour un traitement ultérieur. La troisième version, plus difficile, est itérative et retourne également les sommets visités sous forme d’une liste. Elle utilise une structure de pile (sous forme de liste).\n\nVersion récursive avec simple affichageVersion récursive avec retour listeVersion itérative avec retour liste\n\n\ndef parcoursInfixe(arbre: ArbreBinaire):\n    if not arbre.estVide():\n        parcoursInfixe(arbre.getSousArbreGauche())\n        print(arbre.getRacine())\n        parcoursInfixe(arbre.getSousArbreDroit())\n\n\ndef parcoursInfixe(arbre: ArbreBinaire, liste = []):\n    if not arbre.estVide():\n        parcoursInfixe(arbre.getSousArbreGauche(), liste)\n        liste.append(arbre.getRacine())\n        parcoursInfixe(arbre.getSousArbreDroit(), liste)\n        return liste\n\n\ndef parcoursInfixe(arbre: ArbreBinaire) -&gt; list:\n    # Si l'arbre est vide, on arrête le parcours\n    if arbre.estVide():\n        return []\n    # Liste pour stocker les valeurs des noeuds\n    valeurs = []\n    # Parcours de l'arbre en utilisant une pile\n    pile = []\n    noeud = arbre\n    while not noeud.estVide() or pile != []:\n        # Si l'on a atteint une feuille, on récupère la valeur et on revient en arrière\n        if noeud.estVide():\n            noeud = pile.pop()\n            valeurs.append(noeud.getRacine())\n            noeud = noeud.getSousArbreDroit()\n        else:\n            # Sinon, on parcourt le sous-arbre gauche et on enregistre l'état actuel\n            # pour pouvoir revenir plus tard\n            pile.append(noeud)\n            noeud = noeud.getSousArbreGauche()\n    return valeurs\n\n\n\nDérouler à la main, en mode papier-crayon, l’exécution de ces trois programmes est un très bon exercice !\n\n\n2.3. Parcours en profondeur avec ordre suffixe\n\n\n\n\n\n\nDéfinition : ordre suffixe\n\n\n\nOn appelle parcours suffixe (ou postfixe) un parcours dans lequel chaque noeud est visité après les noeuds de son sous arbre gauche et ceux de son sous arbre droit :\n\non visite récursivement le sous-arbre gauche ;\nensuite on visite récursivement le sous-arbre droit ;\nensuite on visite la racine.\n\nLe parcours est dans l’ordre gauche - droit - noeud\n\n\n\n\n\n\n\n\nExemple\n\n\n\n\n\n\nOrdre suffixe\n\n\nOrdre de parcours des sommets : U-G-R-Z-H-Q-C.\n\n\n\n\n\n\n\n\nAlgorithme de parcours suffixe en pseudo-code\n\n\n\n\nfonction parcoursSuffixe(arbre : arbre binaire) si arbre n’est pas vide alors parcoursSuffixe(sous-arbre gauche de arbre) parcoursSuffixe(sous-arbre droit de arbre) afficher racine de arbre fin si\n\n\n\n\n\n\n\n\n\nExercice\n\n\n\nVoici deux arbres binaires. Pour chacun d’entre eux, indiquer l’ordre de parcours des sommets pour chacun de types de parcours en profondeur définis ci-dessus.\n\n\n\n\n\n\n\nImplémentation en Python : Trois versions sont proposées ci-dessous. La première version est récursive et reprend à l’identique la structure de l’algorithme en pseudo-code. La seconde est également récursive et a été légèrement modifiée pour retourner les sommets visités sous forme d’une liste, ce qui peut être utile pour un traitement ultérieur. La troisième version, plus difficile, est itérative et retourne également les sommets visités sous forme d’une liste. Elle utilise une structure de pile (sous forme de liste).\n\nVersion récursive avec simple affichageVersion récursive avec retour listeVersion itérative avec retour liste\n\n\ndef parcoursSuffixe(arbre: ArbreBinaire):\n    if not arbre.estVide():\n        parcoursSuffixe(arbre.getSousArbreGauche())\n        parcoursSuffixe(arbre.getSousArbreDroit())\n        print(arbre.getRacine())\n\n\ndef parcoursSuffixe(arbre: ArbreBinaire, liste = []):\n    if not arbre.estVide():\n        parcoursSuffixe(arbre.getSousArbreGauche(), liste)\n        parcoursSuffixe(arbre.getSousArbreDroit(), liste)\n        liste.append(arbre.getRacine())\n        return liste\n\n\ndef parcoursSuffixe(arbre: ArbreBinaire) -&gt; list:\n    # Si l'arbre est vide, on arrête le parcours\n    if arbre.estVide():\n        return []\n    # Liste pour stocker les valeurs des noeuds\n    valeurs = []\n    # Parcours de l'arbre en utilisant une pile\n    pile = [arbre]\n    while pile != []:\n        # On dépile et on note l'élément en haut de la pile\n        noeud = pile.pop()\n        valeurs.append(noeud.getRacine())\n        # On empile les sous arbres gauche et droits s'ils existent\n        # Droit sera traité avant Gauche car on parcours à l'envers\n        if not noeud.getSousArbreGauche().estVide():\n            pile.append(noeud.getSousArbreGauche())\n        if not noeud.getSousArbreDroit().estVide():\n            pile.append(noeud.getSousArbreDroit())\n    # On remet à l'endroit\n    valeurs.reverse()\n    return valeurs\n\n\n\nDérouler à la main, en mode papier-crayon, l’exécution de ces trois programmes est un très bon exercice !\n\n\n2.4. Parcours en largeur d’abord\n\n\n\n\n\n\nDéfinition : parcours en largeur d’abord\n\n\n\nOn appelle parcours en largeur d’abord un parcours dans lequel les noeuds sont visités par ordre de niveaux croissant, de gauche à droite.\n\n\n\n\n\n\n\n\nExemple\n\n\n\n\n\n\nParcours en largeur\n\n\nOrdre de parcours des sommets : C-Z-Q-U-R-H-G.\n\n\nLe parcours en largeur est simple à comprendre visuellement, mais il est plus difficile à traduire par un algorithme, car il n’exploite pas la définition récursive des arbres binaires.\nNous utiliserons une file pour effectuer le parcours en largeur d’un arbre binaire.\n\n\n\n\n\n\nAlgorithme de parcours en largeur en pseudo-code\n\n\n\n\nfonction parcoursLargeur(arbre : arbre binaire) créer une liste de résultats vide si arbre n’est pas vide alors créer une file vide ajouter arbre à la file tant que la file n’est pas vide faire noeud \\(\\leftarrow\\) défiler le premier élément de la file ajouter l’étiquette de noeud à la liste de résultats si noeud a un fils gauche alors ajouter le fils gauche de noeud à la file fin si si noeud a un fils droit alors ajouter le fils droit de noeud à la file fin si fin tant que fin si retourner la liste de résultats\n\n\n\nTraduction en Python :\ndef parcoursLargeur(arbre: ArbreBinaire()) -&gt; list:\n    valeurs = []\n    if not arbre.estVide():\n        file = []\n        file.append(arbre)\n        while file != []:\n            noeud = file.pop(0)\n            valeurs.append(noeud.getRacine())\n            if not noeud.getSousArbreGauche().estVide():\n                file.append(noeud.getSousArbreGauche())\n            if not noeud.getSousArbreDroit().estVide():\n                file.append(noeud.getSousArbreDroit())\n    return valeurs\nUne fois encore, dérouler à la main, en mode papier-crayon, l’exécution de ce programme est un très bon exercice !"
  },
  {
    "objectID": "06-algo/algo_arbres_cours.html#insertion-dune-clef-dans-un-arbre-de-recherche",
    "href": "06-algo/algo_arbres_cours.html#insertion-dune-clef-dans-un-arbre-de-recherche",
    "title": "Algorithmes sur les arbres",
    "section": "3. Insertion d’une clef dans un arbre de recherche",
    "text": "3. Insertion d’une clef dans un arbre de recherche\nOn s’intéresse maintenant aux arbres binaires de recherche.\nNous avons déjà utilisé cette structure de données dans la séquence 4 sur les arbres. Notre module structures.py définit la structure d’arbre binaire de recherche par une classe ABR qui possède une méthode insere qui insère une clef dans l’arbre en préservant la structure ABR.\nVoici en pseudo-code l’algorithme utilisé par cette méthode. L’insertion d’une clef va se faire au niveau d’une feuille, donc au bas de l’arbre. Il n’est pourtant pas nécessaire de descendre manuellement dans l’arbre jusqu’au bon endroit car nous exploitons la structure à la fois récursive et ordonnée d’un ABR : il suffit de distinguer dans lequel des deux sous-arbres gauche et droit doit se trouver la future clef, et d’appeler récursivement la fonction d’insertion dans le sous-arbre en question.\n\n\n\n\n\n\nAlgorithme de parcours en largeur en pseudo-code\n\n\n\n\nfonction insere(arbre : ABR, valeur) si arbre est vide alors définir la racine de arbre avec valeur comme clef retourner arbre sinon clef \\(\\leftarrow\\) clef de la racine de arbre si valeur est inférieure ou égale à clef sous-arbre gauche de arbre \\(\\leftarrow\\) insere(sous-arbre gauche de arbre, valeur) sinon sous-arbre droit de arbre \\(\\leftarrow\\) insere(sous-arbre droit de arbre, valeur) fin si fin si retourner arbre\n\n\n\n\n\n\n\n\n\nExercice\n\n\n\nOn considère l’ABR représenté ci-dessous. Dérouler à la main l’exécution de l’algorithme ci-dessus pour insérer la valeur 3 dans cet arbre, puis la valeur 11."
  },
  {
    "objectID": "06-algo/algo_arbres_cours.html#recherche-dune-clef-dans-un-arbre-de-recherche",
    "href": "06-algo/algo_arbres_cours.html#recherche-dune-clef-dans-un-arbre-de-recherche",
    "title": "Algorithmes sur les arbres",
    "section": "4. Recherche d’une clef dans un arbre de recherche",
    "text": "4. Recherche d’une clef dans un arbre de recherche\nNotre module structure.py, dans sa version définitive, comporte une fonction appartient_ABR qui teste l’appartenance d’un élément donné en argument à un ABR donné en argument et renvoie un booléen.\nVoici le code Python de cette fonction.\ndef appartientABR(element, arbre) -&gt; bool:\n    \"\"\"teste l'appartenance d'un élément à un ABR\"\"\"\n    if arbre is None:\n        return False\n    elif element == arbre.getRacine():\n        return True\n    else:\n        if arbre.getRacine() is not None:\n            if element &lt; arbre.getRacine():\n                return appartientABR(element, arbre.getSousArbreGauche())\n            else:\n                return appartientABR(element, arbre.getSousArbreDroit())\nCette fonction exploite à la fois la structure récursive et la structure ordonnée d’un ABR afin de n’effectuer qu’un appel récursif à chaque passage.\nDéterminons une évaluation de sa complexité temporelle, dans le pire des cas, dans le cas particulier d’un arbre équilibré.\nOn note \\(n\\) la taille de l’arbre, c’est-à-dire son nombre de noeuds. Au départ, nous avons donc \\(n\\) noeuds à explorer. Après chaque examen d’un noeud, le nombre de noeuds restant à explorer est divisé par 2.\n\n\n\n\n\nDans le pire des cas, il faudra parcourir tous les étages de l’arbre pour trouver la clef (qui est alors une feuille) ou pour constater qu’elle n’est pas dans l’arbre. On va donc parcourir au total \\(h\\) noeuds, où \\(h\\) est la hauteur de l’arbre.\nOr, nous avons vu que pour un arbre complet, nous avons la relation : \\(n=2^h-1\\) équivalente à \\(2^h=n+1\\) et donc \\(h=\\log_2(n+1)\\).\nLa complexité de la recherche d’une valeur dans un ABR est donc en \\(\\mathcal{O}(log_2(n))\\). Il s’agit d’une complexité très performante : par exemple, pour un arbre de taille 10000, 14 étapes suffiront.\n\n\n\n\n\n\nÀ retenir\n\n\n\nLa complexité temporelle de la recherche d’une valeur dans un ABR équilibré est de l’ordre de \\(\\log_2(n)\\).\n\n\nRemarque :\n\nCet algorithme est à rapprocher de l’algorithme de recherche dichotomique d’une valeur dans un tableau trié, étudié en première."
  },
  {
    "objectID": "06-algo/algo_arbres_exos.html",
    "href": "06-algo/algo_arbres_exos.html",
    "title": "Algorithmes sur les arbres - Exercices",
    "section": "",
    "text": "Sujet zéro 2021 - Exercice 3\nAmérique du Nord 2021 sujet 1 - Exercice 4\nCentres étrangers 2021 sujet 1 - Exercice 3\nMétropole Candidats Libres 2021 sujet 2 - Exercice 3"
  },
  {
    "objectID": "06-algo/algo_arbres_exos.html#exercices-tirés-des-annales",
    "href": "06-algo/algo_arbres_exos.html#exercices-tirés-des-annales",
    "title": "Algorithmes sur les arbres - Exercices",
    "section": "",
    "text": "Sujet zéro 2021 - Exercice 3\nAmérique du Nord 2021 sujet 1 - Exercice 4\nCentres étrangers 2021 sujet 1 - Exercice 3\nMétropole Candidats Libres 2021 sujet 2 - Exercice 3"
  },
  {
    "objectID": "06-algo/diviser_pour_regner_cours.html",
    "href": "06-algo/diviser_pour_regner_cours.html",
    "title": "Méthode “Diviser pour régner”",
    "section": "",
    "text": "La méthode “diviser pour régner” (divide and conquer en anglais) consiste à diviser un problème complexe en plusieurs sous-problèmes plus simples, puis à résoudre ces sous-problèmes séparément avant de les combiner pour obtenir la solution finale du problème initial. Cette méthode permet souvent de simplifier les calculs et de trouver des solutions plus rapidement que si on essayait de résoudre le problème dans son ensemble. Elle est utilisée dans de nombreux domaines, tels que l’informatique, les mathématiques et les sciences de l’ingénieur.\nCette méthode peut par exemple permettre de paralléliser le traitement des sous-problèmes, ce qui peut accélérer encore davantage la recherche de solutions.\nLes inconvénients : la nécessité de décomposer un problème complexe en sous-problèmes, ce qui peut prendre du temps et nécessiter une certaine expertise. De plus, il peut être difficile de combiner les solutions des sous-problèmes pour obtenir une solution finale pour le problème initial. En conséquence, la méthode “diviser pour régner” peut ne pas être adaptée à tous les types de problèmes et peut ne pas être la plus efficace dans certains cas."
  },
  {
    "objectID": "06-algo/diviser_pour_regner_cours.html#le-principe",
    "href": "06-algo/diviser_pour_regner_cours.html#le-principe",
    "title": "Méthode “Diviser pour régner”",
    "section": "",
    "text": "La méthode “diviser pour régner” (divide and conquer en anglais) consiste à diviser un problème complexe en plusieurs sous-problèmes plus simples, puis à résoudre ces sous-problèmes séparément avant de les combiner pour obtenir la solution finale du problème initial. Cette méthode permet souvent de simplifier les calculs et de trouver des solutions plus rapidement que si on essayait de résoudre le problème dans son ensemble. Elle est utilisée dans de nombreux domaines, tels que l’informatique, les mathématiques et les sciences de l’ingénieur.\nCette méthode peut par exemple permettre de paralléliser le traitement des sous-problèmes, ce qui peut accélérer encore davantage la recherche de solutions.\nLes inconvénients : la nécessité de décomposer un problème complexe en sous-problèmes, ce qui peut prendre du temps et nécessiter une certaine expertise. De plus, il peut être difficile de combiner les solutions des sous-problèmes pour obtenir une solution finale pour le problème initial. En conséquence, la méthode “diviser pour régner” peut ne pas être adaptée à tous les types de problèmes et peut ne pas être la plus efficace dans certains cas."
  },
  {
    "objectID": "06-algo/diviser_pour_regner_cours.html#exemple",
    "href": "06-algo/diviser_pour_regner_cours.html#exemple",
    "title": "Méthode “Diviser pour régner”",
    "section": "2. Exemple",
    "text": "2. Exemple\nNous avons déjà rencontré cette méthode : recherche dichotomique dans une ABR et tous les algorithmes de type “dichotomie” (rencontrés en mathématiques par exemple).\nL’algorithme de tri fusion (merge sort en anglais) est un algorithme de tri utilisé pour trier des éléments dans un ordre croissant ou décroissant. Il fonctionne en divisant récursivement la liste d’éléments à trier en sous-listes plus petites jusqu’à ce qu’il ne reste plus qu’une seule valeur dans chaque sous-liste. Ces sous-listes sont ensuite fusionnées en une seule liste triée en comparant les valeurs de chaque sous-liste et en plaçant les valeurs plus petites en premier.\nIl s’agit d’une utilisation classique de la méthode “diviser pour régner” : à chaque étape, on appelle récursivement la même fonction, mais avec une liste dont la taille a été divisée par deux.\nVoici une description de cet algorithme en pseudo-code :\nfonction tri_fusion(liste : tableau d'entiers) -&gt; tableau d'entiers\n    si longueur(liste) &lt;= 1\n        retourner liste\n    sinon\n        milieu = longueur(liste) / 2\n        liste_gauche = tri_fusion(liste[1...milieu])\n        liste_droite = tri_fusion(liste[milieu+1...longueur(liste)])\n        retourner fusionner(liste_gauche, liste_droite)\n\nfonction fusionner(liste_gauche : tableau d'entiers, liste_droite : tableau d'entiers) -&gt; tableau d'entiers\n    // Initialiser les indices des sous-listes et de la liste originale\n    i = 0\n    j = 0\n    liste_fus = []\n\n    // Fusionner les deux sous-listes en comparant les éléments de chaque liste\n    tant que i &lt; longueur(liste_droite) et j &lt; longueur(liste_gauche)\n        si liste_droite[i] &lt;= liste_gauche[j]\n            ajouter liste_droite[i] à liste_fus\n            i = i + 1\n        sinon\n            ajouter liste_gauche[j] à liste_fus\n            j = j + 1\n\n    // Copier les éléments restants de la liste_droite (s'il y en a)\n    tant que i &lt; longueur(liste_droite)\n        ajouter liste_droite[i] à liste_fus\n        i = i + 1\n\n    // Copier les éléments restants de la liste_gauche (s'il y en a)\n    tant que j &lt; longueur(liste_gauche)\n        ajouter liste_gauche[j] à liste_fus\n        j = j + 1\n\n    // Retourner la liste fusionnée\n    retourner liste_fus\n\n\n\n\n\n\nExercice\n\n\n\nDérouler à la main l’exécution de cet algorithme avec la liste [5, 2, 4, 6, 1, 3]. Présenter ce déroulement sous forme d’un arbre.\n\n\nPour utiliser cet algorithme, on peut appeler la fonction tri_fusion en lui passant la liste d’entiers à trier.\nImplémentation en Python :\ndef tri_fusion(liste):\n    if len(liste) &lt;= 1:\n        return liste\n    else:\n        milieu = len(liste) // 2\n        liste_gauche = tri_fusion(liste[:milieu])\n        liste_droite = tri_fusion(liste[milieu:])\n        return fusionner(liste_gauche, liste_droite)\n\n\ndef fusionner(liste_gauche, liste_droite):\n    # Initialiser les indices des sous-listes et de la liste originale\n    i = 0\n    j = 0\n    liste_fus =  []\n\n    # Fusionner les deux sous-listes en comparant les éléments de chaque liste\n    while i &lt; len(liste_droite) and j &lt; len(liste_gauche):\n        if liste_droite[i] &lt;= liste_gauche[j]:\n            liste_fus.append(liste_droite[i])\n            i = i + 1\n        else:\n            liste_fus.append(liste_gauche[j])\n            j = j + 1\n    # Copier les éléments restants de la liste_droite (s'il y en a)\n    while i &lt; len(liste_droite):\n        liste_fus.append(liste_droite[i])\n        i = i + 1\n\n    # Copier les éléments restants de la liste_gauche (s'il y en a)\n    while j &lt; len(liste_gauche):\n        liste_fus.append(liste_gauche[j])\n        j = j + 1\n\n    # Retourner la liste fusionnée\n    return liste_fus\nTest du programme en console :\n&gt;&gt;&gt; liste = [5, 2, 4, 6, 1, 3]\n&gt;&gt;&gt; tri_fusion(liste)\n&gt;&gt;&gt; print(liste)\n[1, 2, 3, 4, 5, 6]\nVisualisation de l’exécution avec Python Tutor :\n\n\n\nComplexité de l’algorithme\nL’aspect “dichotomique” de l’algorithme correspond à une complexité en \\(\\log_2 n\\), où \\(n\\) est la taille de la liste à trier. Cependant, la fonction de fusion de deux listes triées est, elle en \\(\\mathcal{O}(n)\\).\nAu final, on a donc le résultat suivant :\n\n\n\n\n\n\nComplexité de l’algorithme de tri fusion\n\n\n\nLa complexité (temporelle) de l’algorithme de tri fusion est en \\(\\mathcal{O}(n\\log n)\\), où \\(n\\) est la taille de la liste à trier.\nIl s’agit donc d’une complexité quasi-linéaire.\n\n\nComme nous l’avons vu dans les rappels d’algorithmique, une telle complexité est bien meilleure qu’une complexité quadratique et moins bonne qu’une complexité linéaire, comme illustré ci-dessous.\n\n\n\n\n\nPour rappel, les algorithmes de tri étudiés en première (tri par insertion et tri pas sélection) sont de coût quadratique dans le pire des cas."
  },
  {
    "objectID": "06-algo/diviser_pour_regner_exos.html",
    "href": "06-algo/diviser_pour_regner_exos.html",
    "title": "Méthode “Diviser pour régner” - Exercices",
    "section": "",
    "text": "Métropole Candidats Libres 2021 Sujet 1 - Exercice 5\nMétropole 2021 Sujet 1 - Exercice 4\nMétropole 2022 Sujet 1 - Exercice 4"
  },
  {
    "objectID": "06-algo/diviser_pour_regner_exos.html#exercices-tirés-des-annales",
    "href": "06-algo/diviser_pour_regner_exos.html#exercices-tirés-des-annales",
    "title": "Méthode “Diviser pour régner” - Exercices",
    "section": "",
    "text": "Métropole Candidats Libres 2021 Sujet 1 - Exercice 5\nMétropole 2021 Sujet 1 - Exercice 4\nMétropole 2022 Sujet 1 - Exercice 4"
  },
  {
    "objectID": "06-algo/exos_cycles_chemins.html",
    "href": "06-algo/exos_cycles_chemins.html",
    "title": "T.P. : Cycles et chemins dans un graphe",
    "section": "",
    "text": "Nous allons utiliser les algorithmes de parcours de graphe pour déterminer les cycles et les chemins dans un graphe."
  },
  {
    "objectID": "06-algo/exos_cycles_chemins.html#objectif",
    "href": "06-algo/exos_cycles_chemins.html#objectif",
    "title": "T.P. : Cycles et chemins dans un graphe",
    "section": "",
    "text": "Nous allons utiliser les algorithmes de parcours de graphe pour déterminer les cycles et les chemins dans un graphe."
  },
  {
    "objectID": "06-algo/exos_cycles_chemins.html#parcours-dun-graphe-à-la-main",
    "href": "06-algo/exos_cycles_chemins.html#parcours-dun-graphe-à-la-main",
    "title": "T.P. : Cycles et chemins dans un graphe",
    "section": "Parcours d’un graphe à la main",
    "text": "Parcours d’un graphe à la main\nOn considère le graphe G suivant\n\n\n\nimage.png\n\n\n\nQuestion 1\nOn choisit de partir de A.\nRéaliser à la main un parcours en largeur du graphe (on insérera dans la file les sommets pas ordre alphabétique), en indiquant les états successifs de la file. Donner à la fin la liste des sommets parcourus.\nRéponse : (on pourra noter les sommets sans mettre de guillemets ou d’apostrophe : A à la place de ‘A’\n\n\nQuestion 2\nMême question en partant de H.\nRéponse :\n\n\nQuestion 3\nMême question pour le parcours en profondeur (donc avec une pile) en partant de A.\nRéponse :\n\n\nQuestion 4\nMême question en partant de H.\nRéponse :"
  },
  {
    "objectID": "06-algo/exos_cycles_chemins.html#implémentation-des-parcours",
    "href": "06-algo/exos_cycles_chemins.html#implémentation-des-parcours",
    "title": "T.P. : Cycles et chemins dans un graphe",
    "section": "Implémentation des parcours",
    "text": "Implémentation des parcours\nOn donne ci-dessous les classes File, Pile et Graphe dont on utilisera les méthodes. La classe Graphe représente un graphe par un dictionnaire d’adjacence (similaire à la liste d’adjacence vue en cours).\nExécuter les deux cellules suivantes.\n\n# Import de graphviz pour l'affichage des graphes.\nfrom graphviz import Graph\nimport basthon\n\n\nclass File:\n    '''Une implémentation basique à l'aide d'une liste python'''\n    def __init__(self):\n        self.liste=[]\n    def estVide(self):\n        return self.liste==[]\n    def enfile(self,e):\n        self.liste.append(e)\n    def defile(self):\n        return self.liste.pop(0)\nclass Pile:\n    '''Une implémentation basique à l'aide d'une liste python'''\n    def __init__(self):\n        self.liste=[]\n    def estVide(self):\n        return self.liste==[]\n    def empile(self,e):\n        self.liste.append(e)\n    def depile(self):\n        return self.liste.pop()\nclass Graphe:    \n    def __init__(self):\n        self.d = dict() # dictionnaire d'adjacence \n    def ajoute_sommet(self,s):\n        '''Ajoute le sommet s au graphe si celui-ci est un nouveau sommet''' \n        if s not in self.d :\n            self.d[s] = []\n    def ajoute_arete(self,s,t):\n        '''Ajoute si nécessaire les sommets s et t puis crée si elle n'existait pas une arête entre s et t'''\n        self.ajoute_sommet(s)\n        self.ajoute_sommet(t)\n        if t not in self.d[s]:\n            self.d[s].append(t)\n        if s not in self.d[t]:\n            self.d[t].append(s)\n    def arete(self,s,t):\n        '''Renvoie True s'il y a une arête entre s et t et False sinon'''\n        return (t in self.d[s])\n    def sommets(self):\n        '''Renvoie la liste de tous les sommets du graphe'''\n        return list(self.d.keys())\n    def voisins(self,s):\n        '''Renvoie la liste des voisins de s'''\n        return self.d[s]\n    def affiche(self): \n        \"Affichage du graphe en utilisant le module networkx\"\n        dot = Graph('G')\n        for s in self.sommets():\n            for t in self.voisins(s): \n                # Condition pour éviter les doubles arêtes\n                if '{} -- {}'.format(t,s) not in dot.source:\n                    dot.edge(s,t)\n        basthon.display(dot)\n\n\nQuestion 5\nCompléter le code ci-dessous pour instancier et représenter le graphe G plus haut. La liste L est la liste des arêtes du graphe : elle est donnée pour vous aider à instancier le graphe.\n\nL=[('A','B'),('A','C'),('A','D'),('A','E'),('B','C'),('B','D'),('B','F'),('C','E'),('C','G'),('D','E'),('D','H'),('E','I'),('F','G')]\nG=Graphe()\n# à compléter\n\n\n\nQuestion 6\nCompléter la fonction parcoursLargeur ci-dessous et la tester. Vous pouvez vous aider du cours, mais il faut adapter le code aux implémentations des graphes et des files définies ci-dessus.\n\ndef parcoursLargeur(G,s):\n    \"\"\"Parcours en largeur d'abord d'un graphe\n    Args:\n        G: une instance de l'objet Graphe\n        s: le sommet de départ\n    Returns:\n        L: Une liste contenant les nœuds visités dans l'ordre du parcours.\n    \"\"\"\n    F=File()\n    L=[] # la liste des sommets visités que l'on va retourner\n    marque={s:False for s in G.sommets()}\n    pass\n\n\n# tests (on vérifiera les réponses aux questions 1 et 2)\n\n\n# Test des différentes méthodes précédentes\n# me permet de voir que vos méthodes ont l'air correctes, c'est le cas si cette cellule ne renvoie pas d'erreur\nGTest=Graphe()\nfor i in range(0,10,2):\n    for j in range(1,10,2):\n        GTest.ajoute_arete(i,j)\nassert parcoursLargeur(GTest,0)==[0, 1, 3, 5, 7, 9, 2, 4, 6, 8]\nassert parcoursLargeur(GTest,1)==[1, 0, 2, 4, 6, 8, 3, 5, 7, 9]\nprint(\"Tests réussis !\")\n\n\n\nQuestion 7\nCompléter la fonction parcoursProfondeur ci-dessous et la tester. Vous pouvez vous aider du cours, mais il faut adapter le code aux implémentations des graphes et des piles définies ci-dessus.\n\ndef parcoursProfondeur(G,s):\n    \"\"\"Parcours en profondeur d'abord d'un graphe\n    Args:\n        G: une instance de l'objet Graphe\n        s: le sommet de départ\n    Returns:\n        L: Une liste contenant les nœuds visités dans l'ordre du parcours.\n    \"\"\"\n    pass\n\n\n# jeu de tests (on vérifiera les réponses aux questions 1 et 2)\n\n\n# Test des différentes méthodes précédentes\n# me permet de voir que vos méthodes ont l'air correctes, c'est le cas si cette cellule ne renvoie pas d'erreur\nGTest=Graphe()\nfor i in range(0,10,2):\n    for j in range(1,10,2):\n        GTest.ajoute_arete(i,j)\nassert parcoursProfondeur(GTest,0)==[0, 9, 8, 6, 4, 2, 7, 5, 3, 1]\nassert parcoursProfondeur(GTest,1)==[1, 8, 9, 7, 5, 3, 6, 4, 2, 0]\nprint(\"Tests réussis !\")"
  },
  {
    "objectID": "06-algo/exos_cycles_chemins.html#ère-application-détecter-si-un-graphe-est-connexe-ou-pas",
    "href": "06-algo/exos_cycles_chemins.html#ère-application-détecter-si-un-graphe-est-connexe-ou-pas",
    "title": "T.P. : Cycles et chemins dans un graphe",
    "section": "1ère application : détecter si un graphe est connexe ou pas",
    "text": "1ère application : détecter si un graphe est connexe ou pas\n\nQuestion 8\nUn graphe est dit connexe s’il existe un chemin entre chaque paire de sommets. Autrement dit, un graphe est connexe si un parcours en largeur ou en profondeur du graphe permet de visiter tous les sommets.\nCompléter la fonction suivante qui teste si un graphe est connexe ou pas, puis la tester.\n\ndef estConnexe(G):\n    ''' Teste si un graphe est connexe\n    Args:\n        un graphe G non vide\n    Returns:\n        True si G est connexe, False sinon\n    '''\n    pass\n\n\n# Jeu de tests de la fonction estConnexe\n\n\n# Test des différentes méthodes précédentes\n# me permet de voir que vos méthodes ont l'air correctes, c'est le cas si cette cellule ne renvoie pas d'erreur\nGTest=Graphe()\nfor i in range(0,10,2):\n    for j in range(1,10,2):\n        GTest.ajoute_arete(i,j)\nGTestBis=Graphe()\nfor i in range(9):\n    for j in range(i+1,10):\n        GTestBis.ajoute_arete(i,j)\nfor i in range(10,19):\n    for j in range(i+1,20):\n        GTestBis.ajoute_arete(i,j) \nassert estConnexe(GTest)==True\nassert estConnexe(GTestBis)==False"
  },
  {
    "objectID": "06-algo/exos_cycles_chemins.html#application-du-parcours-en-largeur-calculer-la-distance-entre-2-sommets",
    "href": "06-algo/exos_cycles_chemins.html#application-du-parcours-en-largeur-calculer-la-distance-entre-2-sommets",
    "title": "T.P. : Cycles et chemins dans un graphe",
    "section": "Application du parcours en largeur : calculer la distance entre 2 sommets",
    "text": "Application du parcours en largeur : calculer la distance entre 2 sommets\nOn rappelle que la distance entre deux sommets s et t d’un graphe non orienté est la longueur de la plus petite chaîne reliant s et t\n\nQuestion 9\nCompléter la fonction suivante qui renvoie le dictionnaire donnant les distances entre un sommet s donné et tous les autres sommets du graphe atteignables par s\n\ndef distances(G,s):\n    ''' \n    Calcule les distances entre s et les autres sommets\n    Args:\n        un graphe G non orienté et un sommet s\n    Returns:\n        le dictionnaire donnant la distance entre s et les autres sommets atteignables par s\n    '''\n    F=File()\n    d=dict() # le dictionnaire en question\n    F.enfile(s)\n    d[s]=0 # la distance de s à s est 0, cela permet également de marquer s\n    pass\n\n\n# Jeu de tests de la fonction distances\n\n\n# Test des différentes méthodes précédentes\n# me permet de voir que vos méthodes ont l'air correctes, c'est le cas si cette cellule ne renvoie pas d'erreur\nGTest=Graphe()\nfor i in range(0,10,2):\n    for j in range(1,10,2):\n        GTest.ajoute_arete(i,j)\nassert distances(GTest,0)=={0: 0, 1: 1, 3: 1, 5: 1, 7: 1, 9: 1, 2: 2, 4: 2, 6: 2, 8: 2}\nassert distances(GTest,1)=={1: 0, 0: 1, 2: 1, 4: 1, 6: 1, 8: 1, 3: 2, 5: 2, 7: 2, 9: 2}"
  },
  {
    "objectID": "06-algo/exos_cycles_chemins.html#application-du-parcours-en-profondeur-détecter-un-cycle",
    "href": "06-algo/exos_cycles_chemins.html#application-du-parcours-en-profondeur-détecter-un-cycle",
    "title": "T.P. : Cycles et chemins dans un graphe",
    "section": "Application du parcours en profondeur : détecter un cycle",
    "text": "Application du parcours en profondeur : détecter un cycle\n\nQuestion 10\nÀ l’image de l’instanciation du graphe G fait plus haut, créer un graphe G2 acyclique (càd sans cycle), par exemple un arbre et le dessiner\n\nG2=Graphe()\n# à compléter\n\n\n\nQuestion 11\nOn donne ci-dessous l’algorithme de détection de cycle dans un graphe non orienté dont les sommets sont les entiers de \\(0\\) à \\(n-1\\).\n\n\n\nimage.png\n\n\nAdapter cet algorithme (pour qu’il puisse fonctionner avec des sommets autres que des entiers de 0 à n) en prenant non pas une liste de prédécesseurs, mais un dictionnaire, puis compléter la fonction suivante qui détecte s’il y a un cycle ou non, et enfin la tester.\n\ndef detectionCycle(G,s):\n    ''' In : un graphe G non orienté et un sommet s\n        Out: True s'il n'y a pas de cycle atteignable par s, et False sinon'''\n    P=Pile()\n    Pred=dict() # le dictionnaire des prédécesseurs (inutile d'initialiser à -1 puisqu'il est vide)\n    P.empile(s)\n    Pred[s]=s\n    pass\n\n\n# Jeu de tests de la fonction detectionCycle\n\n\n# Test des différentes méthodes précédentes\n# me permet de voir que vos méthodes ont l'air correctes, c'est le cas si cette cellule ne renvoie pas d'erreur\nGTest=Graphe()\nfor i in range(0,20,2):\n    GTest.ajoute_arete(i,i+1)\n    GTest.ajoute_arete(i+1,i+2)\nassert detectionCycle(GTest,0)==False\nGTest.ajoute_arete(0,19)\nassert detectionCycle(GTest,0)==True\n\n\n\nQuestion 12\nCompléter la fonction suivante qui teste si le graphe donné est un arbre ou pas.\nChallenge : à faire sur 1 seule ligne (si c’est possible en utilisant les fonctions précédentes et sans compter la docstring évidemment)\n\ndef estUnArbre(G):\n    ''' \n    Teste si un graphe est un arbre\n    Args:\n        un graphe G non orienté\n    Returns:\n        True si G est un arbre et False sinon\n    '''\n    pass\n\n\n# Jeu de tests de la fonction estUnArbre\n\n\n# Test des différentes méthodes précédentes\n# me permet de voir que vos méthodes ont l'air correctes, c'est le cas si cette cellule ne renvoie pas d'erreur\nGTest=Graphe()\nfor i in range(0,20,2):\n    GTest.ajoute_arete(i,i+1)\n    GTest.ajoute_arete(i+1,i+2)\nassert estUnArbre(GTest)==True\nGTest.ajoute_arete(0,19)\nassert estUnArbre(GTest)==False\nGTestBis=Graphe()\nfor i in range(9):\n    for j in range(i+1,10):\n        GTestBis.ajoute_arete(i,j)\nfor i in range(10,19):\n    for j in range(i+1,20):\n        GTestBis.ajoute_arete(i,j) \nassert estUnArbre(GTestBis)==False"
  },
  {
    "objectID": "06-algo/exos_graphes_fiche1.html",
    "href": "06-algo/exos_graphes_fiche1.html",
    "title": "Exercices : Parcours de graphes",
    "section": "",
    "text": "Voici quatre animations qui représentent 4 parcours différents sur le même graphe à partir du sommet ‘A’.\nRepérer le parcours qui correspond bien à un parcours en profondeur du graphe à partir du sommet ‘A’.\nExpliquer pourquoi les autres parcours ne sont pas un parcours en profondeur du graphe à partir du sommet ‘A’.\nParcours 1 :\n\n\n\nParcours 1\n\n\nParcours 2 :\n\n\n\nParcours 2\n\n\nParcours 3 :\n\n\n\nParcours 3\n\n\nParcours 4 :\n\n\n\nParcours 4\n\n\n\n# Votre réponse ici"
  },
  {
    "objectID": "06-algo/exos_graphes_fiche1.html#exercice-1",
    "href": "06-algo/exos_graphes_fiche1.html#exercice-1",
    "title": "Exercices : Parcours de graphes",
    "section": "",
    "text": "Voici quatre animations qui représentent 4 parcours différents sur le même graphe à partir du sommet ‘A’.\nRepérer le parcours qui correspond bien à un parcours en profondeur du graphe à partir du sommet ‘A’.\nExpliquer pourquoi les autres parcours ne sont pas un parcours en profondeur du graphe à partir du sommet ‘A’.\nParcours 1 :\n\n\n\nParcours 1\n\n\nParcours 2 :\n\n\n\nParcours 2\n\n\nParcours 3 :\n\n\n\nParcours 3\n\n\nParcours 4 :\n\n\n\nParcours 4\n\n\n\n# Votre réponse ici"
  },
  {
    "objectID": "06-algo/exos_graphes_fiche1.html#exercice-2",
    "href": "06-algo/exos_graphes_fiche1.html#exercice-2",
    "title": "Exercices : Parcours de graphes",
    "section": "Exercice 2",
    "text": "Exercice 2\nDevant tant d’efforts pour comprendre les parcours, vous rêvez de partir en voyage sur le continent sud-américiain. Mais quel parcours effectuer pour visiter tous les pays de l’Amérique du Sud ?\nVous allez dans cet exercice :\n\nutiliser un graphe implémenté comme dictionnaire avec la liste des successeurs, représentant les pays frontaliers d’Amérique du Sud,\nprogrammer un parcours en profondeur,\nl’appliquer au voyage de votre rêve !\n\nVoici la carte des pays du continent sud-américain :\n\n\n\n\n\nOn considère le dictionnaire suivant qui permet d’associer à chaque pays d’Amérique du Sud la liste des pays partageant une frontière terrestre.\n\nG = {}\nG[\"France\"] = [\"Brésil\",\"Suriname\"]\nG[\"Argentine\"] = [\"Bolivie\",\"Brésil\",\"Chili\",\"Paraguay\",\"Uruguay\"]\nG[\"Bolivie\"] = [\"Argentine\",\"Brésil\",\"Chili\",\"Paraguay\",\"Pérou\",\"Uruguay\"]\nG[\"Brésil\"] = [\"Argentine\",\"Bolivie\",\"Colombie\",\"France\",\"Guyana\",\"Paraguay\",\"Pérou\",\"Suriname\",\"Uruguay\",\"Venezuela\"]\nG[\"Chili\"]=[\"Argentine\",\"Bolivie\",\"Pérou\"]\nG[\"Colombie\"] = [\"Brésil\",\"Équateur\",\"Pérou\",\"Venezuela\"]\nG[\"Équateur\"] = [\"Colombie\",\"Pérou\"]\nG[\"Guyana\"] = [\"Brésil\",\"Suriname\",\"Venezuela\"]\nG[\"Paraguay\"] = [\"Argentine\",\"Bolivie\",\"Brésil\"]\nG[\"Pérou\"] = [\"Bolivie\",\"Brésil\",\"Chili\",\"Colombie\",\"Équateur\"]\nG[\"Suriname\"] = [\"Brésil\",\"France\",\"Guyana\"]\nG[\"Uruguay\"] = [\"Argentine\",\"Bolivie\",\"Brésil\"]\nG[\"Venezuela\"] = [\"Brésil\",\"Colombie\",\"Guyana\"]\n\nPour savoir quels sommets ont déjà été visités ou non, vous allez utiliser un dictionnaire dont les clés seront les sommets du graphe et les valeurs associées seront les chaînes de caractères soit “inconnu”, soit “visite”\n\nCréer une fonction initialiser qui prend comme paramètre un graphe et renvoie un dictionnaire dont les clés sont les sommets du graphe et la valeur est toujours “inconnu”.\n\n\n# Votre code ci-dessous\n\n\nCréer une fonction visiter qui prend comme paramètre le dictionnaire associant à chaque sommet son état de connaissance et un sommet du graphe, fonction qui renvoie le dictionnaire de connaissance où la valeur associée au sommet entré est mise à ‘visite’\n\n\n# Votre code ci-dessous\n\n\nÉcrire en langage Python la procédure récursive parcours_longueur_rec correspondant à un parcours en profondeur en faisant aussi en sorte que chaque sommet qui vient d’être marqué soit affiché.\n\nCette procédure prend en argument un graphe et un sommet de ce graphe, sommet servant de point de départ au parcours.\nGérer l’affichage à l’aide de l’instruction print.\n\n# Votre code ci-dessous\n\n\nAppliquer cette procédure au graphe modélisant les pays d’Amérique du Sud en prenant comme racine, c’est-à-dire sommet de départ la France (pour la Guyane Française). À la lecture de tous les pays que vous allez visiter, vous allez être profondément heureux.ses.\n\n\n# Votre code ci-dessous"
  },
  {
    "objectID": "06-algo/exos_graphes_fiche1.html#exercice-3",
    "href": "06-algo/exos_graphes_fiche1.html#exercice-3",
    "title": "Exercices : Parcours de graphes",
    "section": "Exercice 3",
    "text": "Exercice 3\nDans cet exercice, nous reprenons la situation de l’exercice précédent, mais nous allons utiliser un parcours en largeur. De plus, le graphe sera maintenant implémenté avec le module Networkx.\nVous prendrez une liste Python en guise de file en considérant que la tête de la file correspond au premier élément de la liste.\nLe graphe sera supposé être un objet de la classe Graph() de la bibliothèque Networkx ; ceci permettra d’utiliser les méthodes de cette bibliothèque, comme :\n\ngraphe.neighbors(v) qui permet d’obtenir les voisins d’un sommet v du graphe graphe,\nvous pourrez transtyper en liste l’itérable les voisins d’un sommet donné grâce à list (comme fait dans le cours : list(graphe.neighbors(v))).\n\n\nÉcrire en langage Python une fonction parcours_largeur qui met en œuvre l’algorithme de parcours en largeur d’un graphe à partir d’un sommet donné.\n\n\n# Votre code ci-dessous\n\n\nTester cet algorithme de parcours en profondeur en prenant le graphe sur les pays d’Amérique du Sud.\n\n\n# Votre code ci-dessous\n\n\nEn vous aidant de la carte de l’Amérique du Sud ci-dessus, vérifier que la liste renvoyée correspond bien à un parcours en largeur.\n\n\n# Votre réponse ci-dessous"
  },
  {
    "objectID": "06-algo/index.html",
    "href": "06-algo/index.html",
    "title": "Programme",
    "section": "",
    "text": "Contenus\nCapacités attendues\nCommentaires\n\n\n\n\nAlgorithmes sur les arbres binaires et sur les arbres binaires de recherche.\nCalculer la taille et la hauteur d’un arbre. Parcourir un arbre de différentes façons (ordres infixe, préfixe ou suffixe ; ordre en largeur d’abord). Rechercher une clé dans un arbre de recherche, insérer une clé.\nUne structure de données récursive adaptée est utilisée. L’exemple des arbres permet d’illustrer la programmation par classe. La recherche dans un arbre de recherche équilibré est de coût logarithmique.\n\n\nMéthode « diviser pour régner ».\nÉcrire un algorithme utilisant la méthode « diviser pour régner ».\nLa rotation d’une image bitmap d’un quart de tour avec un coût en mémoire constant est un bon exemple. L’exemple du tri fusion permet également d’exploiter la récursivité et d’exhiber un algorithme de coût en \\(n log_2 n\\) dans les pires des cas."
  },
  {
    "objectID": "06-algo/index.html#programme",
    "href": "06-algo/index.html#programme",
    "title": "Programme",
    "section": "",
    "text": "Contenus\nCapacités attendues\nCommentaires\n\n\n\n\nAlgorithmes sur les arbres binaires et sur les arbres binaires de recherche.\nCalculer la taille et la hauteur d’un arbre. Parcourir un arbre de différentes façons (ordres infixe, préfixe ou suffixe ; ordre en largeur d’abord). Rechercher une clé dans un arbre de recherche, insérer une clé.\nUne structure de données récursive adaptée est utilisée. L’exemple des arbres permet d’illustrer la programmation par classe. La recherche dans un arbre de recherche équilibré est de coût logarithmique.\n\n\nMéthode « diviser pour régner ».\nÉcrire un algorithme utilisant la méthode « diviser pour régner ».\nLa rotation d’une image bitmap d’un quart de tour avec un coût en mémoire constant est un bon exemple. L’exemple du tri fusion permet également d’exploiter la récursivité et d’exhiber un algorithme de coût en \\(n log_2 n\\) dans les pires des cas."
  },
  {
    "objectID": "06-algo/rappels.html",
    "href": "06-algo/rappels.html",
    "title": "Rappels d’algorithmique",
    "section": "",
    "text": "Cette page regroupe quelques rappels importants. Revoir le cours de première pour les détails."
  },
  {
    "objectID": "06-algo/rappels.html#terminaison-et-correction",
    "href": "06-algo/rappels.html#terminaison-et-correction",
    "title": "Rappels d’algorithmique",
    "section": "1. Terminaison et Correction",
    "text": "1. Terminaison et Correction\n\nProuver la terminaison d’un algorithme, c’est prouver que l’algorithme se termine dans tous les cas. C’est notamment très important lorsque l’algorithme comporte des boucles conditionnelles ou des appels récursifs.\nProuver la correction d’un algorithme, c’est prouver que l’algorithme résout bien le problème demandé.\n\nPar exemple, dans le cas d’une boucle, on utilise un invariant de boucle : c’est une affirmation qui porte sur les valeurs des variables à l’intérieur de la boucle et qui reste vraie à la fin de chaque tour de la boucle.\nIl faut démontrer :\n\nInitialisation : l’affirmation est vraie avant le premier passage dans la boucle\nConservation : si l’affirmation est vraie avant une itération, alors elle sera aussi vraie après cette itération.\nConclusion : une fois la boucle terminée, l’affirmation est vraie.\n\n\n\n\n\n\n\nExemple\n\n\n\nConsidérons l’algorithme suivant qui calcule la puissance entière d’un nombre :\n\nfonction puissance(x : flottant, n : entier) : flottant p \\(\\leftarrow\\) 1 compteur \\(\\leftarrow\\) 0 tant que compteur &lt; n faire compteur \\(\\leftarrow\\) compteur + 1 p \\(\\leftarrow\\) p * x fin tant que retourner p\n\nTerminaison : Au départ la variable \\(compteur\\) est initialisée à 0. À chaque passage dans la boucle, sa valeur augmente d’une unité. La condition de sortie de boucle : \\(compteur\\geqslant n\\) sera donc réalisée en un nombre fini d’étapes (ici \\(n\\) étapes) et donc l’algorithme se termine.\nCorrection : Considérons la propriété \\(p=x^{compteur}\\) et montrons qu’il s’agit d’un invariant de boucle.\n\nInitialisation : Cette propriété est vraie avec les valeurs initiales des variables car \\(x^0=1\\) et \\(p=1\\).\nConservation : Si nous avons \\(p=x^{compteur}\\) avant une itération, alors nous avons \\(x^{compteur+1}=x^{compteur}\\times x = p\\times x\\). le passage dans la boucle augmente \\(compteur\\) de 1 et remplace \\(p\\) par \\(p\\times x\\). Après l’itération, la propriété \\(p=x^{compteur}\\) est donc encore vraie.\nConclusion : En sortie de boucle, on a donc \\(p=x^{compteur}\\). Or on a aussi l’égalité \\(compteur = n\\) qui a provoqué la sortie de boucle. Finalement, nous avons donc \\(p=x^n\\), ce qui prouve que l’algorithme effectue bien l’opération attendue."
  },
  {
    "objectID": "06-algo/rappels.html#complexité",
    "href": "06-algo/rappels.html#complexité",
    "title": "Rappels d’algorithmique",
    "section": "2. Complexité",
    "text": "2. Complexité\nLa durée d’exécution d’un programme traduisant un algorithme donné va dépendre des performances de la machine sur laquelle le programme est exécuté, mais aussi du nombre d’instructions élémentaires mobilisées lors de son exécution. Une partie de ce temps d’exécution provient donc de la façon dont l’algorithme est écrit et non de la façon dont il est programmé.\nOn parle de complexité temporelle d’un algorithme (et non d’un programme) pour mesurer l’efficacité intrinsèque de l’algorithme. Dans la pratique, il s’agit de compter le nombre d’opérations élémentaires (affectations, comparaisons, calculs arithmétiques, …) effectuées par l’algorithme.\nLa complexité en temps d’un algorithme dépend :\n\nde la taille des données passées en paramètres : plus ces données seront volumineuses, plus il faudra d’opérations élémentaires pour les traiter. On notera \\(n\\) le nombre de données à traiter.\nde la donnée en elle-même, de la façon dont sont réparties les différentes valeurs qui la constituent. Par exemple, si on effectue une recherche séquentielle d’un élément dans une liste non triée, on parcourt un par un les éléments jusqu’à trouver, ou pas, celui recherché. Ce parcours peut s’arrêter dès le début si le premier élément est “le bon”. Mais on peut également être amené à parcourir la liste en entier si l’élément cherché est en dernière position, ou même n’y figure pas.\n\nCette remarque conduit à préciser la définition de la complexité en temps. On peut en effet distinguer deux formes de complexité en temps :\n\nla complexité dans le meilleur des cas : c’est la situation la plus favorable, par exemple : recherche d’un élément situé à la première position d’une liste ;\nla complexité dans le pire des cas : c’est la situation la plus défavorable, par exemple : recherche d’un élément dans une liste alors qu’il n’y figure pas.\n\nOn calculera le plus souvent la complexité dans le pire des cas, car elle est la plus pertinente. Il vaut mieux en effet toujours envisager le pire.\n\nOrdres de grandeurs\nPour comparer des algorithmes, il n’est pas nécessaire de calculer la valeur exacte de la complexité, mais seulement un ordre de grandeur asymptotique, noté en mathématiques \\(\\mathcal{O}\\) (notation “grand O”). La définition rigoureuse de cette notation n’est pas au programme de NSI. Il faut cependant en avoir une idée intuitive : dire que la complexité d’un algorithme est en \\(\\mathcal{O}(n^2)\\), par exemple, signifie que cette complexité croît, lorsque \\(n\\) devient grand, de la même façon que la fonction carré. Plus précisément, elle est majorée par une fonction du type \\(c\\times n^2\\), où \\(c\\) est un réel positif.\nLes classes de complexité les plus courantes sont les suivantes, de la meilleure à la pire :\n\n\n\n\\(\\mathcal{O}\\)\nType de complexité\nExemple\n\n\n\n\n\\(\\mathcal{O}(1)\\)\nconstante\nAccès à une cellule de tableau\n\n\n\\(\\mathcal{O}(\\log n)\\)\nlogarithmique\nRecherche dichotomique\n\n\n\\(\\mathcal{O}(n)\\)\nlinéaire\nRecherche du maximum dans un tableau non trié\n\n\n\\(\\mathcal{O}(n\\log n)\\)\nquasi-linéaire\nTri fusion\n\n\n\\(\\mathcal{O}(n^2)\\)\nquadratique\nParcours d’un tableau à deux dimensions\n\n\n\\(\\mathcal{O}(n^3)\\)\ncubique\nParcours d’un tableau à trois dimensions\n\n\n\\(\\mathcal{O}(2^n)\\)\nexponentielle\nCalcul des termes de la suite de Fibonacci de façon naïve récursive\n\n\n\\(\\mathcal{O}(n!)\\)\nfactorielle\nProblème du voyageur de commerce\n\n\n\n\n\n\n\n\n\nExemple\n\n\n\nReprenons l’algorithme du calcul de la puissance d’un nombre.\n\nfonction puissance(x : flottant, n : entier) : flottant p \\(\\leftarrow\\) 1 compteur \\(\\leftarrow\\) 0 tant que compteur &lt; n faire compteur \\(\\leftarrow\\) compteur + 1 p \\(\\leftarrow\\) p * x fin tant que retourner p\n\nNous comptons la complexité en termes d’opérations arithmétiques : additions et multiplications. À chaque passage dans la boucle, nous avons deux opérations et la boucle est parcourue \\(n\\) fois . Nous avons donc au total une complexité de \\(2n\\) opérations arithmétiques, donc une complexité en \\(\\mathcal{O}(n)\\), linéaire."
  },
  {
    "objectID": "07-reseaux/adressesIP.html",
    "href": "07-reseaux/adressesIP.html",
    "title": "TP - Révisions sur les adresses IP",
    "section": "",
    "text": "Cette activité permet de (re)définir quelques notions facilitant la compréhension du chapitre sur les protocoles de routage.\n\n\n\nLa plupart du temps lorsque l’on parle de réseau, il s’agit en réalité d’un sous-réseau d’un réseau plus grand (par exemple un sous-réseau du réseau mondial IP).\nChacun de ses (sous-)réseaux possède une adresse IP, appelée adresse du (sous-)réseau. Dans un (sous-)réseau, il y a plusieurs machines que l’on appellent hôtes, possédant elles aussi une adresse IP dépendant de celle du (sous-)réseau.\nUne adresse IP (IPv4) est une suite de 32 bits (4 octets) exprimée en décimales à point, en séparant chacun des octets par un point : X1.X2.X3.X4 où X1, X2, X3 et X4 sont les valeurs des 4 octets.\nExemple :\n\nReprésentation binaire : 11000001 00110111 11011101 00111110\nReprésentation décimale pointée : 193.55.221.62 (où 193 est la valeur décimale de 11000001, 55 celle de 00110111, etc.)\n\n\n\n\nPour chaque adresse, une partie des bits (les bits de poids fort, à gauche) représente la partie « réseau », et l’autre partie (les bits de poids faible, à droite) représente la partie « hôte » c’est-à-dire la machine du réseau.\nPar exemple, si les 3 premiers octets représentent la partie réseau et le dernier la partie hôte, on obtient le découpage suivant :\n\n\n\nRéseau\nHôte\n\n\n\n\n11000001 00110111 11011101\n00111110\n\n\n193.55.221\n62\n\n\n\n✍️ Q1 : Si la partie réseau occupe les 3 premiers octets, quel est le nombre d’hôtes possibles pour le réseau en question ?\n✍️ Q2 : Et si la partie réseau occupe les 28 premiers bits ?\n\n\n\nLe mécanisme permettant de situer la limite en la partie réseau et la partie hôte s’appelle le masque de sous-réseau (en anglais : subnet mask). C’est aussi une suite de 32 bits :\n\nune série continue de 1 qui fixe la partie réseau (celle de gauche)\nune série continue de 0 qui correspond à la partie hôte\n\nExemple : Dans le cas où les 3 premiers octets représentent la partie réseau, alors le masque de sous-réseau est 11111111.11111111.11111111.00000000 ou 255.255.255.0 en décimal.\n✍️ Q3 : Si la partie réseau d’un sous-réseau occupe les 28 permiers bits, donner le masque de sous-réseau en notations binaire et décimale.\n\n\n\nLorsque l’on donne l’adresse IP d’un (sous-)réseau, il faut donc également donner le masque associé. On pourrait le donner en notation binaire ou décimale, mais pour simplifier on donne généralement juste le nombre de bits correspondant à la partie réseau : X1.X2.X3.X4 /n signifie que les n premiers bits de poids forts de l’adresse IP représentent la partie réseau, les bits suivants de poids faibles représentent la partie hôte.\n\nCette notation simplifiée s’appelle notation CIDR (Classless Inter-Domain Routing).\n\nExemple : le masque de sous-réseau 11111111.11111111.11111111.00000000 (ou 255.255.255.0) s’écrit donc plus simplement /24 car il y a 24 bits pour la partie réseau.\n✍️ Q4 : Déterminer la notation CIDR pour un sous-réseau dont le masque est 255.255.255.240.\n##Adresse réseau\nL’adresse réseau permet de savoir si 2 machines peuvent communiquer entre elles (directement). Si ces 2 machines ont une adresse réseau identique, alors elles appartiennent au même réseau et elles peuvent communiquer.\nCette adresse réseau est celle dont tous les bits de la partie hôte sont à 0, autrement dit l’adresse IP la plus “basse” du réseau.\nExemple : si 193.55.221.62 est une machine d’un réseau dont le masque est /24, alors l’adresse du réseau en question est :\n\n11000001 00110111 11011101 00000000 les 8 derniers bits pour l’hôte ont été mis à zéro\nen décimal cela donne 193.55.221.0.\n\nAinsi, le réseau en question se note 193.55.221.0 /24.\n\n\n\nL’adresse de diffusion ou broadcast est celle utilisée pour envoyer des paquets à toutes les machines du réseau.\nCette adresse de diffusion est celle dont les bits de la partie hôte sont à 1, autrement dit l’adresse IP la plus “haute” du réseau.\nExemple : Le réseau 193.55.221.0 /24 a donc pour adresse de diffusion 11000001 00110111 11011101 11111111 ou 193.55.221.255 en décimal.\n\n\n\nLa plage d’adresses machines est l’ensemble des adresses que peut prendre une machine sur le réseau. Comme l’adresse réseau et l’adresse de diffusion sont déjà prises, il reste toutes les adresses entre les deux pour les machines du réseau :\n\nla première adresse possible pour une machine est donc celle qui suit l’adresse réseau\nla dernière adresse possible pour une machine est donc celle qui précède l’adresse de diffusion\n\nExemple : Les machines sur le réseau 193.55.221.0 /24 ont des adresses IP variant de 193.55.221.1 (la première) à 193.55.221.254 (la dernière).\n✍️ Q5 : Une machine d’adresse IP 112.133.102.41 appartient à un réseau dont le masque est /24 (c’est-à-dire 255.255.255.0).\n\nDonner en notation binaire et en notation décimale, l’adresse réseau et l’adresse de diffusion du réseau.\nCombien de machines peut-on connecter dans ce réseau ? Quelle est leur plage d’adresses ?\n\n✍️ Q6 : Combien de machines peut-on connecter sur un réseau dont le masque est 255.255.240.0 ?\n✍️ Q7 : On installe 10 machines sur un réseau local. L’adresse IP 172.16.29.35 avec le masque 255.255.255.240 (soit /28) est attribuée à une de ces machines.\n\nCombien d’hôtes peut-on placer dans le réseau où est située cette machine ?\nDans quel réseau (préciser l’adresse) sont situées ces machines ?\nPour ce réseau, donnez la première et la dernière adresse IP valide pour ces machines.\nQuelle est l’adresse de diffusion (broadcast) pour ce réseau ?\n\n\n\n\nOn a dit précédemment que si 2 machines ont une adresse réseau identique, alors elles appartiennent au même réseau et elles peuvent communiquer.\nPour déterminer l’adresse réseau d’une adresse IP, il suffit d’appliquer l’opérateur logique ET (ou AND en anglais) bit à bit entre l’adresse IP et le masque de sous-réseau.\nOn rappelle l’opérateur ET a pour table de vérité :\n\n\n\nx\ny\nx ET y\n\n\n\n\n0\n0\n0\n\n\n1\n0\n0\n\n\n0\n1\n0\n\n\n1\n1\n1\n\n\n\nExemple : Pour déterminer l’adresse réseau de la machine d’adresse IP 193.55.221.62 avec le masque 255.255.255.0 :\n\n\n\n\n\n\n\n\nAdresse IP (d’une machine)\n11000001.00110111.11011101.00111110\n193.55.221.62\n\n\n\n\nMasque\n11111111.11111111.11111111.00000000\n255.255.255.0\n\n\nAdresse réseau\n11000001.00110111.11011101.00000000\n193.55.221.0\n\n\n\n✍️ Q8 : Un réseau local contient une machine d’adresse IP 192.168.0.1 avec le masque /20. La machine d’adresse IP 192.168.1.3 appartient-elle au même réseau ? Vous comparerez les adresses réseaux de ces deux machines pour répondre.\n\n\n\nL’objectif de cette partie est d’écrire une fonction meme_sous_reseau(ip_a, ip_b, masque) qui renvoie un booléen indiquant si les machines A et B font partie du même sous-réseau.\nCette partie est à traiter dans Capytale : https://capytale2.ac-paris.fr/web/c/aa58-1299451.\nOn rappelle quelques instructions qui pourront s’avérer utiles :\n    &gt;&gt;&gt; bin(45)\n    '0b101101'\n    &gt;&gt;&gt; chaine = \"bonjour à tous !\"\n    &gt;&gt;&gt; chaine.split(' ')  # on sépare la chaîne selon le caractère espace\n    ['bonjour', 'à', 'tous', '!']\n    def et_logique(bit1, bit2):\n        \"\"\"\n        Renvoie le résultat de l'opération logique bit1 ET bit2.\n        \n        Entrées : deux string d'1 caractère ('0' ou '1')\n        Sortie : string \n        \"\"\"\n        # à vous de jouer !\n        pass\n\n    def test_et_logique():\n        assert et_logique('0', '0') == '0'\n        assert et_logique('0', '1') == '0'\n        assert et_logique('1', '0') == '0'\n        assert et_logique('1', '1') == '1'\n        \n\n    def entier_en_mot_binaire(entier, longueur_mot_binaire):\n        \"\"\"\n        Renvoie un mot binaire correspondant à l'entier.\n        \n        Entrées :\n            entier : int\n            longueur_mot_binaire : int de longueur supérieure ou égale au nombre de bits de nécessaires\n        pour convertir entier en base 2\n        \n        Sortie : string de longueur longueur_mot_binaire            \n        \"\"\"\n        # à vous de jouer !\n        pass\n\n    def test_entier_en_mot_binaire():\n        assert entier_en_mot_binaire(1, 8) == '00000001'\n        assert entier_en_mot_binaire(192, 8) == '11000000'\n        assert entier_en_mot_binaire(168, 8) == '10101000'\n\n\n    def masque_en_mot_binaire(masque):\n        \"\"\"\n        Renvoie la conversion du masque en un mot binaire.\n        \n        Entrée : masque (int)\n        Sortie : string de 32 caractères\n        \"\"\"\n        # à vous de jouer !\n        pass\n\n    def test_masque_en_mot_binaire():\n        assert masque_en_mot_binaire(24) == '11111111111111111111111100000000'\n        \n\n\n    def ip_en_liste(ip):\n        \"\"\"\n        Renvoie une liste dont les éléments sont les 4 octets de l'adresse ip.\n        \n        Entrée : ip (string) \n        Sortie : liste d'entiers\n        \"\"\"\n        # à vous de jouer !\n        pass\n\n    def test_ip_en_liste():\n        assert ip_en_liste('192.168.0.1') == [192, 168, 0, 1]\n        \n        \n\n    def ip_en_mot_binaire(ip):\n        \"\"\"\n        Renvoie la conversion d'une ip en un mot binaire.\n        \n        Entrée : string contenant une IP (ex \"192.168.0.1\")\n        Sortie : string de 32 caractères\n        \"\"\"\n        # à vous de jouer !\n        pass\n        \n    def test_ip_en_mot_binaire():\n        assert ip_en_mot_binaire(\"192.168.0.1\") == '11000000101010000000000000000001'\n        \n\n\n    def adresse_reseau_ip(ip, masque):\n        \"\"\"\n        Renvoie l'adresse réseau de l'adresse ip avec le masque masque.\n        \n        Entrées :\n            ip : string contenant une IP (ex \"192.168.0.1\")\n            masque : entier du masque en notation CIDR (ex : 24)\n        Sortie : string de 32 caractères    \n        \"\"\"\n        # à vous de jouer !\n        pass\n\n           \n    def test_adresse_reseau_ip():\n        assert adresse_reseau_ip(\"192.168.0.1\", 24) == '11000000101010000000000000000000'\n        assert adresse_reseau_ip(\"192.168.1.3\", 24) == '11000000101010000000000100000000'\n        assert adresse_reseau_ip(\"192.168.0.1\", 20) == '11000000101010000000000000000000'\n        assert adresse_reseau_ip(\"192.168.1.3\", 20) == '11000000101010000000000000000000'\n        \n\n\n    def meme_sous_reseau(ip_a, ip_b, masque):\n        \"\"\"\n        Renvoie un booléen indiquant si ip_a et ip_b sont dans un même réseau de masque masque.\n        \n        Entrées :\n        ip_a:  string contenant une IP (ex \"192.168.0.1\")\n        ip_b : string contenant une IP\n        masque : entier du masque en notation CIDR (ex : 24)\n        \"\"\"\n        # à vous de jouer !\n        pass\n\n    def test_meme_sous_reseau():\n        assert meme_sous_reseau(\"192.168.0.1\", \"192.168.1.3\", 24) == False\n        assert meme_sous_reseau(\"192.168.0.1\", \"192.168.1.3\", 20) == True\n        assert meme_sous_reseau(\"192.168.0.1\", \"192.168.0.3\", 30) == True\nSource : https://info-mounier.fr/terminale_nsi/archi_se_reseaux/ip_reseau_masque.php"
  },
  {
    "objectID": "07-reseaux/adressesIP.html#adresse-ip",
    "href": "07-reseaux/adressesIP.html#adresse-ip",
    "title": "TP - Révisions sur les adresses IP",
    "section": "",
    "text": "La plupart du temps lorsque l’on parle de réseau, il s’agit en réalité d’un sous-réseau d’un réseau plus grand (par exemple un sous-réseau du réseau mondial IP).\nChacun de ses (sous-)réseaux possède une adresse IP, appelée adresse du (sous-)réseau. Dans un (sous-)réseau, il y a plusieurs machines que l’on appellent hôtes, possédant elles aussi une adresse IP dépendant de celle du (sous-)réseau.\nUne adresse IP (IPv4) est une suite de 32 bits (4 octets) exprimée en décimales à point, en séparant chacun des octets par un point : X1.X2.X3.X4 où X1, X2, X3 et X4 sont les valeurs des 4 octets.\nExemple :\n\nReprésentation binaire : 11000001 00110111 11011101 00111110\nReprésentation décimale pointée : 193.55.221.62 (où 193 est la valeur décimale de 11000001, 55 celle de 00110111, etc.)"
  },
  {
    "objectID": "07-reseaux/adressesIP.html#structure-dune-adresse-ip-parties-réseau-et-hôte",
    "href": "07-reseaux/adressesIP.html#structure-dune-adresse-ip-parties-réseau-et-hôte",
    "title": "TP - Révisions sur les adresses IP",
    "section": "",
    "text": "Pour chaque adresse, une partie des bits (les bits de poids fort, à gauche) représente la partie « réseau », et l’autre partie (les bits de poids faible, à droite) représente la partie « hôte » c’est-à-dire la machine du réseau.\nPar exemple, si les 3 premiers octets représentent la partie réseau et le dernier la partie hôte, on obtient le découpage suivant :\n\n\n\nRéseau\nHôte\n\n\n\n\n11000001 00110111 11011101\n00111110\n\n\n193.55.221\n62\n\n\n\n✍️ Q1 : Si la partie réseau occupe les 3 premiers octets, quel est le nombre d’hôtes possibles pour le réseau en question ?\n✍️ Q2 : Et si la partie réseau occupe les 28 premiers bits ?"
  },
  {
    "objectID": "07-reseaux/adressesIP.html#masque-de-sous-réseau",
    "href": "07-reseaux/adressesIP.html#masque-de-sous-réseau",
    "title": "TP - Révisions sur les adresses IP",
    "section": "",
    "text": "Le mécanisme permettant de situer la limite en la partie réseau et la partie hôte s’appelle le masque de sous-réseau (en anglais : subnet mask). C’est aussi une suite de 32 bits :\n\nune série continue de 1 qui fixe la partie réseau (celle de gauche)\nune série continue de 0 qui correspond à la partie hôte\n\nExemple : Dans le cas où les 3 premiers octets représentent la partie réseau, alors le masque de sous-réseau est 11111111.11111111.11111111.00000000 ou 255.255.255.0 en décimal.\n✍️ Q3 : Si la partie réseau d’un sous-réseau occupe les 28 permiers bits, donner le masque de sous-réseau en notations binaire et décimale."
  },
  {
    "objectID": "07-reseaux/adressesIP.html#notation-cidr",
    "href": "07-reseaux/adressesIP.html#notation-cidr",
    "title": "TP - Révisions sur les adresses IP",
    "section": "",
    "text": "Lorsque l’on donne l’adresse IP d’un (sous-)réseau, il faut donc également donner le masque associé. On pourrait le donner en notation binaire ou décimale, mais pour simplifier on donne généralement juste le nombre de bits correspondant à la partie réseau : X1.X2.X3.X4 /n signifie que les n premiers bits de poids forts de l’adresse IP représentent la partie réseau, les bits suivants de poids faibles représentent la partie hôte.\n\nCette notation simplifiée s’appelle notation CIDR (Classless Inter-Domain Routing).\n\nExemple : le masque de sous-réseau 11111111.11111111.11111111.00000000 (ou 255.255.255.0) s’écrit donc plus simplement /24 car il y a 24 bits pour la partie réseau.\n✍️ Q4 : Déterminer la notation CIDR pour un sous-réseau dont le masque est 255.255.255.240.\n##Adresse réseau\nL’adresse réseau permet de savoir si 2 machines peuvent communiquer entre elles (directement). Si ces 2 machines ont une adresse réseau identique, alors elles appartiennent au même réseau et elles peuvent communiquer.\nCette adresse réseau est celle dont tous les bits de la partie hôte sont à 0, autrement dit l’adresse IP la plus “basse” du réseau.\nExemple : si 193.55.221.62 est une machine d’un réseau dont le masque est /24, alors l’adresse du réseau en question est :\n\n11000001 00110111 11011101 00000000 les 8 derniers bits pour l’hôte ont été mis à zéro\nen décimal cela donne 193.55.221.0.\n\nAinsi, le réseau en question se note 193.55.221.0 /24."
  },
  {
    "objectID": "07-reseaux/adressesIP.html#adresse-de-diffusion",
    "href": "07-reseaux/adressesIP.html#adresse-de-diffusion",
    "title": "TP - Révisions sur les adresses IP",
    "section": "",
    "text": "L’adresse de diffusion ou broadcast est celle utilisée pour envoyer des paquets à toutes les machines du réseau.\nCette adresse de diffusion est celle dont les bits de la partie hôte sont à 1, autrement dit l’adresse IP la plus “haute” du réseau.\nExemple : Le réseau 193.55.221.0 /24 a donc pour adresse de diffusion 11000001 00110111 11011101 11111111 ou 193.55.221.255 en décimal."
  },
  {
    "objectID": "07-reseaux/adressesIP.html#plage-dadresses-machines",
    "href": "07-reseaux/adressesIP.html#plage-dadresses-machines",
    "title": "TP - Révisions sur les adresses IP",
    "section": "",
    "text": "La plage d’adresses machines est l’ensemble des adresses que peut prendre une machine sur le réseau. Comme l’adresse réseau et l’adresse de diffusion sont déjà prises, il reste toutes les adresses entre les deux pour les machines du réseau :\n\nla première adresse possible pour une machine est donc celle qui suit l’adresse réseau\nla dernière adresse possible pour une machine est donc celle qui précède l’adresse de diffusion\n\nExemple : Les machines sur le réseau 193.55.221.0 /24 ont des adresses IP variant de 193.55.221.1 (la première) à 193.55.221.254 (la dernière).\n✍️ Q5 : Une machine d’adresse IP 112.133.102.41 appartient à un réseau dont le masque est /24 (c’est-à-dire 255.255.255.0).\n\nDonner en notation binaire et en notation décimale, l’adresse réseau et l’adresse de diffusion du réseau.\nCombien de machines peut-on connecter dans ce réseau ? Quelle est leur plage d’adresses ?\n\n✍️ Q6 : Combien de machines peut-on connecter sur un réseau dont le masque est 255.255.240.0 ?\n✍️ Q7 : On installe 10 machines sur un réseau local. L’adresse IP 172.16.29.35 avec le masque 255.255.255.240 (soit /28) est attribuée à une de ces machines.\n\nCombien d’hôtes peut-on placer dans le réseau où est située cette machine ?\nDans quel réseau (préciser l’adresse) sont situées ces machines ?\nPour ce réseau, donnez la première et la dernière adresse IP valide pour ces machines.\nQuelle est l’adresse de diffusion (broadcast) pour ce réseau ?"
  },
  {
    "objectID": "07-reseaux/adressesIP.html#appartenance-à-un-même-réseau",
    "href": "07-reseaux/adressesIP.html#appartenance-à-un-même-réseau",
    "title": "TP - Révisions sur les adresses IP",
    "section": "",
    "text": "On a dit précédemment que si 2 machines ont une adresse réseau identique, alors elles appartiennent au même réseau et elles peuvent communiquer.\nPour déterminer l’adresse réseau d’une adresse IP, il suffit d’appliquer l’opérateur logique ET (ou AND en anglais) bit à bit entre l’adresse IP et le masque de sous-réseau.\nOn rappelle l’opérateur ET a pour table de vérité :\n\n\n\nx\ny\nx ET y\n\n\n\n\n0\n0\n0\n\n\n1\n0\n0\n\n\n0\n1\n0\n\n\n1\n1\n1\n\n\n\nExemple : Pour déterminer l’adresse réseau de la machine d’adresse IP 193.55.221.62 avec le masque 255.255.255.0 :\n\n\n\n\n\n\n\n\nAdresse IP (d’une machine)\n11000001.00110111.11011101.00111110\n193.55.221.62\n\n\n\n\nMasque\n11111111.11111111.11111111.00000000\n255.255.255.0\n\n\nAdresse réseau\n11000001.00110111.11011101.00000000\n193.55.221.0\n\n\n\n✍️ Q8 : Un réseau local contient une machine d’adresse IP 192.168.0.1 avec le masque /20. La machine d’adresse IP 192.168.1.3 appartient-elle au même réseau ? Vous comparerez les adresses réseaux de ces deux machines pour répondre."
  },
  {
    "objectID": "07-reseaux/adressesIP.html#partie-programmation",
    "href": "07-reseaux/adressesIP.html#partie-programmation",
    "title": "TP - Révisions sur les adresses IP",
    "section": "",
    "text": "L’objectif de cette partie est d’écrire une fonction meme_sous_reseau(ip_a, ip_b, masque) qui renvoie un booléen indiquant si les machines A et B font partie du même sous-réseau.\nCette partie est à traiter dans Capytale : https://capytale2.ac-paris.fr/web/c/aa58-1299451.\nOn rappelle quelques instructions qui pourront s’avérer utiles :\n    &gt;&gt;&gt; bin(45)\n    '0b101101'\n    &gt;&gt;&gt; chaine = \"bonjour à tous !\"\n    &gt;&gt;&gt; chaine.split(' ')  # on sépare la chaîne selon le caractère espace\n    ['bonjour', 'à', 'tous', '!']\n    def et_logique(bit1, bit2):\n        \"\"\"\n        Renvoie le résultat de l'opération logique bit1 ET bit2.\n        \n        Entrées : deux string d'1 caractère ('0' ou '1')\n        Sortie : string \n        \"\"\"\n        # à vous de jouer !\n        pass\n\n    def test_et_logique():\n        assert et_logique('0', '0') == '0'\n        assert et_logique('0', '1') == '0'\n        assert et_logique('1', '0') == '0'\n        assert et_logique('1', '1') == '1'\n        \n\n    def entier_en_mot_binaire(entier, longueur_mot_binaire):\n        \"\"\"\n        Renvoie un mot binaire correspondant à l'entier.\n        \n        Entrées :\n            entier : int\n            longueur_mot_binaire : int de longueur supérieure ou égale au nombre de bits de nécessaires\n        pour convertir entier en base 2\n        \n        Sortie : string de longueur longueur_mot_binaire            \n        \"\"\"\n        # à vous de jouer !\n        pass\n\n    def test_entier_en_mot_binaire():\n        assert entier_en_mot_binaire(1, 8) == '00000001'\n        assert entier_en_mot_binaire(192, 8) == '11000000'\n        assert entier_en_mot_binaire(168, 8) == '10101000'\n\n\n    def masque_en_mot_binaire(masque):\n        \"\"\"\n        Renvoie la conversion du masque en un mot binaire.\n        \n        Entrée : masque (int)\n        Sortie : string de 32 caractères\n        \"\"\"\n        # à vous de jouer !\n        pass\n\n    def test_masque_en_mot_binaire():\n        assert masque_en_mot_binaire(24) == '11111111111111111111111100000000'\n        \n\n\n    def ip_en_liste(ip):\n        \"\"\"\n        Renvoie une liste dont les éléments sont les 4 octets de l'adresse ip.\n        \n        Entrée : ip (string) \n        Sortie : liste d'entiers\n        \"\"\"\n        # à vous de jouer !\n        pass\n\n    def test_ip_en_liste():\n        assert ip_en_liste('192.168.0.1') == [192, 168, 0, 1]\n        \n        \n\n    def ip_en_mot_binaire(ip):\n        \"\"\"\n        Renvoie la conversion d'une ip en un mot binaire.\n        \n        Entrée : string contenant une IP (ex \"192.168.0.1\")\n        Sortie : string de 32 caractères\n        \"\"\"\n        # à vous de jouer !\n        pass\n        \n    def test_ip_en_mot_binaire():\n        assert ip_en_mot_binaire(\"192.168.0.1\") == '11000000101010000000000000000001'\n        \n\n\n    def adresse_reseau_ip(ip, masque):\n        \"\"\"\n        Renvoie l'adresse réseau de l'adresse ip avec le masque masque.\n        \n        Entrées :\n            ip : string contenant une IP (ex \"192.168.0.1\")\n            masque : entier du masque en notation CIDR (ex : 24)\n        Sortie : string de 32 caractères    \n        \"\"\"\n        # à vous de jouer !\n        pass\n\n           \n    def test_adresse_reseau_ip():\n        assert adresse_reseau_ip(\"192.168.0.1\", 24) == '11000000101010000000000000000000'\n        assert adresse_reseau_ip(\"192.168.1.3\", 24) == '11000000101010000000000100000000'\n        assert adresse_reseau_ip(\"192.168.0.1\", 20) == '11000000101010000000000000000000'\n        assert adresse_reseau_ip(\"192.168.1.3\", 20) == '11000000101010000000000000000000'\n        \n\n\n    def meme_sous_reseau(ip_a, ip_b, masque):\n        \"\"\"\n        Renvoie un booléen indiquant si ip_a et ip_b sont dans un même réseau de masque masque.\n        \n        Entrées :\n        ip_a:  string contenant une IP (ex \"192.168.0.1\")\n        ip_b : string contenant une IP\n        masque : entier du masque en notation CIDR (ex : 24)\n        \"\"\"\n        # à vous de jouer !\n        pass\n\n    def test_meme_sous_reseau():\n        assert meme_sous_reseau(\"192.168.0.1\", \"192.168.1.3\", 24) == False\n        assert meme_sous_reseau(\"192.168.0.1\", \"192.168.1.3\", 20) == True\n        assert meme_sous_reseau(\"192.168.0.1\", \"192.168.0.3\", 30) == True\nSource : https://info-mounier.fr/terminale_nsi/archi_se_reseaux/ip_reseau_masque.php"
  },
  {
    "objectID": "07-reseaux/routage_cours.html",
    "href": "07-reseaux/routage_cours.html",
    "title": "Routage - Cours",
    "section": "",
    "text": "Les protocoles de routage sont des algorithmes utilisés par les équipements réseau pour acheminer les données d’un point à un autre dans un réseau informatique. Ils permettent de déterminer la meilleure route à suivre pour atteindre la destination finale et de transmettre les données de manière efficace et fiable.\nIl existe plusieurs types de protocoles de routage, qui peuvent être classés selon leur mode de fonctionnement :\n\nLes protocoles de routage statiques : dans ce cas, les routes sont configurées manuellement par l’administrateur réseau et ne sont pas modifiées par la suite. Le protocole de routage statique est généralement utilisé dans les petits réseaux ou lorsque la topologie du réseau est stable.\nLes protocoles de routage dynamiques : dans ce cas, les routes sont déterminées de manière automatique grâce à l’échange de messages entre les équipements réseau. Les protocoles de routage dynamiques sont utilisés dans les réseaux de grande envergure ou lorsque la topologie du réseau est souvent modifiée.\nLes protocoles de routage hybrides : il s’agit d’une combinaison des protocoles de routage statiques et dynamiques, avec une utilisation mixte de routes configurées manuellement et de routes déterminées de manière automatique.\n\nLes protocoles de routage sont utilisés dans tous les types de réseaux, qu’il s’agisse de réseaux locaux (LAN), de réseaux étendus (WAN) ou de réseaux privés virtuels (VPN). Ils jouent un rôle crucial dans la communication entre différents équipements réseau et dans la connectivité globale d’un réseau.\nOn s’intéresse ici seulement à deux exemples de protocoles de routages dynamiques : le protocole RIP et le protocole OSPF.\n\n\n\n\n\n\nDéfinition : protocole de routage\n\n\n\nUn protocole de routage est un algorithme utilisé par les équipements réseau pour acheminer les données d’un point à un autre dans un réseau informatique."
  },
  {
    "objectID": "07-reseaux/routage_cours.html#introduction-aux-protocoles-de-routage",
    "href": "07-reseaux/routage_cours.html#introduction-aux-protocoles-de-routage",
    "title": "Routage - Cours",
    "section": "",
    "text": "Les protocoles de routage sont des algorithmes utilisés par les équipements réseau pour acheminer les données d’un point à un autre dans un réseau informatique. Ils permettent de déterminer la meilleure route à suivre pour atteindre la destination finale et de transmettre les données de manière efficace et fiable.\nIl existe plusieurs types de protocoles de routage, qui peuvent être classés selon leur mode de fonctionnement :\n\nLes protocoles de routage statiques : dans ce cas, les routes sont configurées manuellement par l’administrateur réseau et ne sont pas modifiées par la suite. Le protocole de routage statique est généralement utilisé dans les petits réseaux ou lorsque la topologie du réseau est stable.\nLes protocoles de routage dynamiques : dans ce cas, les routes sont déterminées de manière automatique grâce à l’échange de messages entre les équipements réseau. Les protocoles de routage dynamiques sont utilisés dans les réseaux de grande envergure ou lorsque la topologie du réseau est souvent modifiée.\nLes protocoles de routage hybrides : il s’agit d’une combinaison des protocoles de routage statiques et dynamiques, avec une utilisation mixte de routes configurées manuellement et de routes déterminées de manière automatique.\n\nLes protocoles de routage sont utilisés dans tous les types de réseaux, qu’il s’agisse de réseaux locaux (LAN), de réseaux étendus (WAN) ou de réseaux privés virtuels (VPN). Ils jouent un rôle crucial dans la communication entre différents équipements réseau et dans la connectivité globale d’un réseau.\nOn s’intéresse ici seulement à deux exemples de protocoles de routages dynamiques : le protocole RIP et le protocole OSPF.\n\n\n\n\n\n\nDéfinition : protocole de routage\n\n\n\nUn protocole de routage est un algorithme utilisé par les équipements réseau pour acheminer les données d’un point à un autre dans un réseau informatique."
  },
  {
    "objectID": "07-reseaux/routage_cours.html#protocoles-de-routage-dynamiques-généralités",
    "href": "07-reseaux/routage_cours.html#protocoles-de-routage-dynamiques-généralités",
    "title": "Routage - Cours",
    "section": "2. Protocoles de routage dynamiques : généralités",
    "text": "2. Protocoles de routage dynamiques : généralités\nLe protocole de routage dynamique est un type de protocole de routage où les routes sont déterminées de manière automatique par les équipements réseau en échangeant des informations de routage entre eux. Cela signifie que les équipements réseau sont capables de mettre à jour leurs tables de routage en fonction des changements dans la topologie du réseau.\n\n\n\n\n\n\nDéfinition : table de routage\n\n\n\nUne table de routage est une liste des routes configurées sur un équipement réseau. Elle contient les informations de routage nécessaires pour acheminer les données vers une destination spécifique.\n\n\nIl existe plusieurs protocoles de routage dynamiques, tels que RIP (Routing Information Protocol) et OSPF (Open Shortest Path First). Chacun de ces protocoles utilise des algorithmes différents pour déterminer la route optimale à suivre pour atteindre une destination. Par exemple, RIP utilise le nombre de sauts comme critère de sélection, tandis que OSPF utilise le coût de la route.\nLe protocole de routage dynamique présente plusieurs avantages par rapport au protocole de routage statique :\n\nFlexibilité : les équipements réseau sont capables de s’adapter aux changements de topologie du réseau en mettant à jour leurs tables de routage en temps réel, ce qui permet une meilleure tolérance aux erreurs et une meilleure robustesse.\nScalabilité : les protocoles de routage dynamiques sont adaptés aux réseaux de grande envergure, car ils permettent une gestion automatisée des routes dans tout le réseau.\nRobustesse : en cas de problème sur une route, les protocoles de routage dynamiques peuvent trouver une route alternative pour atteindre la destination, ce qui réduit les temps de panne."
  },
  {
    "objectID": "07-reseaux/routage_cours.html#zoom-sur-le-protocole-rip",
    "href": "07-reseaux/routage_cours.html#zoom-sur-le-protocole-rip",
    "title": "Routage - Cours",
    "section": "3. Zoom sur le protocole RIP",
    "text": "3. Zoom sur le protocole RIP\nLe protocole RIP (Routing Information Protocol) est un protocole de routage dynamique qui utilise l’algorithme à vecteur de distance pour déterminer la route optimale à suivre pour atteindre une destination. Dans le protocole RIP, chaque équipement réseau possède une table de routage qui contient la liste des destinations et le nombre de sauts (ou “hops”) nécessaires pour atteindre ces destinations. L’objectif est de minimiser le nombre de sauts pour atteindre une destination.\nPour mettre à jour ses informations de routage, un équipement réseau envoie périodiquement toutes les 30 secondes (par défaut) un message de diffusion à tous ses voisins, contenant la liste des routes qu’il connaît. Les équipements réseau voisins reçoivent ce message et mettent à jour leurs propres tables de routage en fonction des informations reçues. Si un équipement réseau reçoit une route plus courte pour atteindre une destination que celle enregistrée dans sa table de routage, il met à jour sa table de routage en conséquence.\nPlus précisément :\n\n\n\n\n\n\nAlgorithme à vecteur de distance\n\n\n\n\nChaque équipement réseau maintient une table de routage composée d’une adresse destination, de l’adresse du routeur qui permet de l’atteindre (passerelle ou gateway) depuis le routeur de la table de routage et de la distance (nombre de sauts) pour atteindre la destination via ce routeur.\nChaque équipement réseau échange régulièrement un vecteur de distances avec ses voisins immédiats. Il s’agit d’une liste des routes qu’il connaît, avec le nombre de sauts pour atteindre chaque destination.\nLorsqu’un équipement réseau reçoit un vecteur de distance de l’un de ses voisins, il met à jour sa propre table de routage en y ajoutant la distance (nombre de sauts) depuis son propre équipement jusqu’au voisin. Si la distance est inférieure à celle indiquée dans sa propre table de routage, l’équipement réseau met à jour sa table de routage en conséquence.\nLorsqu’un équipement réseau souhaite envoyer un paquet à une destination, il regarde dans sa table de routage et choisit la route qui nécessite le moins de sauts pour atteindre la destination. Si plusieurs routes ont le même nombre de sauts, l’équipement réseau en choisit une au hasard.\nSi l’équipement réseau ne trouve pas de route vers la destination dans sa table de routage, il envoie le paquet à un équipement réseau “par défaut” (généralement le routeur de l’opérateur de réseau), qui essaiera à son tour de trouver une route vers la destination.\nSi un routeur ne reçoit pas pendant 3 minutes d’information de la part d’un routeur qui lui avait auparavant communiqué sa table de routage, ce routeur est considéré comme en panne, et toutes les routes passant par lui sont affectées de la distance infinie : 16.\n\n\n\n\n\n\n\n\n\nExemple\n\n\n\n\n\n\n\n\nDans l’exemple ci-dessus, le routeur A reçoit le vecteur transmis par le routeur B.\n\nPour le routeur 11, la table de routage du routeur A contient déjà une distance à 0 donc cette entrée de la table de routage reste inchangée.\nPour le routeur 27, la table de routage du routeur A contient une route avec une distance de 6. La distance de 2 incrémentée de 1, pour compter le routeur B qui sera en plus à traverser, est plus intéressante. L’entrée de la table de routage du réseau 27 est mise à jour avec une distance à 3 et le prochain routeur traversé qui devient le routeur B.\nPour le réseau 30, la table de routage du routeur A ne contenait pas de route donc l’entrée est ajoutée avec l’incrémentation de la distance de 1 et le prochain routeur qui est alors B.\nPour le réseau 33, la table de routage du routeur A contient une route avec une distance de 4 donc la distance incrémentée de 1 n’étant pas inférieure à 4, la table de routage du routeur A n’est pas mise à jour.\nPour le réseau 35, la table de routage du routeur A contient une route avec une distance de 3 donc la distance incrémentée de 1 n’étant pas inférieure à 3, la table de routage du routeur A n’est pas mise à jour.\n\n\n\nLe protocole RIP a l’avantage d’être simple à configurer et à utiliser, mais il présente plusieurs inconvénients :\n\nle protocole RIP est limité à un maximum de 15 sauts pour atteindre une destination, ce qui le rend peu adapté aux réseaux de grande envergure. C’est pour cette raison que la distance infinie (16) est utilisée pour indiquer que la route n’est pas accessible.\nle protocole RIP ne tient pas compte de la charge du réseau, ni de la qualité du lien. Il est donc possible que des routes moins optimales soient utilisées, ce qui peut entraîner des problèmes de performance.\navec ce protocole, les routeurs n’ont pas connaissance de la topologie du réseau. Ils ne peuvent donc pas détecter les boucles de routage et peuvent donc être amenés à envoyer des paquets en boucle."
  },
  {
    "objectID": "07-reseaux/routage_cours.html#zoom-sur-le-protocole-ospf",
    "href": "07-reseaux/routage_cours.html#zoom-sur-le-protocole-ospf",
    "title": "Routage - Cours",
    "section": "4. Zoom sur le protocole OSPF",
    "text": "4. Zoom sur le protocole OSPF\n\n4.1. Principe\nLe protocole OSPF (Open Shortest Path First) est un protocole de routage dynamique qui utilise l’algorithme à état de lien pour déterminer la route optimale à suivre pour atteindre une destination. Dans le protocole OSPF, chaque équipement réseau possède une table de routage qui contient la liste des destinations et le coût de la route pour atteindre ces destinations.\nPour mettre à jour ses informations de routage, un équipement réseau envoie périodiquement des messages à ses voisins, contenant des informations sur les routes qu’il connaît. Les équipements réseau voisins reçoivent ces messages et mettent à jour leurs propres tables de routage en fonction des informations reçues. Si un équipement réseau reçoit une route plus courte pour atteindre une destination que celle enregistrée dans sa table de routage, il met à jour sa table de routage en conséquence.\nPlus précisément :\n\n\n\n\n\n\nAlgorithme à état de lien\n\n\n\n\nChaque équipement réseau maintient une table de routage, qui indique le coût de la route vers chaque réseau connu. Le coût de la route est généralement défini en fonction du type de lien utilisé pour relier les équipements réseau (par exemple, un lien Ethernet a un coût inférieur à un lien Modem).\nChaque équipement réseau échange régulièrement des informations d’état de lien avec ses voisins immédiats. Ces informations comprennent le coût de chaque lien et les réseaux atteignables par chaque voisin.\nLorsqu’un équipement réseau reçoit des informations d’état de lien d’un de ses voisins, il met à jour sa propre table de routage en y ajoutant le coût de la route depuis son propre équipement jusqu’au voisin. Si le coût est inférieur à celui indiqué dans sa propre table de routage, l’équipement réseau met à jour sa table de routage en conséquence.\nLorsqu’un équipement réseau souhaite envoyer un paquet à une destination, il regarde dans sa table de routage et choisit la route qui a le coût le plus faible pour atteindre la destination. Si plusieurs routes ont le même coût, l’équipement réseau en choisit une au hasard.\nSi l’équipement réseau ne trouve pas de route vers la destination dans sa table de routage, il envoie le paquet à un équipement réseau “par défaut” (généralement le routeur de l’opérateur de réseau), qui essaiera à son tour de trouver une route vers la destination.\n\n\n\nLe protocole OSPF a l’avantage de s’adapter rapidement en cas de changements de topologie du réseau, grâce à son algorithme à état de lien qui permet de mettre à jour les informations de routage de manière ciblée. Il est également adapté aux réseaux de grande envergure.\nDans ce protocole, chaque routeur possède la connaissance de la topologie du réseau. Il est donc possible de détecter les boucles de routage et de les éviter.\nCe protocole permet une gestion automatisée des routes dans le réseau et offre une meilleure tolérance aux erreurs et une meilleure robustesse que le protocole RIP. Cependant, il nécessite une configuration plus complexe et peut entraîner une consommation de ressources supérieure.\n\n\n4.2. Calcul du coût d’une route\nOn peut classer les différents types de liaisons en fonction de leur débit théorique :\n\n\n\nType de liaison\nDébit théorique\n\n\n\n\nModem\n56 Kbit/s\n\n\nBluetooth\n3 Mbit/s\n\n\nEthernet\n10 Mbit/s\n\n\nWifi\n54 Mbit/s\n\n\n4G\n100 Mbit/s\n\n\nFast Ethernet\n100 Mbit/s\n\n\nFFTH (fibre)\n10 Gbit/s\n\n\n5G\n20 Gbit/s\n\n\n\nLe coût d’une route est défini en fonction du débit théorique de la liaison utilisée pour relier les équipements réseau. Plus le débit est élevé, plus le coût de la route est faible.\nL’idée du protocole OSPF est de pondérer chaque trajet entre routeurs (comptant simplement pour «1» dans le protocole RIP) par une valeur de coût inversement proportionnelle au débit de transfert.\nPar exemple, si le débit \\(d\\) est exprimé en \\(bits/s\\), on peut calculer le coût de chaque liaison par la formule :\n\\[\n\\text{coût} = \\frac{10^8}{d}\n\\]\nCette formule de calcul peut être différente suivant les exercices et sera systématiquement redonnée. La valeur du débit étant au dénominateur, la valeur du coût sera inversement proportionnelle au débit.\nAvec cette convention, une route entre deux routeurs reliés en Fast Ethernet (100 Mbits/s) aura un coût de 1, une liaison wifi de 54 Mbits/s aura un coût de 1,85 environ et une liaison fibre optique de 10 Gbits/s aura un coût de 0,01.\n\n\n4.3. Lien avec les graphes\nLe protocole OSPF utilise un algorithme de routage qui s’appuie sur les graphes. En effet, le réseau peut être modélisé par un graphe étiqueté et non orienté, où chaque routeur est un sommet et chaque lien est une arête.\nLes étiquettes des arêtes sont les coûts des routes entre les routeurs.\nPour calculer le plus court chemin du routeur en question à toutes les destinations possibles, l’algorithme utilisé est celui de Dijkstra. Ainsi, chaque routeur a la vue des plus courts chemins en termes de coûts partant de lui-même.\n\n\n\n\n\n\nExemple : Un cas simple\n\n\n\nOn considère le réseau représenté par le graphe ci-dessous et la table d’état des liens commune à tous les routeurs à un instant donné.\n\n\n\n\n\nL’algorithme de Dijkstra évalue le coût de chaque route entre A et D. La route A-B-C-D a un coût de \\(1 + 1 + 2 = 4\\). La route A-E-D qui serait choisie par le protocole RIP a un coût de \\(50 + 1 = 51\\) donc l’algorithme de Dijkstra choisira la route A-B-C-D.\nSur un réseau de petite taille, la route choisie par l’algorithme Dijkstra peut être trouvée à la main comme dans l’exemple ci-dessus.\n\n\nPour les cas plus complexes, on utilise l’algorithme de Dijkstra. La vidéo ci-dessous permet d’en comprendre le fonctionnement.\n\n\n\n\n\n\n\n\nExemple : Un cas plus complexe\n\n\n\nOn considère un réseau modélisé par le graphe étiqueté ci-dessous :\n\n\n\n\n\nNous cherchons à déterminer le chemin le plus rapide entre R1 et R7. L’application graphonline permet de le faire visuellement via le menu Algorithmes / plus court chemin avec l’algorithme de Djisktra.\n\n\n\n\n\nContrairement à RIP, le chemin qu’OSPF nous indiquera sera \\(R1 \\rightarrow R2 \\rightarrow R3 \\rightarrow R5 \\rightarrow R4 \\rightarrow R6 \\rightarrow R7\\). Ce chemin n’est clairement pas le plus efficace en termes de sauts mais est le plus rapide en termes de débit car il n’exploite pratiquement que des liaisons à 10 Gb/s.\nApplication “à la main” de l’algorithme de Dijkstra sur cet exemple. On utilise ici un calcul du coût en utilisant la formule \\(c = \\frac{10^9}{d}\\) avec \\(d\\) le débit en \\(bits/s\\). Ainsi :\n\n1 Gb/s sera affecté du poids 1\n10 Gb/s sera affecté du poids 0.1\n100 Mb/s sera affecté du poids 10\n\nNous dressons un tableau. A chaque nouvelle ligne, on calcule le coût total vers les destinations possibles et on ne retient que le plus petit (en gras) que l’on marque sur une nouvelle ligne.\nPour empêcher les retours, une fois une destination choisie (en gras), on désactive tout le reste de la colonne (avec des x).\n\n\n\nR1\nR2\nR3\nR4\nR5\nR6\nR7\nChoix\n\n\n\n\n0-R1\n-\n-\n-\n-\n-\n-\nR1 (0)\n\n\nx\n0,1-R1\n1-R1\n-\n-\n-\n-\nR2 (0,1)\n\n\nx\nx\n0,2-R2\n1,1-R2\n-\n-\n-\nR3 (0,2)\n\n\nx\nx\nx\n-\n0,3-R3\n-\n-\nR5 (0,3)\n\n\nx\nx\nx\n0,4-R5\nx\n1,3-R5\n10,3-R5\nR4 (0,4)\n\n\nx\nx\nx\nx\nx\n0,5-R4\n-\nR6 (0,5)\n\n\nx\nx\nx\nx\nx\nx\n1,5-R6\nR7 (1,5)\n\n\n\nDans le tableau, on indique des couples distance-origine : ainsi 0,5-R4 dans la colonne R6 signifie que R6 est à une distance minimum de 0,5 du départ en provenance de R4. On peut ainsi reconstituer l’itinéraire optimal en partant de R7 et en remontant à l’envers en utilisant le champ origine :\n\\[R1 \\rightarrow R2 \\rightarrow R3 \\rightarrow R5 \\rightarrow R4 \\rightarrow R6 \\rightarrow R7\\]\navec un poids total minimum de 1,5.\n\n\n\n\n\n\n\n\nExercice\n\n\n\nOn reprend le graphe ci-dessus, mais la liaison R4-R5 est maintenant indisponible. Déterminer le chemin le plus rapide entre R1 et R7 en appliquant l’algorithme de Dijkstra."
  },
  {
    "objectID": "07-reseaux/routage_cours.html#conclusion",
    "href": "07-reseaux/routage_cours.html#conclusion",
    "title": "Routage - Cours",
    "section": "Conclusion",
    "text": "Conclusion\nDans ce cours, nous avons étudié les protocoles de routage, qui permettent de déterminer comment acheminer les paquets de données d’une source à une destination à travers un réseau.\nLes protocoles de routage dynamique permettent une gestion automatisée des routes dans le réseau, en échangeant des informations de routage avec les équipements voisins. Nous avons vu deux protocoles de routage dynamique courants : le protocole RIP (Routing Information Protocol), qui se base sur le nombre de sauts pour choisir la route la plus courte et le protocole OSPF (Open Shortest Path First), qui se base sur le coût de la route pour choisir la route la plus courte.\nLe protocole OSPF est plus efficace que le protocole RIP : si une route choisie par le protocole RIP est plus courte en termes de sauts, elle peut contenir un lien avec une bande passante très faible. Par contre, les calculs de plus courts chemins du protocole OSPF sont plus lourds et les formats de messages ainsi que les échanges sont plus complexes que le protocole RIP.\nCe dernier n’est plus utilisé aujourd’hui, mais il est relativement simple, ce qui permet de l’étudier en classe terminale\nDans l’avenir, il est probable que les protocoles de routage évoluent pour s’adapter aux nouvelles technologies et aux besoins croissants en matière de connectivité et de mobilité. Par exemple, les protocoles de routage pourront prendre en compte des considérations de qualité de service, de sécurité et de respect de l’environnement."
  },
  {
    "objectID": "07-reseaux/routage_exos.html",
    "href": "07-reseaux/routage_exos.html",
    "title": "Routage - Exercices",
    "section": "",
    "text": "Les exercices précédés du symbole  sont à faire sur machine, en sauvegardant le fichier si nécessaire.\nLes exercices précédés du symbole  doivent être résolus par écrit."
  },
  {
    "objectID": "07-reseaux/routage_exos.html#exercice-1",
    "href": "07-reseaux/routage_exos.html#exercice-1",
    "title": "Routage - Exercices",
    "section": " Exercice 1",
    "text": "Exercice 1\nOn considère un réseau composé de plusieurs routeurs reliés de la façon suivante :\n\n\n\n\n\n\nOn suppose que l’on a exécuté le protocole RIP sur ce réseau. Compléter la table suivante, qui indique pour chaque machine la portion de la table de routage pour la destination G.\n\n\n\nMachine\nDestination\nPasserelle\nInterface\nDistance\n\n\n\n\nA\nG\n\n\n\n\n\nB\nG\n\n\n\n\n\nC\nG\n\n\n\n\n\nD\nG\n\n\n\n\n\nE\nG\n\n\n\n\n\nF\nG\n\n\n\n\n\n\nOn suppose que le lien B-F tombe en panne. Mettre à jour la table ci-dessus."
  },
  {
    "objectID": "07-reseaux/routage_exos.html#exercice-2",
    "href": "07-reseaux/routage_exos.html#exercice-2",
    "title": "Routage - Exercices",
    "section": " Exercice 2",
    "text": "Exercice 2\nOn considère le réseau représenté ci-dessous :\n\n\n\n\n\nOn utilise le protocole OSPF et on dispose des informations suivantes sur les débits :\n\nà l’intérieur du réseau 192.168.0.0/25 : 1,544 Mb/s\nliaison Routeur_1 \\(\\rightarrow\\) Switch_1 : 100 Mb/s\nliaison Switch_1 \\(\\rightarrow\\) Routeur_2 : 2,048 Mb/s\nliaison Switch_1 \\(\\rightarrow\\) Routeur_3 : 100 Mb/s\nliaison Routeur_2 \\(\\rightarrow\\) Switch_2 : 1,544 Mb/s\nliaison Switch_3 \\(\\rightarrow\\) Routeur_3 et Routeur_4 : 10 Mb/s\nliaison Routeur_4 \\(\\rightarrow\\) Internet : 100 Mb/s\n\nLe débit de référénce est de 100 Mb/s.\n\nConstruire un graphe dont les sommets sont les routeurs et les switchs et les arêtes sont les liaisons. On indiquera sur chaque arête le coût associé.\nAppliquer l’algorithme de Dijkstra pour trouver le chemin le plus court entre la machine 192.168.0.101 et Internet."
  },
  {
    "objectID": "07-reseaux/routage_exos.html#exercice-3",
    "href": "07-reseaux/routage_exos.html#exercice-3",
    "title": "Routage - Exercices",
    "section": " Exercice 3",
    "text": "Exercice 3\n2020, sujet 0\nOn considère un réseau composé de plusieurs routeurs reliés de la façon suivante :\n\n\n\n\n\nLe protocole RIP permet de construire les tables de routage des différents routeurs, en indiquant pour chaque routeur la distance, en nombre de sauts, qui le sépare d’un autre routeur. Pour le réseau ci-dessus, on dispose des tables de routage suivantes :\n\n\n\n\n\nQuestion 1\n\nLe routeur A doit transmettre un message au routeur G, en effectuant un nombre minimal de sauts. Déterminer le trajet parcouru.\nDéterminer une table de routage possible pour le routeur G obtenu à l’aide du protocole RIP.\n\nQuestion 2\nLe routeur C tombe en panne. Reconstruire la table de routage du routeur A en suivant le protocole RIP."
  },
  {
    "objectID": "07-reseaux/routage_exos.html#exercice-4",
    "href": "07-reseaux/routage_exos.html#exercice-4",
    "title": "Routage - Exercices",
    "section": " Exercice 4",
    "text": "Exercice 4\n2021, sujet Métropole 1\nOn représente ci-dessous un réseau dans lequel R1, R2, R3, R4, R5 et R6 sont des routeurs. Le réseau local L1 est relié au routeur R1 et le réseau local L2 au routeur R6.\n\n\n\n\n\nDans cet exercice, les adresses IP sont composées de 4 octets, soit 32 bits. Elles sont notées X1.X2.X3.X4, où X1, X2, X3 et X4 sont les valeurs des 4 octets, convertis en notation décimale. La notation X1.X2.X3.X4/n signifie que les n premiers bits de poids forts de l’adresse IP représentent la partie « réseau », les bits suivants représentent la partie « hôte ». Toutes les adresses des hôtes connectés à un réseau local ont la même partie réseau et peuvent donc communiquer directement. L’adresse IP dont tous les bits de la partie « hôte » sont à 0 est appelée « adresse du réseau ».\nOn donne également des extraits de la table de routage des routeurs R1 à R5 dans le tableau suivant :\n\n\n\n\n\n1/ Un paquet part du réseau local L1 à destination du réseau local L2.\n1.a. En utilisant l’extrait de la table de routage de R1, vers quel routeur R1 envoie-t-il ce paquet : R2 ou R3 ? Justifier.\n1.b. A l’aide des extraits de tables de routage ci-dessus, nommer les routeurs traversés par ce paquet, lorsqu’il va du réseau L1 au réseau L2.\n2/ La liaison entre R1 et R2 est rompue.\n2.a. Sachant que ce réseau utilise le protocole RIP (distance en nombre de sauts), donner l’un des deux chemins possibles que pourra suivre un paquet allant de L1 vers L2.\n2.b. Dans les extraits de tables de routage ci-dessus, pour le chemin de la question 2.a, quelle(s) ligne(s) sera (seront) modifiée(s) ?\n3/ On a rétabli la liaison entre R1 et R2. Par ailleurs, pour tenir compte du débit des liaisons, on décide d’utiliser le protocole OSPF (distance liée au coût minimal des liaisons) pour effectuer le routage. Le coût des liaisons entre les routeurs est donné par le tableau suivant :\n\n\n\n\n\n\nLe coût C d’une liaison est donné ici par la formule \\(C = \\frac{10^9}{BP}\\)\n\noù \\(BP\\) est la bande passante de la connexion en bps (bits par seconde). Sachant que la bande passante de la liaison R2-R3 est de 10 Mbps, calculer le coût correspondant.\n\nDéterminer le chemin parcouru par un paquet partant du réseau L1 et arrivant au réseau L2, en utilisant le protocole OSPF.\nIndiquer pour quel(s) routeur(s) l’extrait de la table de routage sera modifié pour un paquet à destination de L2, avec la métrique OSPF."
  },
  {
    "objectID": "07-reseaux/routage_exos.html#exercice-5",
    "href": "07-reseaux/routage_exos.html#exercice-5",
    "title": "Routage - Exercices",
    "section": " Exercice 5",
    "text": "Exercice 5\n2021, sujet Métropole 2\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\nLa figure 1 ci-dessus représente le schéma d’un réseau d’entreprise. Il y figure deux réseaux locaux L1 et L2. Ces deux réseaux locaux sont interconnectés par les routeurs R2, R3, R4 et R5. Le réseau local L1 est constitué des PC portables P1 et P2 connectés à la passerelle R1 par le switch Sw1. Les serveurs S1 et S2 sont connectés à la passerelle R6 par le switch Sw2.\nLe tableau 1 suivant indique les adresses IPv4 des machines constituants le réseau de l’entreprise.\n\n\n\n\n\n\n\n\nTableau 1 : adresses IPv4 des machines\n\n\n\nRappels et notations\nRappelons qu’une adresse IP est composée de 4 octets, soit 32 bits. Elle est notée X1.X2.X3.X4, où X1, X2, X3 et X4 sont les valeurs des 4 octets. Dans le tableau 1, les valeurs des 4 octets ont été converties en notation décimale.\nLa notation X1.X2.X3.X4/n signifie que les n premiers bits de poids forts de l’adresse IP représentent la partie « réseau », les bits suivants de poids faibles représentent la partie « machine ».\nToutes les adresses des machines connectées à un réseau local ont la même partie réseau. L’adresse IP dont tous les bits de la partie « machine » sont à 0 est appelée « adresse du réseau ». L’adresse IP dont tous les bits de la partie « machine » sont à 1 est appelée « adresse de diffusion ».\n1/ 1.a. Quelles sont les adresses des réseaux locaux L1 et L2 ?\n1.b. Donner la plus petite et la plus grande adresse IP valides pouvant être attribuées à un ordinateur portable ou un serveur sur chacun des réseaux L1 et L2 sachant que l’adresse du réseau et l’adresse de diffusion ne peuvent pas être attribuées à une machine.\n1.c. Combien de machines peut-on connecter au maximum à chacun des réseaux locaux L1 et L2 ?\n2/ 2.a. Expliquer l’utilité d’avoir plusieurs chemins possibles reliant les réseaux L1 et L2.\n2.b. Quel est le chemin le plus court en nombre de sauts pour relier R1 et R6 ? Donner le nombre de sauts de ce chemin et préciser les routeurs utilisés.\n2.c. La bande passante d’une liaison Ether (quantité d’information qui peut être transmise en bits/s) est de \\(10^7\\) bits/s et celle d’une liaison FastEther est de \\(10^8\\) bits/s. Le coût d’une liaison est défini par \\(\\frac{10^8}{d}\\) , où \\(d\\) est sa bande passante en bits/s.\n\n\n\n\n\n\n\n\nTableau 2 : type des liaisons entre les routeurs\n\n\n\nQuel est le chemin reliant R1 et R6 qui a le plus petit coût ? Donner le coût de ce chemin et préciser les routeurs utilisés.\n3/ Dans l’annexe A figurent les tables de routages des routeurs R1, R2, R5 et R6 au démarrage du réseau. Indiquer sur votre copie ce qui doit figurer dans les lignes laissées vides des tables de routage des routeurs R5 et R6 pour que les échanges entre les ordinateurs des réseaux L1 et L2 se fassent en empruntant le chemin le plus court en nombre de sauts."
  },
  {
    "objectID": "07-reseaux/routage_exos.html#exercice-6",
    "href": "07-reseaux/routage_exos.html#exercice-6",
    "title": "Routage - Exercices",
    "section": " Exercice 6",
    "text": "Exercice 6\n2021, sujet Amérique du Nord\nUn constructeur automobile possède six sites de production qui échangent des documents entre eux. Les sites de production sont reliés entre eux par six routeurs A, B, C, D, E et F.\nOn donne ci-dessous les tables de routage des routeurs A à F obtenues avec le protocole RIP.\n\n\n\n\n\n\nDéterminer à l’aide de ces tables le chemin emprunté par un paquet de données envoyé du routeur A vers le routeur F.\nOn veut représenter schématiquement le réseau de routeur à partir des tables de routage. Recopier sur la copie le schéma ci-dessous :\n\n\n\n\n\n\nEn s’appuyant sur les tables de routage, tracer les liaisons entre les routeurs."
  },
  {
    "objectID": "07-reseaux/routage_exos.html#exercice-7",
    "href": "07-reseaux/routage_exos.html#exercice-7",
    "title": "Routage - Exercices",
    "section": " Exercice 7",
    "text": "Exercice 7\n2023, sujet 0a\nNous allons étudier les communications entre Bob et Alice. Ils communiquent au travers du réseau ci-dessous dont le protocole de routage est le protocole OSPF qui minimise le coût des communications :\n\n\n\n\n\n\n\n\nFigure 1 : Plan du réseau de communication entre Alice et Bob.\n\n\n\nLAN : réseau local ; WAN : réseau étendu ; R : routeur ; Sw : Switch\nUne adresse IPv4 est composée de quatre octets soit 32 bits. Une adresse de sous- réseau avec la notation /n signifie que les n premiers bits de l’adresse correspondent à la partie « réseau » et les suivants à la partie « machine ».\nL’adresse dont tous les bits de la partie « machine » sont à 0 est appelée adresse du réseau.\nL’adresse dont tous les bits de la partie « machine » sont à 1 est appelée adresse de diffusion.\nCes adresses sont réservées et ne peuvent pas être attribuées à des machines. Le choix des routes empruntées par les paquets IP est uniquement basé sur le protocole OSPF. On prendra comme débit maximal de référence 10 000 Mbit/s.\nLe coût est alors calculé de la façon suivante :\n\\[\\text{coût} = \\frac{\\text{débit maximal de référence}}{\\text{débit du réseau concerné}}\\]\n\nLa configuration IP partielle ci-dessous a été affichée sur l’un des ordinateurs :\nIP hôte : 172.16.2.3\nIP passerelle : 172.16.2.253\nIndiquer en justifiant si cette configuration appartient à l’ordinateur de Bob ou d’Alice.\nLe réseau WAN8 a un débit de 1 000 Mbit/s. Calculer le cout correspondant.\nOn donne les tables de routage des routeurs R1 à R5, dans lesquelles Pass. désigne la passerelle (qui correspond au routeur suivant) :\n\n\n\n\n\n\n\n\nFigure 2 : Tables de routage des routeurs R1 à R5.\n\n\n\nÉcrire sur votre copie la table de routage du routeur R6.\nBob envoie un message à Alice.\nÉnumérer dans l’ordre tous les routeurs par lesquels transitera ce message.\nUn routeur tombe en panne, le nouveau coût pour la route entre Bob et Alice est de 111. Déterminer le nom du routeur en panne."
  },
  {
    "objectID": "07-reseaux/routage_exos.html#exercice-8",
    "href": "07-reseaux/routage_exos.html#exercice-8",
    "title": "Routage - Exercices",
    "section": " Exercice 8",
    "text": "Exercice 8\n2023, sujet 0b\nOn considère le réseau ci-dessous dans lequel :\n\nles nœuds A, B, C, D, E, F et G sont des routeurs,\nle type de liaison est précisé entre chaque routeur.\n\n\n\n\n\n\nOn rappelle que la bande passante des liaisons FTTH (fibre optique : Fiber To The Home) est de 10 Gbit/s et celle des liaisons FastEthernet de 100 Mbit/s.\nOn s’intéresse au protocole de routage OSPF. Le protocole OSPF est un protocole de routage qui cherche à minimiser la somme des coûts des liaisons entre les routeurs empruntés par un paquet. Le coût \\(\\mathcal{C}\\) d’une liaison est donné par :\n\\[\\mathcal{C}=\\frac{10^8}{d}\\]\noù d est la bande passante en bit/s de la liaison.\n\nCalculer le coût d’une liaison de communication par la technologie FastEthernet.\nLe fichier collections_timbres.csv contenu dans une machine reliée au routeur A doit être envoyé à une machine reliée au routeur G. Déterminer la route permettant de relier le routeur A au routeur G et minimisant la somme des coûts selon le protocole OSPF."
  },
  {
    "objectID": "08-graphes/graphes_cours.html",
    "href": "08-graphes/graphes_cours.html",
    "title": "Graphes (Cours)",
    "section": "",
    "text": "Définition\n\n\n\nUn graphe non orienté est constitué :\n\nd’un ensemble fini de sommets (représentés par des points) ;\nd’un ensemble d’arêtes (représentées par des traits) qui relient des sommets entre eux.\n\n\n\nLa figure ci-dessous représente un graphe dont les sommets sont numérotés de 0 à 6.\n\n\n\nFigure 1: Graphe non orienté\n\n\n\n\n\n\n\n\nDéfinition\n\n\n\nUn graphe orienté est constitué :\n\nd’un ensemble fini de sommets (représentés par des points) ;\nd’un ensemble d’arcs (représentés par des flèches) qui relient des sommets entre eux.\n\n\n\nLa figure ci-dessous représente un graphe orienté dont les sommets sont numérotés de 0 à 6.\n\n\n\nFigure 2: Graphe orienté\n\n\n\nUn peu de vocabulaire :\n\ndeux sommets reliés par une arête (ou un arc) sont dits adjacents, ou voisins ;\nun sommet est dit isolé s’il n’est relié à aucun autre sommet ;\nl’ordre d’un graphe est le nombre de ses sommets ;\nle degré d’un sommet \\(S\\), noté \\(deg(S)\\), est le nombre d’arêtes (ou d’arcs) qui le relient à d’autres sommets ;\n\n\n\n\nLa structure d’arbre déjà rencontrée dans le cours est un cas particulier de graphe non orienté.\n\n\n\n\n\n\nDéfinition\n\n\n\nUn arbre est un graphe non orienté qui satisfait les conditions suivantes :\n\nil est connexe ;\nil n’a pas de cycle.\n\n\n\nExplications : connexe signifie que tous les sommets sont reliés entre eux par un chemin (il n’y a pas de points isolés). pas de cycle signifie que l’on ne peut pas revenir au même sommet en passant par le même chemin.\nEn particulier le graphe ci-dessus (Figure 1) n’est pas un arbre, car il n’est pas connexe (le sommet 6 n’est pas relié au sommet 1) et il contient un cycle (le chemin 1-2-4-1).\n\n\n\nVoici quelques situations pouvant être modélisées par un graphe :\n\nun réseau routier ;\nun réseau de télécommunications ;\nun réseau social ;\nun réseau électrique ;"
  },
  {
    "objectID": "08-graphes/graphes_cours.html#notion-de-graphe",
    "href": "08-graphes/graphes_cours.html#notion-de-graphe",
    "title": "Graphes (Cours)",
    "section": "",
    "text": "Définition\n\n\n\nUn graphe non orienté est constitué :\n\nd’un ensemble fini de sommets (représentés par des points) ;\nd’un ensemble d’arêtes (représentées par des traits) qui relient des sommets entre eux.\n\n\n\nLa figure ci-dessous représente un graphe dont les sommets sont numérotés de 0 à 6.\n\n\n\nFigure 1: Graphe non orienté\n\n\n\n\n\n\n\n\nDéfinition\n\n\n\nUn graphe orienté est constitué :\n\nd’un ensemble fini de sommets (représentés par des points) ;\nd’un ensemble d’arcs (représentés par des flèches) qui relient des sommets entre eux.\n\n\n\nLa figure ci-dessous représente un graphe orienté dont les sommets sont numérotés de 0 à 6.\n\n\n\nFigure 2: Graphe orienté\n\n\n\nUn peu de vocabulaire :\n\ndeux sommets reliés par une arête (ou un arc) sont dits adjacents, ou voisins ;\nun sommet est dit isolé s’il n’est relié à aucun autre sommet ;\nl’ordre d’un graphe est le nombre de ses sommets ;\nle degré d’un sommet \\(S\\), noté \\(deg(S)\\), est le nombre d’arêtes (ou d’arcs) qui le relient à d’autres sommets ;\n\n\n\n\nLa structure d’arbre déjà rencontrée dans le cours est un cas particulier de graphe non orienté.\n\n\n\n\n\n\nDéfinition\n\n\n\nUn arbre est un graphe non orienté qui satisfait les conditions suivantes :\n\nil est connexe ;\nil n’a pas de cycle.\n\n\n\nExplications : connexe signifie que tous les sommets sont reliés entre eux par un chemin (il n’y a pas de points isolés). pas de cycle signifie que l’on ne peut pas revenir au même sommet en passant par le même chemin.\nEn particulier le graphe ci-dessus (Figure 1) n’est pas un arbre, car il n’est pas connexe (le sommet 6 n’est pas relié au sommet 1) et il contient un cycle (le chemin 1-2-4-1).\n\n\n\nVoici quelques situations pouvant être modélisées par un graphe :\n\nun réseau routier ;\nun réseau de télécommunications ;\nun réseau social ;\nun réseau électrique ;"
  },
  {
    "objectID": "08-graphes/graphes_cours.html#implémentations-dun-graphe",
    "href": "08-graphes/graphes_cours.html#implémentations-dun-graphe",
    "title": "Graphes (Cours)",
    "section": "2. Implémentations d’un graphe",
    "text": "2. Implémentations d’un graphe\nL’objectif de cette section est de définir une structure de données en Python permettant de représenter un graphe.\nLes opérations suivantes doivent être possibles (cf. FORTIER (2022)):\n\ncréer un graphe vide ;\najouter un sommet ;\najouter une arête (ou un arc) ;\nsupprimer un sommet ;\nsupprimer une arête (ou un arc) ;\nvérifier si deux sommets sont adjacents ;\nconnaître la liste des sommets adjacents à un sommet donné.\n\nNous étudions deux implémentations : par matrice d’adjacence et par liste d’adjacence.\n\n2.1. Matrice d’adjacence\nRappel : une matrice est un tableau à deux dimensions, où chaque élément est identifié par un couple de coordonnées (ligne, colonne). En Python, on peut représenter une matrice par une liste de listes.\n\n\n\n\n\n\nDéfinition\n\n\n\nLa matrice d’adjacence d’un graphe \\(G\\) (orienté ou non) est une matrice carrée \\(A\\) de taille \\(n\\) telle que :\n\n\\(A_{i,j} = 1\\) si les sommets \\(i\\) et \\(j\\) sont adjacents ;\n\\(A_{i,j} = 0\\) si les sommets \\(i\\) et \\(j\\) ne sont pas adjacents.\n\n\n\nExemple : la matrice d’adjacence du graphe non orienté de la figure ci-dessus (Figure 1) est la suivante :\n\n\n\n\n\nGraphe Fig.1\n\n\n\n\\[\n\\begin{pmatrix}\n0 & 0 & 0 & 0 & 0 & 0 & 1 \\\\\n0 & 0 & 1 & 1 & 1 & 0 & 0 \\\\\n0 & 1 & 0 & 0 & 1 & 1 & 0\\\\\n0 & 1 & 0 & 0 & 1 & 0 & 0\\\\\n0 & 1 & 1 & 1 & 0 & 0 & 0\\\\\n0 & 0 & 1 & 0 & 0 & 0 & 0\\\\\n1 & 0 & 0 & 0 & 0 & 0 & 0\n\\end{pmatrix}\n\\]\n\n\n\nRemarques : dans le cas d’un graphe non orienté, la matrice d’adjacence est symétrique par rapport à la diagonale principale. Dans le cas d’un graphe orienté, la matrice d’adjacence n’est pas forcément symétrique.\n\n\n\n\n\n\nTP Python\n\n\n\nTP Python : implémentation des graphes par matrice d’adjacence\n\n\n\n\n\n2.2. Liste d’adjacence\n\n\n\n\n\n\nDéfinition : liste d’adjacence\n\n\n\nLa liste d’adjacence d’un graphe \\(G\\) (orienté ou non) dont les sommets sont les entiers compris entre 0 et \\(n-1\\) est une liste \\(L\\) de taille \\(n\\) telle que :\n\n\\(L[i]\\) est la liste des sommets adjacents au sommet \\(i\\).\n\n\n\nExemple : la liste d’adjacence du graphe non orienté de la figure ci-dessus (Figure 1) est la suivante :\n\n\n\n\n\nGraphe Fig.1\n\n\n\n\\[\n\\begin{array}{|c|c|}\n\\hline\n0 & [6] \\\\\n\\hline\n1 & [2,3,4] \\\\\n\\hline\n2 & [1,4,5] \\\\\n\\hline\n3 & [1,4] \\\\\n\\hline\n4 & [1,2,3] \\\\\n\\hline\n5 & [2] \\\\\n\\hline\n6 & [0] \\\\\n\\hline\n\\end{array}\n\\]\n\n\n\nDans le cas d’un graphe comportant peu d’arêtes, la liste d’adjacence occupe moins de mémoire que la matrice d’adjacence. Mais certaines opérations, comme la vérification de l’adjacence de deux sommets ou la suppression d’une arête, sont plus coûteuses en temps d’exécution.\n\n\n\n\n\n\nTP Python\n\n\n\nDans le TP ci-dessous, vous devez implémenter la structure de graphe par liste d’adjacence. Vous devez également implémenter les fonctions permettant de passer d’une représentation à l’autre.\nTP Python : implémentation des graphes par liste d’adjacence"
  },
  {
    "objectID": "08-graphes/graphes_exercices.html",
    "href": "08-graphes/graphes_exercices.html",
    "title": "Exercices sur les graphes",
    "section": "",
    "text": "Les exercices précédés du symbole  sont à faire sur machine, en sauvegardant le fichier si nécessaire.\nLes exercices précédés du symbole  doivent être résolus par écrit."
  },
  {
    "objectID": "08-graphes/graphes_exercices.html#exercice-1",
    "href": "08-graphes/graphes_exercices.html#exercice-1",
    "title": "Exercices sur les graphes",
    "section": " Exercice 1",
    "text": "Exercice 1\nOn dit qu’un graphe est simple s’il n’y a pas de boucle ni de double arête. Un graphe simple est dit complet s’il est non orienté et que chaque paire de sommets est reliée par une arête.\nDessiner un graphe complet d’ordre 3, puis un graphe complet d’ordre 4."
  },
  {
    "objectID": "08-graphes/graphes_exercices.html#exercice-2",
    "href": "08-graphes/graphes_exercices.html#exercice-2",
    "title": "Exercices sur les graphes",
    "section": " Exercice 2",
    "text": "Exercice 2\nGraphe d’un réseau électrique\nUn de vos amis travaille pour un distributeur d’électricité.\nIl doit proposer à son supérieur une représentation du réseau reliant différentes villes. Comme il n’y arrive pas trop, il voudrait que vous la lui fassiez.\nPour simplifier le problème, il a déjà renommé les villes en A, B, C, D, E et F. De plus, il vous donne les informations suivantes :\n\nla ville B est reliée par un réseau électrique aux villes A, C et D,\nla ville A est reliée par un réseau électrique aux villes B, E et F,\nla ville C est reliée par un réseau électrique aux villes B, D, E et F,\nla ville D est reliée par un réseau électrique aux villes B, C et F,\nla ville E est reliée par un réseau électrique aux villes A, C et F,\nla ville F est relié par un réseau électrique aux villes A, C, D et E.\n\nProposer un graphe qui modélise la situation.\nCe graphe est-il complet ? Pourquoi ?\nDonner sa matrice d’adjacence."
  },
  {
    "objectID": "08-graphes/graphes_exercices.html#exercice-3",
    "href": "08-graphes/graphes_exercices.html#exercice-3",
    "title": "Exercices sur les graphes",
    "section": " Exercice 3",
    "text": "Exercice 3\nVoici un ensemble de relations :\n\nA est ami avec tout le monde sauf G,\nB est ami avec A, D et H,\nC est ami avec A, F, G et H,\nD est ami avec A, B et H,\nE est ami avec A et H,\nF est ami avec A et C,\nG est ami avec C et H,\nH est ami avec A, B, C, D, E et G.\n\n\nReprésenter ce graphe et vérifier qu’il est non orienté.\nImplémenter ce graphe sous la forme d’une liste d’adjacence dans laquelle chaque clé représente le nœud étudié.\nÉcrire la matrice d’adjacence et vérifier qu’elle est symétrique (on utilisera l’ordre alphabétique pour indexer les nœuds). 4 Implémenter la matrice en python sous la forme d’une liste de liste."
  },
  {
    "objectID": "08-graphes/graphes_exercices.html#exercice-4",
    "href": "08-graphes/graphes_exercices.html#exercice-4",
    "title": "Exercices sur les graphes",
    "section": " Exercice 4",
    "text": "Exercice 4\nVoici un graphe représentant les distances dans le réseau sud-est.\n\n\n\nRéseau sud-Est\n\n\n\nImplémenter ce graphe sous la forme d’un dictionnaire de liste dans lequel chaque clé représente le nœud étudié et les sommets adjacents sont représentés sous la forme d’une liste de dictionnaires clé(sommet adjacent): valeur(distance).\nÉcrire la matrice d’adjacence et vérifier qu’elle est symétrique(on utilisera l’ordre alphabétique pour indexer les nœuds).\nProposer un algorithme qui renvoie tous les chemins possibles pour aller de Nice à Lyon sans jamais passer deux fois par la même ville. On utilisera trois paramètres d’entrée: le graphe implémenté sous la forme d’un dictionnaire d’adjacence comme celui de la question 2 et les deux villes de départ et d’arrivée."
  },
  {
    "objectID": "08-graphes/index_graphes.html",
    "href": "08-graphes/index_graphes.html",
    "title": "Programme",
    "section": "",
    "text": "Contenus\nCapacités attendues\nCommentaires\n\n\n\n\nGraphes : structures relationnelles. Sommets, arcs, arêtes, graphes orientés ou non orientés.\nModéliser des situations sous forme de graphes. Écrire les implémentations correspondantes d’un graphe : matrice d’adjacence, liste de successeurs/de prédécesseurs. Passer d’une représentation à une autre.\nOn s’appuie sur des exemples comme le réseau routier, le réseau électrique, Internet, les réseaux sociaux. Le choix de la représentation dépend du traitement qu’on veut mettre en place : on fait le lien avec la rubrique « algorithmique »."
  },
  {
    "objectID": "08-graphes/index_graphes.html#programme",
    "href": "08-graphes/index_graphes.html#programme",
    "title": "Programme",
    "section": "",
    "text": "Contenus\nCapacités attendues\nCommentaires\n\n\n\n\nGraphes : structures relationnelles. Sommets, arcs, arêtes, graphes orientés ou non orientés.\nModéliser des situations sous forme de graphes. Écrire les implémentations correspondantes d’un graphe : matrice d’adjacence, liste de successeurs/de prédécesseurs. Passer d’une représentation à une autre.\nOn s’appuie sur des exemples comme le réseau routier, le réseau électrique, Internet, les réseaux sociaux. Le choix de la représentation dépend du traitement qu’on veut mettre en place : on fait le lien avec la rubrique « algorithmique »."
  },
  {
    "objectID": "08-graphes/tp_graphe_liste.html",
    "href": "08-graphes/tp_graphe_liste.html",
    "title": "TP - Implémentation des graphes par liste d’adjacence",
    "section": "",
    "text": "Cliquer ici pour accéder à la version notebook de ce TP sur Capytale\nOn considère un graphe \\(G\\) dont les sommets sont les entiers de \\(0\\) à \\(n-1\\) et les arêtes sont les couples d’entiers \\((i,j)\\) avec \\(0\\leq i,j\\leq n-1\\).\nL’objectif de ce TP est d’implémenter les graphes en python par liste d’adjacence.\nOn considère ici que les graphes sont non orientés."
  },
  {
    "objectID": "08-graphes/tp_graphe_liste.html#implémentation-objet",
    "href": "08-graphes/tp_graphe_liste.html#implémentation-objet",
    "title": "TP - Implémentation des graphes par liste d’adjacence",
    "section": "1. Implémentation objet",
    "text": "1. Implémentation objet\nCréer une classe Graph qui permet de représenter un graphe par liste d’adjacence.\nLa classe Graph doit contenir les attributs suivants :\n\norder : le nombre de sommets du graphe\nliste : une liste de listes d’entiers représentant la liste d’adjacence du graphe\n\nLa classe Graph doit contenir les méthodes suivantes :\n\n__init__ : initialise un graphe vide de taille order\nadd_edge : ajoute l’arête \\((i,j)\\) au graphe\nremove_edge : supprime l’arête \\((i,j)\\) du graphe\nadd_vertex : ajoute un sommet au graphe\nremove_vertex : supprime le sommet i du graphe\nis_adjacent : retourne True si les sommets i et j sont adjacents, False sinon\nneighbors : retourne la liste des voisins du sommet i\ndegree : retourne le degré du sommet i\n__str__ : retourne une chaîne de caractères représentant le graphe (afficher sur chaque ligne le numéro du sommet suivi de la liste de ses voisins)\ndraw : dessine le graphe (s’inspirer du TP précédent !)\n\n\nimport networkx as nx\n\nclass Graph:\n\n    pass\n\n\n# Exemple d'utilisation\n\ng = Graph(5)\ng.add_edge(0, 3)\ng.add_edge(1, 2)\ng.add_edge(1, 4)\ng.add_edge(2, 3)\ng.add_edge(2, 4)\ng.add_edge(3, 4)\nprint(g)\ng.draw()"
  },
  {
    "objectID": "08-graphes/tp_graphe_liste.html#passage-dune-représentation-à-lautre",
    "href": "08-graphes/tp_graphe_liste.html#passage-dune-représentation-à-lautre",
    "title": "TP - Implémentation des graphes par liste d’adjacence",
    "section": "Passage d’une représentation à l’autre",
    "text": "Passage d’une représentation à l’autre\nOn considère un graphe \\(G\\) représenté par liste d’adjacence. On souhaite passer à une représentation par matrice d’adjacence.\nCompléter la fonction list_to_matrix qui prend en paramètre une liste d’adjacence d’un graphe G et retourne la matrice d’adjacence représentant le graphe.\n\ndef list_to_matrix(liste):\n    pass\n\n\n# Test de la fonction list_to_matrix\nmatrice = list_to_matrix(g.liste)\nassert matrice == [[0, 0, 0, 1, 0], [0, 0, 1, 0, 1], [0, 1, 0, 1, 1], [1, 0, 1, 0, 1], [0, 1, 1, 1, 0]]\nprint(\"Test réussi !\")\n\nOpération inverse : compléter la fonction matrix_to_list qui prend en paramètre une matrice d’adjacence d’un graphe G et retourne la liste d’adjacence représentant le graphe.\n\ndef matrix_to_list(matrice):\n    pass\n\n\n# Test de la fonction matrix_to_list\nliste = matrix_to_list(matrice)\nassert liste == [[3], [2, 4], [1, 3, 4], [0, 2, 4], [1, 2, 3]]\nprint(\"Test réussi !\")"
  },
  {
    "objectID": "08-graphes/tp_graphe_liste_capytale.html",
    "href": "08-graphes/tp_graphe_liste_capytale.html",
    "title": "TP - Implémentation des graphes par liste d’adjacence",
    "section": "",
    "text": "On considère un graphe \\(G\\) dont les sommets sont les entiers de \\(0\\) à \\(n-1\\) et les arêtes sont les couples d’entiers \\((i,j)\\) avec \\(0\\leq i,j\\leq n-1\\).\nL’objectif de ce TP est d’implémenter les graphes en python par liste d’adjacence.\nOn considère ici que les graphes sont non orientés."
  },
  {
    "objectID": "08-graphes/tp_graphe_liste_capytale.html#implémentation-objet",
    "href": "08-graphes/tp_graphe_liste_capytale.html#implémentation-objet",
    "title": "TP - Implémentation des graphes par liste d’adjacence",
    "section": "1. Implémentation objet",
    "text": "1. Implémentation objet\nCréer une classe Graph qui permet de représenter un graphe par liste d’adjacence.\nLa classe Graph doit contenir les attributs suivants :\n\norder : le nombre de sommets du graphe\nliste : une liste de listes d’entiers représentant la liste d’adjacence du graphe\n\nLa classe Graph doit contenir les méthodes suivantes :\n\n__init__ : initialise un graphe vide de taille order\nadd_edge : ajoute l’arête \\((i,j)\\) au graphe\nremove_edge : supprime l’arête \\((i,j)\\) du graphe\nadd_vertex : ajoute un sommet au graphe\nremove_vertex : supprime le sommet i du graphe\nis_adjacent : retourne True si les sommets i et j sont adjacents, False sinon\nneighbors : retourne la liste des voisins du sommet i\ndegree : retourne le degré du sommet i\n__str__ : retourne une chaîne de caractères représentant le graphe (afficher sur chaque ligne le numéro du sommet suivi de la liste de ses voisins)\ndraw : dessine le graphe (s’inspirer du TP précédent !)\n\n\nimport networkx as nx\n\nclass Graph:\n\n    pass\n\n\n# Exemple d'utilisation\n\ng = Graph(5)\ng.add_edge(0, 3)\ng.add_edge(1, 2)\ng.add_edge(1, 4)\ng.add_edge(2, 3)\ng.add_edge(2, 4)\ng.add_edge(3, 4)\nprint(g)\ng.draw()"
  },
  {
    "objectID": "08-graphes/tp_graphe_liste_capytale.html#passage-dune-représentation-à-lautre",
    "href": "08-graphes/tp_graphe_liste_capytale.html#passage-dune-représentation-à-lautre",
    "title": "TP - Implémentation des graphes par liste d’adjacence",
    "section": "Passage d’une représentation à l’autre",
    "text": "Passage d’une représentation à l’autre\nOn considère un graphe \\(G\\) représenté par liste d’adjacence. On souhaite passer à une représentation par matrice d’adjacence.\nCompléter la fonction list_to_matrix qui prend en paramètre une liste d’adjacence d’un graphe G et retourne la matrice d’adjacence représentant le graphe.\n\ndef list_to_matrix(liste):\n    pass\n\n\n# Test de la fonction list_to_matrix\nmatrice = list_to_matrix(g.liste)\nassert matrice == [[0, 0, 0, 1, 0], [0, 0, 1, 0, 1], [0, 1, 0, 1, 1], [1, 0, 1, 0, 1], [0, 1, 1, 1, 0]]\nprint(\"Test réussi !\")\n\nOpération inverse : compléter la fonction matrix_to_list qui prend en paramètre une matrice d’adjacence d’un graphe G et retourne la liste d’adjacence représentant le graphe.\n\ndef matrix_to_list(matrice):\n    pass\n\n\n# Test de la fonction matrix_to_list\nliste = matrix_to_list(matrice)\nassert liste == [[3], [2, 4], [1, 3, 4], [0, 2, 4], [1, 2, 3]]\nprint(\"Test réussi !\")"
  },
  {
    "objectID": "08-graphes/tp_graphe_liste_CORR.html",
    "href": "08-graphes/tp_graphe_liste_CORR.html",
    "title": "TP - Implémentation des graphes par liste d’adjacence",
    "section": "",
    "text": "On considère un graphe \\(G\\) dont les sommets sont les entiers de \\(0\\) à \\(n-1\\) et les arêtes sont les couples d’entiers \\((i,j)\\) avec \\(0\\leq i,j\\leq n-1\\).\nL’objectif de ce TP est d’implémenter les graphes en python par liste d’adjacence.\nOn considère ici que les graphes sont non orientés."
  },
  {
    "objectID": "08-graphes/tp_graphe_liste_CORR.html#implémentation-objet",
    "href": "08-graphes/tp_graphe_liste_CORR.html#implémentation-objet",
    "title": "TP - Implémentation des graphes par liste d’adjacence",
    "section": "1. Implémentation objet",
    "text": "1. Implémentation objet\nCréer une classe Graph qui permet de représenter un graphe par liste d’adjacence.\nLa classe Graph doit contenir les attributs suivants :\n\norder : le nombre de sommets du graphe\nliste : une liste de listes d’entiers représentant la liste d’adjacence du graphe\n\nLa classe Graph doit contenir les méthodes suivantes :\n\n__init__ : initialise un graphe vide de taille order\nadd_edge : ajoute l’arête \\((i,j)\\) au graphe\nremove_edge : supprime l’arête \\((i,j)\\) du graphe\nadd_vertex : ajoute un sommet au graphe\nremove_vertex : supprime le sommet i du graphe\nis_adjacent : retourne True si les sommets i et j sont adjacents, False sinon\nneighbors : retourne la liste des voisins du sommet i\ndegree : retourne le degré du sommet i\n__str__ : retourne une chaîne de caractères représentant le graphe (afficher sur chaque ligne le numéro du sommet suivi de la liste de ses voisins)\ndraw : dessine le graphe (s’inspirer du TP précédent !)\n\n\nimport networkx as nx\n\nclass Graph:\n\n    def __init__(self, n):\n        self.order = n\n        self.liste = [[] for i in range(n)]\n\n    def add_edge(self, u, v):\n        self.liste[u].append(v)\n        self.liste[v].append(u)\n    \n    def remove_edge(self, u, v):\n        self.liste[u].remove(v)\n        self.liste[v].remove(u)\n    \n    def add_vertex(self):\n        self.liste.append([])\n        self.order += 1\n    \n    def remove_vertex(self, u):\n        for v in self.liste[u]:\n            self.liste[v].remove(u)\n        self.liste.pop(u)\n        self.order -= 1\n    \n    def is_adjacent(self, u, v):\n        return v in self.liste[u]\n    \n    def neighbors(self, u):\n        return self.liste[u]\n    \n    def degree(self, u):\n        return len(self.liste[u])\n    \n    def __str__(self):\n        rep = \"\"\n        for i in range(self.order):\n            rep += str(i) + \" : \" + str(self.liste[i]) + \"\\n\"\n        return rep\n    \n    def draw(self):\n        G = nx.Graph()\n        G.add_nodes_from(range(self.order))\n        for i in range(self.order):\n            for j in self.liste[i]:\n                G.add_edge(i, j)\n        nx.draw(G, with_labels=True, node_color='white', font_size=18, edgecolors='black', node_size=500)\n\n\n# Exemple d'utilisation\n\ng = Graph(5)\ng.add_edge(0, 3)\ng.add_edge(1, 2)\ng.add_edge(1, 4)\ng.add_edge(2, 3)\ng.add_edge(2, 4)\ng.add_edge(3, 4)\nprint(g)\ng.draw()\n\n0 : [3]\n1 : [2, 4]\n2 : [1, 3, 4]\n3 : [0, 2, 4]\n4 : [1, 2, 3]"
  },
  {
    "objectID": "08-graphes/tp_graphe_liste_CORR.html#passage-dune-représentation-à-lautre",
    "href": "08-graphes/tp_graphe_liste_CORR.html#passage-dune-représentation-à-lautre",
    "title": "TP - Implémentation des graphes par liste d’adjacence",
    "section": "Passage d’une représentation à l’autre",
    "text": "Passage d’une représentation à l’autre\nOn considère un graphe \\(G\\) représenté par liste d’adjacence. On souhaite passer à une représentation par matrice d’adjacence.\nCompléter la fonction list_to_matrix qui prend en paramètre une liste d’adjacence d’un graphe G et retourne la matrice d’adjacence représentant le graphe.\n\ndef list_to_matrix(liste):\n    n = len(liste)\n    mat = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        for j in liste[i]:\n            mat[i][j] = 1\n            mat[j][i] = 1\n    return mat\n\n\n# Test de la fonction list_to_matrix\nmatrice = list_to_matrix(g.liste)\nassert matrice == [[0, 0, 0, 1, 0], [0, 0, 1, 0, 1], [0, 1, 0, 1, 1], [1, 0, 1, 0, 1], [0, 1, 1, 1, 0]]\nprint(\"Test réussi !\")\n\nTest réussi !\n\n\nOpération inverse : compléter la fonction matrix_to_list qui prend en paramètre une matrice d’adjacence d’un graphe G et retourne la liste d’adjacence représentant le graphe.\n\ndef matrix_to_list(matrice):\n    n = len(matrice)\n    liste = [[] for i in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if matrice[i][j] == 1:\n                liste[i].append(j)\n    return liste\n\n\n# Test de la fonction matrix_to_list\nliste = matrix_to_list(matrice)\nassert liste == [[3], [2, 4], [1, 3, 4], [0, 2, 4], [1, 2, 3]]\nprint(\"Test réussi !\")\n\nTest réussi !"
  },
  {
    "objectID": "08-graphes/tp_graphe_matrice.html",
    "href": "08-graphes/tp_graphe_matrice.html",
    "title": "TP - Implémentation des graphes par matrice d’adjacence",
    "section": "",
    "text": "Cliquer ici pour accéder à la version notebook de ce TP dans Capytale\nOn considère un graphe \\(G\\) dont les sommets sont les entiers de \\(0\\) à \\(n-1\\) et les arêtes sont les couples d’entiers \\((i,j)\\) avec \\(0\\leq i,j\\leq n-1\\).\nL’objectif de ce TP est d’implémenter les graphes en python par matrice d’adjacence.\nOn considère ici que les graphes sont non orientés."
  },
  {
    "objectID": "08-graphes/tp_graphe_matrice.html#implémentation-simple",
    "href": "08-graphes/tp_graphe_matrice.html#implémentation-simple",
    "title": "TP - Implémentation des graphes par matrice d’adjacence",
    "section": "Implémentation simple",
    "text": "Implémentation simple\nQuestion 1 : Fonction permettant de créer un graphe comportant \\(n\\) sommets et pas d’arêtes.\n\ndef make_graph(n: int) -&gt; list:\n    \"\"\"Crée la matrice d'adjacence d'un graphe de n sommets sans arêtes\"\"\"\n    g = []\n    # Compléter ci dessous\n    \n    return g\n\n\n# Test de la fonction make_graph\n\ng = make_graph(5)\nprint(g)\n\nQuestion 2 : Fonction permettant d’ajouter une arête entre les sommets \\(i\\) et \\(j\\).\n\ndef add_edge(g: list, i: int, j: int) -&gt; None:\n    \"\"\"Ajoute l'arête (i,j) au graphe g\"\"\"\n    pass\n\nQuestion 3 - Application : en utilisant les deux fonctions précédentes, créer une variable g représentant le graphe suivant :\n\n\n\ngraphe 1\n\n\n\n# Entrer votre code ici\n\n\n# Vérification\nassert g == [[1, 1, 1, 0, 0], [1, 0, 1, 1, 0], [1, 1, 0, 1, 1], [0, 1, 1, 0, 1], [0, 0, 1, 1, 0]]\nprint(\"Test réussi !\")\n\nQuestion 4 : Compléter la fonction remove_edge permettant de supprimer une arête entre les sommets \\(i\\) et \\(j\\).\n\ndef remove_edge(g: list, i: int, j: int) -&gt; None:\n    \"\"\"Supprime l'arête (i,j) du graphe g\"\"\"\n    pass\n\n\n# Test de la fonction remove_edge\nfrom copy import deepcopy\n\nh = deepcopy(g)\nremove_edge(h, 0, 1)\nassert h == [[1, 0, 1, 0, 0], [0, 0, 1, 1, 0], [1, 1, 0, 1, 1], [0, 1, 1, 0, 1], [0, 0, 1, 1, 0]]\nprint(\"Test réussi !\")\n\nQuestion 5 : Compléter les fonctions add_vertex et remove_vertex permettant d’ajouter un sommet et de supprimer un sommet dans un graphe. On rappelle que les sommets sont des entiers successifs. Par exemple, si on supprime le sommet \\(2\\), les sommets \\(3\\) et \\(4\\) deviennent les sommets \\(2\\) et \\(3\\). Par ailleurs, le sommet ajouté par la fonction add_vertex doit être le plus grand sommet du graphe.\n\ndef add_vertex(g: list) -&gt; None:\n    \"\"\"Ajoute un sommet à un graphe g\"\"\"\n    pass\n\ndef remove_vertex(g: list, i: int) -&gt; None:\n    \"\"\"Supprime le sommet i du graphe g\"\"\"\n    pass\n\n\n# Test de la fonction add_vertex\nh = deepcopy(g)\nadd_vertex(h)\nassert h == [[1, 1, 1, 0, 0, 0], [1, 0, 1, 1, 0, 0], [1, 1, 0, 1, 1, 0], [0, 1, 1, 0, 1, 0], [0, 0, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0]]\nprint(\"Test réussi !\")\n\n\n# Test de la fonction remove_vertex\nremove_vertex(h, 5)\nassert h == [[1, 1, 1, 0, 0], [1, 0, 1, 1, 0], [1, 1, 0, 1, 1], [0, 1, 1, 0, 1], [0, 0, 1, 1, 0]]\nprint(\"Test réussi !\")\n\nQuestion 6 : Compléter la fonction est_adjacent qui prend en paramètre un graphe g et deux sommets i et j et qui renvoie True si les sommets sont adjacents et False sinon.\n\ndef is_adjacent(g: list, i: int, j: int) -&gt; bool:\n    \"\"\"Renvoie True si les sommets i et j sont adjacents, False sinon\"\"\"\n    pass\n\n\n# Test de la fonction is_adjacent\nassert is_adjacent(g, 0, 1) == True\nassert is_adjacent(g, 0, 4) == False\nprint(\"Test réussi !\")\n\nQuestion 7 : Compléter la fonction neighbors qui prend en paramètre un graphe g et un sommet i et qui renvoie la liste des sommets adjacents au sommet i, puis la fonction degree qui prend en paramètre un graphe g et un sommet i et qui renvoie le degré du sommet i.\n\ndef neighbors(g: list, i: int) -&gt; list:\n    \"\"\"Renvoie la liste des sommets autres que i \n       adjacents au sommet i\"\"\"\n    pass\n\ndef degree(g: list, i: int) -&gt; int:\n    \"\"\"Renvoie le degré du sommet i\"\"\"\n    pass\n\n\n# Test de la fonction neighbors\nassert neighbors(g, 0) == [1, 2]\nassert neighbors(g, 1) == [0, 2, 3]\n\n# Test de la fonction degree\nassert degree(g, 0) == 2\nassert degree(g, 1) == 3\nprint(\"Test réussi !\")"
  },
  {
    "objectID": "08-graphes/tp_graphe_matrice.html#implémentation-objet",
    "href": "08-graphes/tp_graphe_matrice.html#implémentation-objet",
    "title": "TP - Implémentation des graphes par matrice d’adjacence",
    "section": "Implémentation objet",
    "text": "Implémentation objet\nQuestion 8 : Créer une classe Graph permettant de représenter un graphe sous la forme d’une matrice d’adjacence, en reformulant les fonctions définies dans la partie précédente. Cette classe doit contenir les attributs suivants :\n\norder : nombre de sommets du graphe\nmatrix : matrice d’adjacence du graphe\n\nCette classe doit contenir les méthodes suivantes :\n\n__init__ : constructeur de la classe\nadd_edge : ajoute une arête entre les sommets i et j\nremove_edge : supprime une arête entre les sommets i et j\nadd_vertex : ajoute un sommet au graphe\nremove_vertex : supprime un sommet du graphe\nis_adjacent : renvoie True si les sommets i et j sont adjacents et False sinon\nneighbors : renvoie la liste des sommets adjacents au sommet i\ndegree : renvoie le degré du sommet i\n__str__ : renvoie une chaîne de caractères représentant le graphe en affichant les lignes de la matrice d’adjacence l’une en dessous de l’autre.\n\n\nclass Graph:\n\n    pass\n\nQuestion 9 - Application : en utilisant la classe Graph, créer une variable g représentant le graphe suivant :\n\n\n\ngraphe 2\n\n\nDéterminer la liste des voisins du sommet \\(2\\).\n\n# Entrer votre code ici\n\nBonus : Implémenter une fonction draw_graph permettant de dessiner un graphe à partir de sa matrice d’adjacence.\nPour cela, on utilisera le module networkx qui est spécialisé dans l’analyse des graphes. Il s’agit donc de définir un graphe de type networkx à partir de la matrice d’adjacence du graphe et de le dessiner à l’aide de la fonction draw du module networkx.\n\n# Imports nécessaires\nimport networkx as nx\n\nQuelques commandes utiles :\n\ng = nx.Graph() : création d’un graphe vide\ng.add_node(i) : ajoute le sommet i au graphe g\ng.add_edge(i,j) : ajoute une arête entre les sommets i et j\nnx.draw(g) : dessine le graphe g\n\n\ndef draw_graph(g: Graph) -&gt; None:\n    \"\"\"Dessine le graphe g\"\"\"\n    # Création du graphe\n    G = nx.Graph()\n    # Compléter ci-dessous pour définir un graphe G au format nx correspondant à g\n\n    \n    # Dessin du graphe\n    nx.draw(G, with_labels=True, node_color='white', font_size=18, edgecolors='black', node_size=500)\n\n\n# Vérification de la fonction draw_graph\ndraw_graph(g)"
  },
  {
    "objectID": "08-graphes/tp_graphe_matrice_capytale.html",
    "href": "08-graphes/tp_graphe_matrice_capytale.html",
    "title": "TP - Implémentation des graphes par matrice d’adjacence",
    "section": "",
    "text": "On considère un graphe \\(G\\) dont les sommets sont les entiers de \\(0\\) à \\(n-1\\) et les arêtes sont les couples d’entiers \\((i,j)\\) avec \\(0\\leq i,j\\leq n-1\\).\nL’objectif de ce TP est d’implémenter les graphes en python par matrice d’adjacence.\nOn considère ici que les graphes sont non orientés."
  },
  {
    "objectID": "08-graphes/tp_graphe_matrice_capytale.html#implémentation-simple",
    "href": "08-graphes/tp_graphe_matrice_capytale.html#implémentation-simple",
    "title": "TP - Implémentation des graphes par matrice d’adjacence",
    "section": "Implémentation simple",
    "text": "Implémentation simple\nQuestion 1 : Fonction permettant de créer un graphe comportant \\(n\\) sommets et pas d’arêtes.\n\ndef make_graph(n: int) -&gt; list:\n    \"\"\"Crée la matrice d'adjacence d'un graphe de n sommets sans arêtes\"\"\"\n    g = []\n    # Compléter ci dessous\n    \n    return g\n\n\n# Test de la fonction make_graph\n\ng = make_graph(5)\nprint(g)\n\nQuestion 2 : Fonction permettant d’ajouter une arête entre les sommets \\(i\\) et \\(j\\).\n\ndef add_edge(g: list, i: int, j: int) -&gt; None:\n    \"\"\"Ajoute l'arête (i,j) au graphe g\"\"\"\n    pass\n\nQuestion 3 - Application : en utilisant les deux fonctions précédentes, créer une variable g représentant le graphe suivant :\n\n\n\ngraphe 1\n\n\n\n# Entrer votre code ici\n\n\n# Vérification\nassert g == [[1, 1, 1, 0, 0], [1, 0, 1, 1, 0], [1, 1, 0, 1, 1], [0, 1, 1, 0, 1], [0, 0, 1, 1, 0]]\nprint(\"Test réussi !\")\n\nQuestion 4 : Compléter la fonction remove_edge permettant de supprimer une arête entre les sommets \\(i\\) et \\(j\\).\n\ndef remove_edge(g: list, i: int, j: int) -&gt; None:\n    \"\"\"Supprime l'arête (i,j) du graphe g\"\"\"\n    pass\n\n\n# Test de la fonction remove_edge\nfrom copy import deepcopy\n\nh = deepcopy(g)\nremove_edge(h, 0, 1)\nassert h == [[1, 0, 1, 0, 0], [0, 0, 1, 1, 0], [1, 1, 0, 1, 1], [0, 1, 1, 0, 1], [0, 0, 1, 1, 0]]\nprint(\"Test réussi !\")\n\nQuestion 5 : Compléter les fonctions add_vertex et remove_vertex permettant d’ajouter un sommet et de supprimer un sommet dans un graphe. On rappelle que les sommets sont des entiers successifs. Par exemple, si on supprime le sommet \\(2\\), les sommets \\(3\\) et \\(4\\) deviennent les sommets \\(2\\) et \\(3\\). Par ailleurs, le sommet ajouté par la fonction add_vertex doit être le plus grand sommet du graphe.\n\ndef add_vertex(g: list) -&gt; None:\n    \"\"\"Ajoute un sommet à un graphe g\"\"\"\n    pass\n\ndef remove_vertex(g: list, i: int) -&gt; None:\n    \"\"\"Supprime le sommet i du graphe g\"\"\"\n    pass\n\n\n# Test de la fonction add_vertex\nh = deepcopy(g)\nadd_vertex(h)\nassert h == [[1, 1, 1, 0, 0, 0], [1, 0, 1, 1, 0, 0], [1, 1, 0, 1, 1, 0], [0, 1, 1, 0, 1, 0], [0, 0, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0]]\nprint(\"Test réussi !\")\n\n\n# Test de la fonction remove_vertex\nremove_vertex(h, 5)\nassert h == [[1, 1, 1, 0, 0], [1, 0, 1, 1, 0], [1, 1, 0, 1, 1], [0, 1, 1, 0, 1], [0, 0, 1, 1, 0]]\nprint(\"Test réussi !\")\n\nQuestion 6 : Compléter la fonction est_adjacent qui prend en paramètre un graphe g et deux sommets i et j et qui renvoie True si les sommets sont adjacents et False sinon.\n\ndef is_adjacent(g: list, i: int, j: int) -&gt; bool:\n    \"\"\"Renvoie True si les sommets i et j sont adjacents, False sinon\"\"\"\n    pass\n\n\n# Test de la fonction is_adjacent\nassert is_adjacent(g, 0, 1) == True\nassert is_adjacent(g, 0, 4) == False\nprint(\"Test réussi !\")\n\nQuestion 7 : Compléter la fonction neighbors qui prend en paramètre un graphe g et un sommet i et qui renvoie la liste des sommets adjacents au sommet i, puis la fonction degree qui prend en paramètre un graphe g et un sommet i et qui renvoie le degré du sommet i.\n\ndef neighbors(g: list, i: int) -&gt; list:\n    \"\"\"Renvoie la liste des sommets autres que i \n       adjacents au sommet i\"\"\"\n    pass\n\ndef degree(g: list, i: int) -&gt; int:\n    \"\"\"Renvoie le degré du sommet i\"\"\"\n    pass\n\n\n# Test de la fonction neighbors\nassert neighbors(g, 0) == [1, 2]\nassert neighbors(g, 1) == [0, 2, 3]\n\n# Test de la fonction degree\nassert degree(g, 0) == 2\nassert degree(g, 1) == 3\nprint(\"Test réussi !\")"
  },
  {
    "objectID": "08-graphes/tp_graphe_matrice_capytale.html#implémentation-objet",
    "href": "08-graphes/tp_graphe_matrice_capytale.html#implémentation-objet",
    "title": "TP - Implémentation des graphes par matrice d’adjacence",
    "section": "Implémentation objet",
    "text": "Implémentation objet\nQuestion 8 : Créer une classe Graph permettant de représenter un graphe sous la forme d’une matrice d’adjacence, en reformulant les fonctions définies dans la partie précédente. Cette classe doit contenir les attributs suivants :\n\norder : nombre de sommets du graphe\nmatrix : matrice d’adjacence du graphe\n\nCette classe doit contenir les méthodes suivantes :\n\n__init__ : constructeur de la classe\nadd_edge : ajoute une arête entre les sommets i et j\nremove_edge : supprime une arête entre les sommets i et j\nadd_vertex : ajoute un sommet au graphe\nremove_vertex : supprime un sommet du graphe\nis_adjacent : renvoie True si les sommets i et j sont adjacents et False sinon\nneighbors : renvoie la liste des sommets adjacents au sommet i\ndegree : renvoie le degré du sommet i\n__str__ : renvoie une chaîne de caractères représentant le graphe en affichant les lignes de la matrice d’adjacence l’une en dessous de l’autre.\n\n\nclass Graph:\n\n    pass\n\nQuestion 9 - Application : en utilisant la classe Graph, créer une variable g représentant le graphe suivant :\n\n\n\ngraphe 2\n\n\nDéterminer la liste des voisins du sommet \\(2\\).\n\n# Entrer votre code ici\n\nBonus : Implémenter une fonction draw_graph permettant de dessiner un graphe à partir de sa matrice d’adjacence.\nPour cela, on utilisera le module networkx qui est spécialisé dans l’analyse des graphes. Il s’agit donc de définir un graphe de type networkx à partir de la matrice d’adjacence du graphe et de le dessiner à l’aide de la fonction draw du module networkx.\n\n# Imports nécessaires\nimport networkx as nx\n\nQuelques commandes utiles :\n\ng = nx.Graph() : création d’un graphe vide\ng.add_node(i) : ajoute le sommet i au graphe g\ng.add_edge(i,j) : ajoute une arête entre les sommets i et j\nnx.draw(g) : dessine le graphe g\n\n\ndef draw_graph(g: Graph) -&gt; None:\n    \"\"\"Dessine le graphe g\"\"\"\n    # Création du graphe\n    G = nx.Graph()\n    # Compléter ci-dessous pour définir un graphe G au format nx correspondant à g\n\n    \n    # Dessin du graphe\n    nx.draw(G, with_labels=True, node_color='white', font_size=18, edgecolors='black', node_size=500)\n\n\n# Vérification de la fonction draw_graph\ndraw_graph(g)"
  },
  {
    "objectID": "08-graphes/tp_graphe_matrice_CORR.html",
    "href": "08-graphes/tp_graphe_matrice_CORR.html",
    "title": "TP - Implémentation des graphes par matrice d’adjacence",
    "section": "",
    "text": "On considère un graphe \\(G\\) dont les sommets sont les entiers de \\(0\\) à \\(n-1\\) et les arêtes sont les couples d’entiers \\((i,j)\\) avec \\(0\\leq i,j\\leq n-1\\).\nL’objectif de ce TP est d’implémenter les graphes en python par matrice d’adjacence.\nOn considère ici que les graphes sont non orientés."
  },
  {
    "objectID": "08-graphes/tp_graphe_matrice_CORR.html#implémentation-simple",
    "href": "08-graphes/tp_graphe_matrice_CORR.html#implémentation-simple",
    "title": "TP - Implémentation des graphes par matrice d’adjacence",
    "section": "Implémentation simple",
    "text": "Implémentation simple\nQuestion 1 : Fonction permettant de créer un graphe comportant \\(n\\) sommets et pas d’arêtes.\n\ndef make_graph(n: int) -&gt; list:\n    \"\"\"Crée la matrice d'adjacence d'un graphe de n sommets sans arêtes\"\"\"\n    g = []\n    for i in range(n):\n        line = [0 for j in range(n)]\n        g.append(line)\n    return g\n\n\n# Test de la fonction make_graph\n\ng = make_graph(5)\nprint(g)\n\n[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]\n\n\nQuestion 2 : Fonction permettant d’ajouter une arête entre les sommets \\(i\\) et \\(j\\).\n\ndef add_edge(g: list, i: int, j: int) -&gt; None:\n    \"\"\"Ajoute l'arête (i,j) au graphe g\"\"\"\n    g[i][j] = 1\n    g[j][i] = 1\n\nQuestion 3 - Application : en utilisant les deux fonctions précédentes, créer une variable g représentant le graphe suivant :\n\n\n\ngraphe 1\n\n\n\n# Entrer votre code ici\ng = make_graph(5)\nadd_edge(g, 0, 0)\nadd_edge(g, 0, 1)\nadd_edge(g, 0, 2)\nadd_edge(g, 1, 2)\nadd_edge(g, 1, 3)\nadd_edge(g, 2, 3)\nadd_edge(g, 2, 4)\nadd_edge(g, 3, 4)\nprint(g)\n\n[[1, 1, 1, 0, 0], [1, 0, 1, 1, 0], [1, 1, 0, 1, 1], [0, 1, 1, 0, 1], [0, 0, 1, 1, 0]]\n\n\n\n# Vérification\nassert g == [[1, 1, 1, 0, 0], [1, 0, 1, 1, 0], [1, 1, 0, 1, 1], [0, 1, 1, 0, 1], [0, 0, 1, 1, 0]]\nprint(\"Test réussi !\")\n\nTest réussi !\n\n\nQuestion 4 : Compléter la fonction remove_edge permettant de supprimer une arête entre les sommets \\(i\\) et \\(j\\).\n\ndef remove_edge(g: list, i: int, j: int) -&gt; None:\n    \"\"\"Supprime l'arête (i,j) du graphe g\"\"\"\n    g[i][j] = 0\n    g[j][i] = 0\n\n\n# Test de la fonction remove_edge\nfrom copy import deepcopy\n\nh = deepcopy(g)\nremove_edge(h, 0, 1)\nassert h == [[1, 0, 1, 0, 0], [0, 0, 1, 1, 0], [1, 1, 0, 1, 1], [0, 1, 1, 0, 1], [0, 0, 1, 1, 0]]\nprint(\"Test réussi !\")\n\nTest réussi !\n\n\nQuestion 5 : Compléter les fonctions add_vertex et remove_vertex permettant d’ajouter un sommet et de supprimer un sommet dans un graphe. On rappelle que les sommets sont des entiers successifs. Par exemple, si on supprime le sommet \\(2\\), les sommets \\(3\\) et \\(4\\) deviennent les sommets \\(2\\) et \\(3\\). Par ailleurs, le sommet ajouté par la fonction add_vertex doit être le plus grand sommet du graphe.\n\ndef add_vertex(g: list) -&gt; None:\n    \"\"\"Ajoute un sommet à un graphe g\"\"\"\n    n = len(g)\n    line = [0 for j in range(n+1)]\n    g.append(line)\n    for i in range(n):\n        g[i].append(0)\n\ndef remove_vertex(g: list, i: int) -&gt; None:\n    \"\"\"Supprime le sommet i du graphe g\"\"\"\n    n = len(g)\n    if i &lt; 0 or i &gt;= n:\n        raise IndexError\n    else:\n        for j in range(n):\n            g[j].pop(i)\n        g.pop(i)\n\n\n# Test de la fonction add_vertex\nh = deepcopy(g)\nadd_vertex(h)\nassert h == [[1, 1, 1, 0, 0, 0], [1, 0, 1, 1, 0, 0], [1, 1, 0, 1, 1, 0], [0, 1, 1, 0, 1, 0], [0, 0, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0]]\nprint(\"Test réussi !\")\n\nTest réussi !\n\n\n\n# Test de la fonction remove_vertex\nremove_vertex(h, 5)\nassert h == [[1, 1, 1, 0, 0], [1, 0, 1, 1, 0], [1, 1, 0, 1, 1], [0, 1, 1, 0, 1], [0, 0, 1, 1, 0]]\nprint(\"Test réussi !\")\n\nTest réussi !\n\n\nQuestion 6 : Compléter la fonction est_adjacent qui prend en paramètre un graphe g et deux sommets i et j et qui renvoie True si les sommets sont adjacents et False sinon.\n\ndef is_adjacent(g: list, i: int, j: int) -&gt; bool:\n    \"\"\"Renvoie True si les sommets i et j sont adjacents, False sinon\"\"\"\n    return g[i][j] == 1\n\n\n# Test de la fonction is_adjacent\nassert is_adjacent(g, 0, 1) == True\nassert is_adjacent(g, 0, 4) == False\nprint(\"Test réussi !\")\n\nTest réussi !\n\n\nQuestion 7 : Compléter la fonction neighbors qui prend en paramètre un graphe g et un sommet i et qui renvoie la liste des sommets adjacents au sommet i, puis la fonction degree qui prend en paramètre un graphe g et un sommet i et qui renvoie le degré du sommet i.\n\ndef neighbors(g: list, i: int) -&gt; list:\n    \"\"\"Renvoie la liste des sommets autres que i \n       adjacents au sommet i\"\"\"\n    n = []\n    for j in range(len(g)):\n        if is_adjacent(g, i, j) and i!=j :\n            n.append(j)\n    return n\n\ndef degree(g: list, i: int) -&gt; int:\n    \"\"\"Renvoie le degré du sommet i\"\"\"\n    return len(neighbors(g, i))\n\n\n# Test de la fonction neighbors\nassert neighbors(g, 0) == [1, 2]\nassert neighbors(g, 1) == [0, 2, 3]\n\n# Test de la fonction degree\nassert degree(g, 0) == 2\nassert degree(g, 1) == 3\nprint(\"Test réussi !\")\n\nTest réussi !"
  },
  {
    "objectID": "08-graphes/tp_graphe_matrice_CORR.html#implémentation-objet",
    "href": "08-graphes/tp_graphe_matrice_CORR.html#implémentation-objet",
    "title": "TP - Implémentation des graphes par matrice d’adjacence",
    "section": "Implémentation objet",
    "text": "Implémentation objet\nQuestion 8 : Créer une classe Graph permettant de représenter un graphe sous la forme d’une matrice d’adjacence, en reformulant les fonctions définies dans la partie précédente. Cette classe doit contenir les attributs suivants :\n\norder : nombre de sommets du graphe\nmatrix : matrice d’adjacence du graphe\n\nCette classe doit contenir les méthodes suivantes :\n\n__init__ : constructeur de la classe\nadd_edge : ajoute une arête entre les sommets i et j\nremove_edge : supprime une arête entre les sommets i et j\nadd_vertex : ajoute un sommet au graphe\nremove_vertex : supprime un sommet du graphe\nis_adjacent : renvoie True si les sommets i et j sont adjacents et False sinon\nneighbors : renvoie la liste des sommets adjacents au sommet i\ndegree : renvoie le degré du sommet i\n__str__ : renvoie une chaîne de caractères représentant le graphe en affichant les lignes de la matrice d’adjacence l’une en dessous de l’autre.\n\n\nclass Graph:\n\n    def __init__(self, n: int):\n        \"\"\"Crée un graphe de n sommets sans arêtes\"\"\"\n        self.order = n\n        self.matrix = make_graph(n)\n\n    def add_edge(self, i: int, j: int) -&gt; None:\n        \"\"\"Ajoute l'arête (i,j) au graphe\"\"\"\n        add_edge(self.matrix, i, j)\n\n    def remove_edge(self, i: int, j: int) -&gt; None:\n        \"\"\"Supprime l'arête (i,j) du graphe\"\"\"\n        remove_edge(self.matrix, i, j)\n\n    def add_vertex(self) -&gt; None:\n        \"\"\"Ajoute un sommet au graphe\"\"\"\n        add_vertex(self.matrix)\n\n    def remove_vertex(self, i: int) -&gt; None:\n        \"\"\"Supprime le sommet i du graphe\"\"\"\n        remove_vertex(self.matrix, i)\n\n    def is_adjacent(self, i: int, j: int) -&gt; bool:\n        \"\"\"Renvoie True si les sommets i et j sont adjacents, False sinon\"\"\"\n        return is_adjacent(self.matrix, i, j)\n\n    def neighbors(self, i: int) -&gt; list:\n        \"\"\"Renvoie la liste des sommets adjacents au sommet i\"\"\"\n        return neighbors(self.matrix, i)\n    \n    def degree(self, i: int) -&gt; int:\n        \"\"\"Renvoie le degré du sommet i\"\"\"\n        return degree(self.matrix, i)\n\n    def __str__(self):\n        \"\"\"Affiche le graphe\"\"\"\n        rep = \"\"\n        for line in self.matrix:\n            rep += str(line) + \"\\n\"\n        return rep\n\nQuestion 9 - Application : en utilisant la classe Graph, créer une variable g représentant le graphe suivant :\n\n\n\ngraphe 2\n\n\nDéterminer la liste des voisins du sommet \\(2\\).\n\n# Entrer votre code ici\ng = Graph(7)\ng.add_edge(0, 6)\ng.add_edge(1, 2)\ng.add_edge(1, 3)\ng.add_edge(1, 4)\ng.add_edge(2, 4)\ng.add_edge(2, 5)\ng.add_edge(3, 4)\n\ng.neighbors(2)\n\n[1, 4, 5]\n\n\nBonus : Implémenter une fonction draw_graph permettant de dessiner un graphe à partir de sa matrice d’adjacence.\nPour cela, on utilisera le module networkx qui est spécialisé dans l’analyse des graphes. Il s’agit donc de définir un graphe de type networkx à partir de la matrice d’adjacence du graphe et de le dessiner à l’aide de la fonction draw du module networkx.\n\n# Imports nécessaires\nimport networkx as nx\n\nQuelques commandes utiles :\n\ng = nx.Graph() : création d’un graphe vide\ng.add_node(i) : ajoute le sommet i au graphe g\ng.add_edge(i,j) : ajoute une arête entre les sommets i et j\nnx.draw(g) : dessine le graphe g\n\n\ndef draw_graph(g: Graph) -&gt; None:\n    \"\"\"Dessine le graphe g\"\"\"\n    # Création du graphe\n    G = nx.Graph()\n    for i in range(g.order):\n        G.add_node(i)\n    for i in range(g.order):\n        for j in range(i+1, g.order):\n            if g.is_adjacent(i, j):\n                G.add_edge(i, j)\n    # Dessin du graphe\n    nx.draw(G, with_labels=True, node_color='white', font_size=18, edgecolors='black', node_size=500)\n\n\n# Vérification de la fonction draw_graph\ndraw_graph(g)"
  },
  {
    "objectID": "09-reseaux2/HTTPS_cours.html",
    "href": "09-reseaux2/HTTPS_cours.html",
    "title": "Sécurisation des communications - Cours",
    "section": "",
    "text": "Notebook Capytale pour les exercices de ce cours : Capytale"
  },
  {
    "objectID": "09-reseaux2/HTTPS_cours.html#le-chiffre-de-césar",
    "href": "09-reseaux2/HTTPS_cours.html#le-chiffre-de-césar",
    "title": "Sécurisation des communications - Cours",
    "section": "Le chiffre de César",
    "text": "Le chiffre de César\nL’exemple le plus connu de chiffrement symétrique, et un des plus simples, est le chiffre de César. Cette méthode de communication chiffrée aurait été inventée par Jules César lui-même3. Pour obtenir le texte chiffré, le chiffre de César consiste à remplacer chaque lettre du texte en clair par la lettre obtenue après un décalage d’un nombre fixe de lettres dans l’alphabet.\nPour un décalage de 3 lettres, le A devient D, le B devient E… Comme le montre l’image ci-dessous :\n\n\n\n\n\nLe nombre 3, qui correspond au nombre de lettres à décaler, est appelé la clef secrète de chiffrement. Pour déchiffrer le message, il suffit de donner la clef de chiffrement au destinataire du message qui réalise l’opération inverse pour déchiffrer le message.\n\n\n\n\n\n\n\n\n\n\n\nExtrait de La vie des douze Césars de Suétone\n\n\n\nOn possède enfin de César des lettres à Cicéron, et sa correspondance avec ses amis sur ses affaires domestiques. Il y employait, pour les choses tout à fait secrètes, une espèce de chiffre qui en rendait le sens inintelligible (les lettres étant disposées de manière à ne pouvoir jamais former un mot), et qui consistait, je le dis pour ceux qui voudront les déchiffrer, à changer le rang des lettres dans l’alphabet, en écrivant la quatrième pour la première, c’est-à-dire le D pour le A, et ainsi de suite.\n\n\nJules César et son destinataire utilisent la même clef de chiffrement et elle n’est connue que par eux. Ce chiffrement est donc symétrique et cette clef est la clef partagée.\nExercice 1\nDéchiffrer le message chiffré « qf hwduytlwfumnj jxy zynqnxjj ifsx qjx sfanlfyjzwx bjg ! » avec la clef partagée 5, “à la main” (sans utiliser de programme informatique).\n# Votre réponse ici\nExercice 2\nÉcrire une fonction Python qui déchiffre un message encodé par le chiffrement de César avec un décalage de \\(n\\) caractères, en supposant que le message est écrit en minuscules et sans accents :\ndef dechiffrement_cesar(message, n):\n    \"\"\"\n    Déchiffre un message codé par le chiffrement de César avec un décalage de n caractères\n    Args:\n        message (str): message à déchiffrer\n        n (int): décalage du chiffrement de César\n    Returns:\n        str: message déchiffré\n    \"\"\"\n    a = \"abcdefghijklmnopqrstuvwxyz\"\n    # Votre réponse ici\nPour chiffrer un message avec une fonction analogue, il faut que le texte soit écrit en minuscules et sans accents. Il est donc préférable de calibrer le texte à chiffrer pour enlever les accents et autres caractères spéciaux. Les espaces et signes de ponctuation sont ignorés.\nExercice 3\nCompléter et tester les deux fonctions suivantes\ndef calibrage_texte(texte_a_calibrer: str) -&gt; str:\n    \"\"\"\n    Calibre le texte en enlevant les accents et autres caractères spéciaux\n    et en mettant toutes les lettres en minuscule.\n    Args:\n        texte_a_calibrer (str): texte à calibrer\n    Returns:\n        str: texte calibré\n    \"\"\"\n    # Votre réponse ici\n\ndef chiffrement_cesar(message: str, n: int) -&gt; str:\n    \"\"\"\n    Chiffre un message en utilisant le chiffrement de César avec un décalage de n caractères.\n    Args:\n        message (str): message à chiffrer\n        n (int): décalage du chiffrement de César\n    Returns:\n        str: message chiffré\n    \"\"\"\n    # Votre réponse ici\nCe chiffrement fait apparaître quelques limites intéressantes, dont le principe peut s’appliquer à d’autres algorithmes plus modernes :\n\nla clef 0 n’est pas utilisable, car elle ne chiffre pas le message (notion de clef faible) ;\nsi on se limite à l’alphabet sans ajouter de signe de ponctuation, le nombre de clefs possibles est limité à 25. Il est donc possible de toutes les tester et il s’agit alors d’une attaque dite par « force brute » ;\nl’informatique permet également de réaliser une analyse de la fréquence des occurrences de chaque lettre dans une langue et de la comparer aux fréquences trouvées dans le message chiffré. On sait par exemple qu’en français, la lettre la plus fréquente est le « e ». Si la lettre la plus fréquente du message chiffré est le « f », la clef vaut alors certainement 1.\n\nExercice 4\nÉcrire et tester une fonction Python qui renvoie la lettre la plus fréquente du texte passé en argument. Si des lettres ex æquo apparaissent, on choisit parmi les plus fréquentes la première qui apparaît dans le message chiffré. La fonction doit construire un dictionnaire dont les clefs sont les lettres et les valeurs le nombre d’occurrences de chaque lettre dans le texte.\ndef lettre_plus_frequente(texte: str) -&gt; str:\n    \"\"\"\n    Renvoie la lettre la plus fréquente du texte passé en argument.\n    Args:\n        texte (str): texte dans lequel on cherche la lettre la plus fréquente\n    Returns:\n        str: lettre la plus fréquente\n    \"\"\"\n    # Votre réponse ici\nExercice 5\nÉcrire et tester une fonction Python qui déchiffre le message passé en argument à partir de la recherche de la lettre la plus fréquente dans le texte passé en argument :\ndef dechiffrement_cesar_attaque_frequences(message: str) -&gt; str:\n    \"\"\"\n    Déchiffre le message passé en argument à partir de la recherche de la lettre la plus fréquente dans le texte passé en argument.\n    Args:\n        message (str): message à déchiffrer\n    Returns:\n        str: message déchiffré\n    \"\"\"\n    # Votre réponse ici\nLe chiffre de César est un exemple simple de chiffrement symétrique. Dans une des dernières utilisations connues, l’armée russe chiffra certaines de ses communications avec le chiffre de César durant la Première Guerre mondiale, mais les analystes autrichiens et allemands cassèrent ce code très simplement. De nos jours, le chiffre de César n’est uniquement utilisé qu’à des fins pédagogiques, car il est trop facilement déchiffrable."
  },
  {
    "objectID": "09-reseaux2/HTTPS_cours.html#le-chiffre-de-vernam",
    "href": "09-reseaux2/HTTPS_cours.html#le-chiffre-de-vernam",
    "title": "Sécurisation des communications - Cours",
    "section": "Le chiffre de Vernam",
    "text": "Le chiffre de Vernam\nLe chiffrement symétrique dit de Vernam utilise comme clef partagée une chaîne de caractères aussi longue que le message à chiffrer. L’algorithme consiste alors à :\n\nfaire correspondre chaque lettre du message à chiffrer avec chaque lettre de la clef partagée ;\nconvertir chaque lettre en nombre. Par exemple : 0 pour A, 1 pour B, 2 pour C… Le caractère « espace» est aussi codé par le nombre 26. Les décalages sont alors modulo 27 : la lettre est codée par le reste de la division euclidienne par 27.\nIl est aussi possible d’utiliser le codage ASCII pour convertir chaque lettre en nombre : 65 pour A, 66 pour B… ;\ndécaler dans l’alphabet chaque lettre du message à chiffrer. Ce décalage est égal au nombre correspondant à la lettre qui a la même position dans la clef partagée. Cela revient à effectuer un chiffrement de César avec un décalage différent pour chaque lettre du message à chiffrer.\n\nAttention : pour garantir la sécurité de la méthode, la clef doit être choisie de façon aléatoire et ne pourra servir qu’une fois.\n\n\n\n\n\nExercice 6\nÉcrire une onction Python qui calcule l’index de la lettre du texte à chiffrer (sens = 1) ou à déchiffrer (sens = -1) puis qui renvoie le texte chiffré ou déchiffré. Le texte et la clef ne doivent contenir que des lettres en minuscules et des espaces.\ndef chiffrement_vernam(texte: str, clef: str, sens: int) -&gt; str:\n    \"\"\"\n    Calcule l'index de la lettre du texte à chiffrer (sens = 1) ou à déchiffrer (sens = -1) puis renvoie le texte chiffré ou déchiffré.\n    Args:\n        texte (str): texte à chiffrer ou déchiffrer\n        clef (str): clef de chiffrement\n        sens (int): sens du chiffrement (1 pour chiffrer, -1 pour déchiffrer)\n    Returns:\n        str: texte chiffré ou déchiffré\n    \"\"\"\n    assert len(texte) == len(clef), \"Le texte et la clef doivent contenir le même nombre de caractères.\"\n    a = \"abcdefghijklmnopqrstuvwxyz \"\n    # Votre réponse ici\nUne attaque par force brute n’est pas réalisable, car on peut faire dire « n’importe quoi » avec une clef adéquate. Par exemple, si on déchiffre « awqusabiobuynhoubu » avec « qwrboklepycfotdujq », on décode la phrase « la terre est plate ».\nUtilisé correctement, cet algorithme est théoriquement inviolable. Il faut néanmoins faire attention à certains écueils :\n\nune clef de chiffrement déjà utilisée ne doit pas être réutilisée puisque si deux messages ont été chiffrés avec la même clef de chiffrement, il suffit d’effectuer une soustraction pour annuler l’effet du masque et avec un peu plus de travail, de retrouver les deux textes en clair ;\nla clef se doit d’être aléatoire, par exemple en la générant avec un générateur aléatoire. Si ce n’est pas le cas, il est possible de retrouver la séquence qui l’a générée ;\ncomme la clef, aussi grande que les données échangées, n’est pas réutilisable, il faut au préalable partager, par un autre canal sécurisé, une assez grande quantité de données pour permettre les futurs échanges.\n\nCe système a été utilisé durant la guerre froide par le « Téléphone rouge» entre le Kremlin et la Maison-Blanche, qui était en fait plus un téléscripteur qu’un réel téléphone. La « clef », quant à elle, était échangée par valise diplomatique."
  },
  {
    "objectID": "09-reseaux2/HTTPS_cours.html#le-chiffrement-aes",
    "href": "09-reseaux2/HTTPS_cours.html#le-chiffrement-aes",
    "title": "Sécurisation des communications - Cours",
    "section": "Le chiffrement AES",
    "text": "Le chiffrement AES\nLe chiffrement AES (Advanced Encryption Standard) est un des algorithmes les plus utilisés actuellement et il est à l’heure actuelle considéré comme sûr.\nDans les utilisations les plus fréquentes de l’AES, on peut citer :\n\nle chiffrement des données lors de l’ajout d’un mot de passe à un fichier PDF ou ZIP ;\nla sécurisation des connexions via l’utilisation de VPN ;\nla sécurisation des données utilisateurs lors de l’utilisation d’outils de gestion de mots de passe ;\nla protection de serveurs multi-joueurs contre les attaques. C’est le cas par exemple de l’entreprise Rockstar, développeur et éditeur de la série des Grand Theft Auto (GTA) ;\nle chiffrement des communications lors de l’utilisation de messageries instantanées. C’est le cas de l’application WhatsApp.\n\nCe chiffrement symétrique utilise une clef de 128, 192 ou 256 bits et elle est utilisée pour paramétrer une suite de transformations qui permettent de chiffrer ou de déchiffrer le message.\nLe fonctionnement plus complexe de ce chiffrement par bloc dépasse le cadre des programmes. Pour aller plus loin, il est possible de prendre connaissance, par exemple, du cours sur le sujet édité par le laboratoire lorrain de recherche en informatique et ses applications (LORIA)."
  },
  {
    "objectID": "09-reseaux2/HTTPS_cours.html#le-chiffrement-rsa",
    "href": "09-reseaux2/HTTPS_cours.html#le-chiffrement-rsa",
    "title": "Sécurisation des communications - Cours",
    "section": "Le chiffrement RSA",
    "text": "Le chiffrement RSA\nLe concept de chiffrement asymétrique est attribué à Whitfield Diffie et à Martin Hellman, qui l’ont présenté en 1976. Le premier exemple de chiffrement asymétrique est le chiffrement RSA (abréviation des noms de ses inventeurs Ronald Rivest, Adi Shamir, Loenard Adleman).\nLa sécurité du RSA repose sur la facilité à multiplier deux nombres premiers entre eux et la difficulté de factoriser le produit de deux nombres premiers, pourvu qu’ils soient suffisamment grands. C’est à l’heure actuelle l’algorithme de chiffrement asymétrique le plus utilisé.\nPour comprendre les mécanismes sous-jacents au chiffrement RSA, et ceci n’est pas un attendu des programmes, on pourra lire l’article édité sur Interstices.info qui propose aussi une animation interactive de ce chiffrement.\nÀ noter qu’il existe d’autres algorithmes asymétriques, qui dépassent, eux aussi, les attendus des programmes. On peut citer, par exemple, la « cryptographie sur les courbes elliptiques » qui permet d’avoir un niveau de sécurité comparable à celui de RSA, mais en utilisant une clef beaucoup plus courte. Cette clef plus courte engendre des calculs plus rapides ainsi qu’une utilisation moins importante de mémoire et d’énergie."
  },
  {
    "objectID": "09-reseaux2/HTTPS_cours.html#autre-utilisation-du-chiffrement-symétrique-la-signature-numérique",
    "href": "09-reseaux2/HTTPS_cours.html#autre-utilisation-du-chiffrement-symétrique-la-signature-numérique",
    "title": "Sécurisation des communications - Cours",
    "section": "Autre utilisation du chiffrement symétrique : la signature numérique",
    "text": "Autre utilisation du chiffrement symétrique : la signature numérique\nLe chiffrement asymétrique permet également de réaliser une signature numérique. Par analogie avec la signature traditionnelle d’un document papier, la signature numérique :\n\nrelie un document à son auteur ;\nest difficilement imitable.\n\nContrairement à une signature « papier», la signature numérique possède des propriétés supplémentaires :\n\nelle appartient à un seul message. Il est donc impossible de la copier pour la coller sur un autre message ;\nelle ne peut pas être falsifiée ni reniée.\n\nLa signature numérique est calculée à partir de la clef privée du signataire et peut être vérifiée en utilisant la clef publique du signataire."
  },
  {
    "objectID": "09-reseaux2/HTTPS_cours.html#authentification-du-site",
    "href": "09-reseaux2/HTTPS_cours.html#authentification-du-site",
    "title": "Sécurisation des communications - Cours",
    "section": "Authentification du site",
    "text": "Authentification du site\nLors de l’accès à un site utilisant le protocole HTTPS, le serveur envoie sa clef publique, ainsi qu’une signature numérique de cette clef, c’est ce qu’on appelle le certificat du site. Pour être valide, la signature du certificat du site doit avoir été réalisée par une autorité en laquelle le navigateur a confiance.\nEn pratique, le navigateur ou le système d’exploitation maintiennent une liste de clefs publiques en laquelle ils ont confiance, appelés certificats racines, et avec lesquelles ils vérifient le certificat présenté par le serveur web. Un principe résume correctement cette vérification : « les amis de mes amis sont mes amis ». Cela permet de ne pas avoir à stocker dans le navigateur l’intégralité des certificats des sites sûrs.\nL’inconvénient de cette méthode est que cette liste de certificats racines est critique. En effet si une entrée « malveillante» est ajoutée, tous les sites qui auront été signés avec cette entrée seront considérés comme sûrs par le navigateur.\nEn pratique, d’autres informations sont vérifiées comme la date de validité et la liste de révocations."
  },
  {
    "objectID": "09-reseaux2/HTTPS_cours.html#chiffrement-des-communications",
    "href": "09-reseaux2/HTTPS_cours.html#chiffrement-des-communications",
    "title": "Sécurisation des communications - Cours",
    "section": "Chiffrement des communications",
    "text": "Chiffrement des communications\nUne fois le serveur authentifié, la communication peut commencer. Les algorithmes de chiffrement asymétrique sont en général assez coûteux en temps de calcul, c’est donc un algorithme de chiffrement symétrique qui va être utilisé pour chiffrer les échanges. Le problème est alors celui du partage de la clef.\nUne possibilité est que le client génère une clef, puis qu’il la partage avec le serveur en utilisant la clef publique du serveur pour la chiffrer. De cette façon, seul le serveur pourra déchiffrer la clef partagée et l’échange pourra continuer en utilisant cette clef et un algorithme symétrique.\nUne autre possibilité est d’utiliser un autre protocole appelé l’« Échange de clefs Diffie-Hellman7 » du nom de ses auteurs, en 1976. Cet algorithme permet aux deux participants de se mettre d’accord sur la clef partagée, sans que celle-ci ait à transiter, même cryptée, sur le réseau. Cet échange est d’ailleurs obligatoire dans les versions récentes du protocole et il est utilisé, entre autres, par le réseau Tor.\nExplication complète, mais hors-programme : http://www.acrypta.com/telechargements/fichecrypto_205.pdf\nPour une explication simplifiée : https://www.youtube.com/watch?v=-PoJqTNY1eI"
  },
  {
    "objectID": "09-reseaux2/HTTPS_cours.html#en-résumé",
    "href": "09-reseaux2/HTTPS_cours.html#en-résumé",
    "title": "Sécurisation des communications - Cours",
    "section": "En résumé",
    "text": "En résumé\nL’implémentation du protocole SSL/TLS, et donc du protocole HTTPS, est assez complexe. Les algorithmes utilisés en pratique sont en quelque sorte négociés entre le client et le serveur lors de l’établissement de la connexion. En revanche, il faut être attentif à tous les détails pour que la sécurité soit assurée."
  },
  {
    "objectID": "09-reseaux2/index.html",
    "href": "09-reseaux2/index.html",
    "title": "Programme",
    "section": "",
    "text": "Contenus\nCapacités attendues\nCommentaires\n\n\n\n\nSécurisation des communications.\nDécrire les principes de chiffrement symétrique (clef partagée) et asymétrique (avec clef privée/clef publique).Décrire l’échange d’une clef symétrique en utilisant un protocole asymétrique pour sécuriser une communication HTTPS.\nLes protocoles symétriques et asymétriques peuvent être illustrés en mode débranché, éventuellement avec description d’un chiffrement particulier.La négociation de la méthode chiffrement du protocole SSL (Secure Sockets Layer) n’est pas abordée."
  },
  {
    "objectID": "09-reseaux2/index.html#programme-officiel",
    "href": "09-reseaux2/index.html#programme-officiel",
    "title": "Programme",
    "section": "",
    "text": "Contenus\nCapacités attendues\nCommentaires\n\n\n\n\nSécurisation des communications.\nDécrire les principes de chiffrement symétrique (clef partagée) et asymétrique (avec clef privée/clef publique).Décrire l’échange d’une clef symétrique en utilisant un protocole asymétrique pour sécuriser une communication HTTPS.\nLes protocoles symétriques et asymétriques peuvent être illustrés en mode débranché, éventuellement avec description d’un chiffrement particulier.La négociation de la méthode chiffrement du protocole SSL (Secure Sockets Layer) n’est pas abordée."
  },
  {
    "objectID": "10-langages_prog2/calculabilite.html",
    "href": "10-langages_prog2/calculabilite.html",
    "title": "Calculabilité et décidabilité",
    "section": "",
    "text": "Dans le cadre de la spécialité NSI, nous utilisons le langage Python, même si nous savons qu’il existe bien d’autres langages de programmation, comme JavaScript, C, Perl, Java, Fortran, etc.\nUn même algorithme peut être traduit en un programme dans l’un ou l’autre des langages de notre choix.\nCela revient à dire que tous les langages de programmation usuels ont la même puissance d’expression algorithmique, que chacun permet de programmer les mêmes fonctions que tous les autres. Cela définit ainsi un modèle de calcul :\n\n\n\n\n\n\nFonction calculable\n\n\n\non dira qu’une fonction est calculable si elle peut être programmée dans l’un ou l’autre des langages de programmation usuels.\n\n\nDans ce cours, nous utiliserons le langage Python comme témoin : une fonction est calculable si on peut la programmer en Python.\nIl existe d’autres modèles de calcul, comme les fonctions récursives, les machines de Turing, que nous ne développerons pas ici, et qui ne font pas partie des attendus du programme.\nLa thèse de Church 1 postule que tous ces modèles de calcul sont équivalents : une fonction calculable pour un modèle l’est pour un autre. Cela nous permet d’utiliser le modèle des fonctions programmables en Python sans perdre de généralité.\n\n\n\nAlonzo Church (1903-1995)"
  },
  {
    "objectID": "10-langages_prog2/calculabilite.html#la-thèse-de-church",
    "href": "10-langages_prog2/calculabilite.html#la-thèse-de-church",
    "title": "Calculabilité et décidabilité",
    "section": "",
    "text": "Dans le cadre de la spécialité NSI, nous utilisons le langage Python, même si nous savons qu’il existe bien d’autres langages de programmation, comme JavaScript, C, Perl, Java, Fortran, etc.\nUn même algorithme peut être traduit en un programme dans l’un ou l’autre des langages de notre choix.\nCela revient à dire que tous les langages de programmation usuels ont la même puissance d’expression algorithmique, que chacun permet de programmer les mêmes fonctions que tous les autres. Cela définit ainsi un modèle de calcul :\n\n\n\n\n\n\nFonction calculable\n\n\n\non dira qu’une fonction est calculable si elle peut être programmée dans l’un ou l’autre des langages de programmation usuels.\n\n\nDans ce cours, nous utiliserons le langage Python comme témoin : une fonction est calculable si on peut la programmer en Python.\nIl existe d’autres modèles de calcul, comme les fonctions récursives, les machines de Turing, que nous ne développerons pas ici, et qui ne font pas partie des attendus du programme.\nLa thèse de Church 1 postule que tous ces modèles de calcul sont équivalents : une fonction calculable pour un modèle l’est pour un autre. Cela nous permet d’utiliser le modèle des fonctions programmables en Python sans perdre de généralité.\n\n\n\nAlonzo Church (1903-1995)"
  },
  {
    "objectID": "10-langages_prog2/calculabilite.html#fixons-le-vocabulaire",
    "href": "10-langages_prog2/calculabilite.html#fixons-le-vocabulaire",
    "title": "Calculabilité et décidabilité",
    "section": "Fixons le vocabulaire",
    "text": "Fixons le vocabulaire\n\nProblèmes, instances, prédicats\nLa notion de problème n’est pas si simple à définir. Par exemple : le problème de savoir si un nombre est premier. De quoi s’agit-il précisément ?\nSi j’ai calculé une table des nombres premiers jusqu’à un million, et si on me donne le nombre 870 671, il me suffit de consulter la table pour constater qu’il est effectivement premier. Mais bien entendu cette méthode a ses limites.\nSi on note \\(P\\) l’ensemble des nombres premiers, on voudrait pouvoir dire de tout entier naturel \\(n\\) si oui ou non \\(n \\in P\\).\nAutrement dit, on voudrait avoir accès à une fonction \\(f ∶ \\mathbb{N} \\mapsto \\{Vrai,Faux\\}\\) telle que \\(f(n)\\) est \\(Vrai\\) si et seulement si \\(n\\in P\\).\n\n\n\n\n\n\nProblème décidable\n\n\n\nDire que le problème est décidable, c’est dire qu’il existe un programme Python permettant de calculer \\(f(n)\\) pour tout entier \\(n\\).\n\n\n\n\n\n\n\n\nPrédicat\n\n\n\nUn prédicat est une fonction qui prend des valeurs booléennes, c’est-à-dire dans l’ensemble \\({Vrai,Faux}\\).\n\n\n\n\n\n\n\n\nProblème de décision\n\n\n\nUn problème de décision est la donnée d’un ensemble \\(E\\), que l’on appelle l’ensemble des instances et d’une partie \\(E^+\\) de \\(E\\) que l’on appelle l’ensemble des instances positives.\n\n\nPar exemple le problème de la primalité peut être défini par l’ensemble d’instances \\(E = \\mathbb{N}\\) et l’ensemble d’instances positives \\(E^+ = P\\).\nOn peut présenter un problème de décision de différentes façons.\nD’abord à l’aide d’un schéma comme celui-ci :\n\nNom du problème\nDonnée : spécification d’une instance\nRéponse : propriété portant sur une instance qui spécifie les instances positives\nCe qui donne pour le problème de la primalité :\n\n\nPrimalité d’un entier\nDonnée : un entier naturel\nRéponse : décider si ce nombre est premier\nUne autre façon de définir un problème de décision est de fournir l’ensemble des instances (ici \\(\\mathbb{N}\\)) et la description du prédicat testant l’appartenance aux instances positives (ici, le prédicat est une fonction, la fonction isprime).\nPrenons un autre exemple : colorier un graphe avec un nombre fixé de couleurs, c’est colorier ses sommets de sorte que deux sommets reliés par une arête du graphe ne sont jamais de la même couleur.\nOn peut alors définir :\n\n\nColoration d’un graphe\nDonnée : un graphe non orienté et un nombre \\(c\\) de couleurs\nRéponse : décider si on peut colorier ce graphe avec \\(c\\) couleurs\nNotons qu’ici les instances sont des couples \\((G, c)\\) où \\(G\\) est un graphe et \\(c\\) un entier.\nNos exemples peuvent être plus exotiques, comme :\n\n\nProgramme Python bien formé\nDonnée : une chaîne de caractères\nRéponse : décider si le programme constitué de la chaîne de caractère donnée est un programme Python bien formé, c’est-à-dire sans erreurs de syntaxe\n\n\n\nProblèmes de décision décidables\nUn problème de décision est décidable si on peut écrire un programme en Python qui permette de calculer le prédicat associé au problème.\nAttention ! On ne s’intéresse ici pas du tout aux questions de complexité : que l’algorithme de calcul du prédicat soit coûteux ou pas n’intervient pas, c’est l’existence d’un tel algorithme qui permet de conclure, et pas ses performances.\nPar exemple, on peut écrire un programme qui teste si un nombre est premier, comme celui-ci :\ndef isprime(n):\n    # on élimine les cas triviaux\n    if n &lt; 2:\n        return False\n    if n % 2 == 0: \n        return False\n    # on teste tous les diviseurs possibles (il y a beaucoup plus efficace !)\n    for d in range(3,n,2):\n        if n % d == 0 : return False\n    return True\nOn aura remarqué que le prédicat renvoie une réponse (True ou False) pour n’importe quelle donnée. En particulier, il ne sombre jamais dans une boucle infinie : il termine toujours. On peut donc affirmer que le problème de la primalité est décidable.\nLe problème de la coloration des graphes pose un problème de programmation plus difficile, et nous ne détaillerons pas ici un programme Python pour le prédicat associé : contentons-nous de dire qu’il suffit de balayer de façon systématique les coloriages de tous les sommets avec les couleurs disponibles, et, pour chaque coloriage, de vérifier, par un balayage systématique des arêtes, si deux sommets reliés sont coloriés de la même façon. Mais, pour un graphe à \\(n\\) sommets et \\(p\\) arêtes et \\(c\\) couleurs, cela va coûter cher : un nombre d’opérations de l’ordre de \\(c^n \\times p\\).\nMais on ne s’intéresse pas du tout ici à la complexité et l’important est qu’on puisse affirmer que le problème de la coloration des graphes est décidable.\nNotons au passage que savoir résoudre ce problème de décision permet de résoudre un autre type de problème : déterminer le nombre minimal de couleurs dont il faut disposer pour pouvoir colorer un graphe. Si on a écrit un programme qui résout le problème de décision de la coloration d’un graphe, on peut en déduire facilement :\ndef nbMinimalCouleurs(graphe): \n    c = 1\n    while not colorationPossible(graphe,c):\n        c += 1\n    return c\nOn est assuré de sortir de la boucle : en effet si le graphe possède \\(n\\) sommets, on peut le colorier à coup sûr avec \\(n\\) couleurs, il suffit de colorier chaque sommet par une couleur unique. Ainsi peut-on garantir que la boucle terminera pour une valeur de \\(c\\) au plus égale à \\(n\\).\n\nLe troisième problème que nous avons présenté est, lui aussi, décidable\n\nla preuve peut se limiter à rappeler qu’il existe un interpréteur du langage Python, qui en particulier est capable de décider si oui ou non une chaîne de caractères représente un programme Python syntaxiquement correct. Cet interpréteur est le plus souvent écrit dans le langage C, mais la thèse de Church nous indique qu’on pourrait aussi le programmer en Python.\n\n\nRemarque importante : la question de la calculabilité d’une fonction ou de la décidabilité d’un problème est une question totalement différente de celle de la complexité des algorithmes concernés."
  },
  {
    "objectID": "10-langages_prog2/calculabilite.html#le-problème-de-larrêt",
    "href": "10-langages_prog2/calculabilite.html#le-problème-de-larrêt",
    "title": "Calculabilité et décidabilité",
    "section": "Le problème de l'arrêt",
    "text": "Le problème de l'arrêt\n\nLes fonctions calculables\n\n\n\n\n\n\nFonction calculable\n\n\n\nUne fonction \\(f ∶ E \\mapsto V\\) (où \\(V\\) n’est pas nécessairement l’ensemble \\(\\{Vrai,Faux\\}\\)) est dite calculable s’il existe un programme Python qui prend en entrée une valeur quelconque \\(x\\in E\\) et renvoie toujours la valeur \\(f(x)\\) (ce qui signifie en particulier que le programme termine pour toute entrée \\(x\\) et renvoie \\(f(x)\\)).\n\n\nOn a déjà dit qu’il était équivalent de dire qu’un problème de décision est décidable ou que le prédicat associé est calculable.\n\n\nLes programmes comme données\nUn programme écrit en Python n’est autre qu’une chaîne de caractères : c’est le texte même du programme.\nBien sûr, pour un même programme, en ajoutant des espaces à la fin d’une ligne, ou entre deux mots, on obtient un autre programme qui calcule exactement les mêmes choses. Mais peu importe.\nCela permet de considérer des fonctions qui prennent en entrée des programmes.\n\n\nLe problème de l’arrêt est indécidable\nVoici tout d’abord la définition du problème :\nProblème de l’arrêt\nDonnée : le couple constitué d’un programme Python \\(π\\) pour une fonction \\(f\\) qui prend un argument, et d’une valeur \\(x\\) pour cet argument\nRéponse : décider si le calcul de \\(f(x)\\) par le programme \\(π\\) termine ou ne termine pas\nUne instance est donc un couple \\((π, x)\\) formé du texte \\(π\\) d’un programme Python pour une fonction \\(f\\) et d’une valeur \\(x\\) qui a vocation à être fournie en argument à \\(f\\).\nC’est Alan Turing qui, en 1936, dans le cadre de son fameux article « On Computable Numbers, with an Application to the Entscheidungsproblem », démontre le théorème de l’indécidabilité du problème de l’arrêt qui s’énonce ainsi :\nLe problème de l’arrêt est indécidable.\nCe résultat met définitivement fin à tout espoir d’automatiser de façon algorithmique le calcul de n’importe quelle fonction. C’est ce qui fait son importance, à la fois historique, scientifique et philosophique.\n\n\n\nAlan Turing (1912 - 1954)\n\n\n\nDémonstration du théorème\nLa démonstration classique que nous présentons ici est une preuve par l’absurde. On suppose donc qu’il existe un programme Python qui décide du problème de l’arrêt :\ndef testARRET(programme,x):\n    ...\n    if ...:\n        # si le programme s'arrête sur l'entrée x\n        return True\n    else:\n        return False\nOn définit alors le programme suivant :\ndef testSurSoi(programme):\n    if testARRET(programme,programme):\n        while True:\n            continue \n    else:\n        return True\nLes lignes 3–4 forment une boucle infinie.\nQue se passe-t-il lors de l’appel testSurSoi(testSurSoi) ?\n▷ ou bien cet appel termine, ce qui signifie qu’on n’est pas entré dans la boucle infinie des lignes 3–4. Mais alors, cela signifie que l’appel testARRET(testSurSoi,testSurSoi) a renvoyé la valeur False, ce qui ne peut arriver que si l’appel testSurSoi(testSurSoi) ne termine pas : c’est contradictoire ;\n▷ ou bien cet appel ne termine pas, ce qui signifie qu’on est entré dans la boucle. Cela ne peut arriver que si l’appel testSurSoi(testSurSoi) termine : c’est contradictoire.\nOn aboutit dans tous les cas à une contradiction, ce qui achève notre démonstration par l’absurde !\nRmarque : on peut regarder une vidéo très amusante qui illustre cette célèbre démonstration ici :\n\n\n\n\n\nUn autre exemple de problème indécidable : Le dixième problème de Hilbert\nLors du deuxième congrès international des mathématiciens, tenu à Paris en août 1900, le grand mathématicien allemand David Hilbert (1862–1943) a présenté en août 1900, à Paris, une liste de 23 problèmes à ses collègues. Ces problèmes interrogent en particulier les fondements des mathématiques et de la logique et seule une moitié d’entre eux ont été résolus depuis.\n\n\n\nDavid Hilbert (1862 - 1943)\n\n\nLe dixième problème de Hilbert consiste en la décidabilité d’un problème de décision.\nIl s’agit de déterminer s’il existe un algorithme qui décide si un polynôme à plusieurs variables dont tous les coefficients sont entiers admet ou non des solutions entières.\nPar exemple, l’équation \\(3x^2 − 2xy + 4y^2z = 31\\) admet comme solution \\(x = 1\\), \\(y = 2\\) et \\(z = 2\\), alors que l’équation \\(3x^2 + 6xy + y^2 + z^2 + 1 = 0\\) n’admet aucune solution entière.\nIl a fallu attendre 1970 pour que le mathématicien russe Iouri Vladimirovitch Matiassevitch démontre, à l’âge de 23 ans, que ce problème est indécidable.\n\n\n\nIouri Vladimirovitch Matiassevitch (1947 - )\n\n\n\nDes cas simples\nIl n’est pas trop difficile de décider si une équation polynomiale à une seule variable entière \\(x\\) a ou non des solutions entières.\nLe professeur de mathématiques pourra facilement donner une preuve générale, mais considérons un exemple pour s’en convaincre. Soit l’équation \\(3x^5 − 2x^4 + 7x^3 + 22x^2 − 31x + 7 = 0\\).\nComme le coefficient constant n’est pas nul, \\(x = 0\\) n’est pas solution. Cherchons s’il peut y avoir des solutions entières non nulles.\nEn isolant le terme de degré nul, on obtient une équation équivalente \\(−3x^5 + 2x^4 − 7x^3 − 22x^2 + 31x = 7\\), qu’on peut réécrire sous la forme \\(x(−3x^4 + 2x^3 − 7x^2 − 22x + 31) = 7\\), ce qui prouve qu’une solution entière \\(x\\) non nulle doit être un diviseur de 7 : il suffit donc de tester quelques entiers parmi \\(−7\\), \\(−6\\), \\(−5\\), …, \\(−1\\), \\(0\\), \\(1\\), …, \\(7\\). (Comme \\(7\\) est premier, on ne teste ici que \\(−7\\), \\(−1\\), \\(1\\) et \\(7\\)).\nIl n’est donc besoin que d’une simple boucle pour programmer le prédicat.\nDonc le problème de décider si un polynôme à coefficients entiers et à une seule variable admet ou non des solutions entières est décidable.\n\n\nÇa se complique\nDès que l’équation polynomiale considérée possède deux variables, tout se complique. Par exemple il est vrai que l’équation \\(x^2 − 991y^2 − 1 = 0\\) a des solutions entières, mais elles ne sont pas faciles à trouver : la plus petite d’entre elles est \\(x = 379516400906811930638014896080\\) et \\(y = 12055735790331359447442538767\\).\nOn sait démontrer que le problème de savoir si une équation polynomiale à coefficients entiers à \\(p\\) inconnues a des solutions entières est décidable pour \\(p = 1\\) (on l’a vu plus haut), on sait aussi qu’il est indécidable pour \\(p \\geqslant 9\\). Mais on ne sait pas si le problème est décidable pour \\(p \\in [2, 8]\\).\nIl y a des sous-problèmes décidables : si on se restreint à des équations où le degré total est inférieur ou égal à 2, le problème est décidable ; le problème devient indécidable pour des degrés inférieurs ou égaux à 4. En revanche, on ne sait dire si le dixième problème de Hilbert restreint aux polynômes de degré 3 est décidable ou non décidable !"
  },
  {
    "objectID": "11-algos2/bfs_graphe.html",
    "href": "11-algos2/bfs_graphe.html",
    "title": "Parcours d’un graphe en largeur (Cours)",
    "section": "",
    "text": "Notion de parcours d’un graphe\n\n\n\nD’une façon générale, parcourir un graphe consiste à visiter chaque sommet une seule fois, en appliquant éventuellement un même traitement à chaque sommet.\nPlus précisément, le parcours d’un graphe est une liste \\(L\\) de tous ses sommets :\n\nLe premier élément de \\(L\\) est un sommet de départ choisi arbitrairement.\nChaque sommet du graphe est visité une seule fois exactement.\nChaque sommet, sauf le départ, est adjacent à au moins un sommet déjà visité."
  },
  {
    "objectID": "11-algos2/bfs_graphe.html#parcours-dun-graphe-en-largeur-dabord",
    "href": "11-algos2/bfs_graphe.html#parcours-dun-graphe-en-largeur-dabord",
    "title": "Parcours d’un graphe en largeur (Cours)",
    "section": "Parcours d’un graphe en largeur d’abord",
    "text": "Parcours d’un graphe en largeur d’abord\nCe type de parcours consiste à visiter tous les sommets d’un graphe en commençant par un sommet de départ, puis en visitant tous les sommets adjacents à ce sommet, puis en visitant tous les sommets adjacents à ces sommets et encore non visités, etc. jusqu’à ce que tous les sommets soient visités. En anglais, on parle de breadth-first search (BFS)."
  },
  {
    "objectID": "11-algos2/bfs_graphe.html#exemple",
    "href": "11-algos2/bfs_graphe.html#exemple",
    "title": "Parcours d’un graphe en largeur (Cours)",
    "section": "1. Exemple",
    "text": "1. Exemple\nVoici un exemple de graphe et de parcours en largeur d’abord.\n\n\nCode\nimport networkx as nx\nfrom algorithmx import jupyter_canvas\nfrom algorithmx.networkx import add_graph\n\n# Définition du graphe\ngraph = nx.Graph()\ngraph.add_nodes_from([\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"])\ngraph.add_edges_from([(\"A\", \"B\"), (\"A\", \"D\"), (\"B\", \"C\"), (\"B\", \"E\"), (\"C\", \"F\"), (\"D\", \"E\"), (\"E\", \"F\"), (\"F\", \"G\")])\n\ncanvas = jupyter_canvas(buttons=True)\nadd_graph(canvas, graph)\n\ncanvas\n\n\n\n\n\nParcours en largeur à partir du sommet A :\n\nNous commençons par visiter le sommet A. Nous l’ajoutons à la liste \\(L\\).\nNous visitons tous les sommets adjacents à A, c’est-à-dire B et D. Nous les ajoutons à la liste \\(L\\) qui devient donc \\(L = [A, B, D]\\).\nTous les sommets adjacents à A sont visités. Nous considérons maintenant tous les sommets adjacents à B, c’est-à-dire C et E. Nous les ajoutons à la liste \\(L\\) qui devient donc \\(L = [A, B, D, C, E]\\). Tous les sommets adjacents à B sont visités.\nNous nous intéressons maintenant aux sommets adjacents à D, c’est-à-dire A et E, mais ceux-ci ont déjà été visités. Nous ne les ajoutons donc pas à la liste \\(L\\).\nPassons aux voisins de C, c’est-à-dire B et F. B a déjà été visité, mais F n’a pas encore été visité. Nous l’ajoutons à la liste \\(L\\) qui devient donc \\(L = [A, B, D, C, E, F]\\).\nConsidérons maintenant les voisins de E, c’est-à-dire B, D et F. Tous ont déjà été visités.\nPassons aux voisins de F, c’est-à-dire C, E et G. C et E ont déjà été visités, mais G n’a pas encore été visité. Nous l’ajoutons à la liste \\(L\\) qui devient donc \\(L = [A, B, D, C, E, F, G]\\).\n\nLe parcours en largeur d’abord est terminé. Tous les sommets ont été visités et \\(L=[A, B, D, C, E, F, G]\\).\n\n\n\n\n\n\nRemarque\n\n\n\nLe parcours en largeur d’abord d’un graphe n’est en général pas unique : quand un sommet a plusieurs voisins non visités, l’ordre de leur parcours est arbitraire. Il est donc possible que le parcours en largeur d’abord d’un même graphe donne des résultats différents.\n\n\n\n2. Description de l’algorithme\nVoici les étapes de l’algorithme BFS:\n\n\n\n\n\n\nParcours en largeur d’abord\n\n\n\n\nChoisir un nœud de départ et le marquer comme visité.\nCréer une file vide et y ajouter le nœud de départ.\nTant que la file n’est pas vide :\n\nExtraire le premier élément de la file.\nPour chaque nœud adjacent au nœud extrait, si le nœud n’a pas encore été visité, le marquer comme visité et l’ajouter à la file.\n\n\nLorsque l’algorithme est terminé, tous les nœuds ont été visités.\n\n\nL’algorithme BFS peut être implémenté à l’aide d’une file.\n\n\n3. Implémentation en Python\nPour l’implémentation, nous supposerons que nous avons un graphe défini en utilisant le module networkx de Python.\nVoici une implémentation de l’algorithme BFS en Python.\n\ndef bfs(graph, start):\n    \"\"\"Parcours en largeur d'abord d'un graphe\n    Args:\n        graph: un graphe networkx\n        start: le sommet de départ\n    Returns:\n        list: Une liste contenant les nœuds visités dans l'ordre du parcours.\n    \"\"\"\n    visited = [start]\n    queue = [start]\n    while queue != []:\n        node = queue.pop(0)\n        for neighbor in list((graph.neighbors(node))):\n            if neighbor not in visited:\n                queue.append(neighbor)\n                visited.append(neighbor)            \n    return visited\n\nTest de l’algorithme :\n\nbfs(graph, \"A\")\n\n['A', 'B', 'D', 'C', 'E', 'F', 'G']\n\n\nVisualisation du parcours en largeur d’abord\nNous pouvons visualiser le parcours en largeur d’abord en utilisant le module algorithmx de Python. Ce module permet de visualiser les étapes de l’algorithme de parcours en largeur d’abord.\n\n\nCode\nimport networkx as nx\nfrom algorithmx import jupyter_canvas\nfrom algorithmx.networkx import add_graph\n\n# Définition du graphe\ngraph = nx.Graph()\ngraph.add_nodes_from([\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"])\ngraph.add_edges_from([(\"A\", \"B\"), (\"A\", \"D\"), (\"B\", \"C\"), (\"B\", \"E\"), (\"C\", \"F\"), (\"D\", \"E\"), (\"E\", \"F\"), (\"F\", \"G\")])\n\ncanvas = jupyter_canvas(buttons=True)\nadd_graph(canvas, graph)\n\ncanvas.pause(2)\n\nbfs = nx.edge_bfs(graph, \"A\")\nsource = None\nfor e in bfs:\n    if e[0] != source:\n        # Resize the source\n        canvas.node(e[0]).size('1.6x').color('red')\n        if source is not None:\n            canvas.node(source).size('0.8x')\n\n        # Update the source\n        source = e[0]\n        canvas.pause(1)\n\n    # Traverse the edge\n    canvas.edge(e).traverse('blue')\n    canvas.pause(0.5)\n\ncanvas.node(source).size('0.8x')\n\ncanvas\n\n\n\n\n\n\n\n4. Exemple d’application\nLa principale application de l’algorithme BFS est la recherche de plus court chemin dans un graphe, étant donné que l’algorithme parcourt tous les nœuds du graphe par distance croissante par rapport au nœud de départ.\n\nTrouver le chemin le plus court entre deux nœuds dans un graphe. BFS peut être utilisé pour trouver le chemin le plus court entre deux nœuds dans un graphe en commençant par le premier nœud et en explorant tous ses voisins. Une fois que tous les voisins ont été explorés, l’algorithme passe au nœud suivant dans le graphe et répète le processus. Cela continue jusqu’à ce que le nœud de destination soit atteint."
  },
  {
    "objectID": "11-algos2/dfs_graphe.html",
    "href": "11-algos2/dfs_graphe.html",
    "title": "Parcours d’un graphe en profondeur (Cours)",
    "section": "",
    "text": "Notion de parcours d’un graphe\n\n\n\nD’une façon générale, parcourir un graphe consiste à visiter chaque sommet une seule fois, en appliquant éventuellement un même traitement à chaque sommet.\nPlus précisément, le parcours d’un graphe est une liste \\(L\\) de tous ses sommets :\n\nLe premier élément de \\(L\\) est un sommet de départ choisi arbitrairement.\nChaque sommet du graphe est visité une seule fois exactement.\nChaque sommet, sauf le départ, est adjacent à au moins un sommet déjà visité."
  },
  {
    "objectID": "11-algos2/dfs_graphe.html#parcours-dun-graphe-en-profondeur-dabord",
    "href": "11-algos2/dfs_graphe.html#parcours-dun-graphe-en-profondeur-dabord",
    "title": "Parcours d’un graphe en profondeur (Cours)",
    "section": "Parcours d’un graphe en profondeur d’abord",
    "text": "Parcours d’un graphe en profondeur d’abord\nCe type de parcours est souvent désigné par le terme anglais depth-first search (DFS). Il consiste à parcourir le graphe en partant d’un sommet donné, en suivant un chemin le plus profond possible, puis en revenant en arrière pour suivre un autre chemin. On peut imaginer que l’on se déplace dans le graphe en suivant un chemin qui ressemble à un serpent qui se déplace dans un labyrinthe. Le serpent se déplace le plus profondément possible dans le labyrinthe, puis revient en arrière pour suivre un autre chemin. On peut aussi imaginer que l’on se déplace dans le graphe en suivant un chemin qui ressemble à un arbre. On commence par la racine, puis on descend le plus profondément possible dans l’arbre, puis on remonte en arrière pour suivre un autre chemin.\n\n1. Exemple\nVoici un exemple de graphe et de parcours en profondeur d’abord.\n\n\nCode\nimport networkx as nx\nfrom algorithmx import jupyter_canvas\nfrom algorithmx.networkx import add_graph\n\n# Définition du graphe\ngraph = nx.Graph()\ngraph.add_nodes_from([\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"])\ngraph.add_edges_from([(\"A\", \"B\"), (\"A\", \"D\"), (\"B\", \"C\"), (\"B\", \"E\"), (\"C\", \"F\"), (\"D\", \"E\"), (\"E\", \"F\"), (\"F\", \"G\")])\n\ncanvas = jupyter_canvas(buttons=True)\nadd_graph(canvas, graph)\n\ncanvas\n\n\n\n\n\nParcours en profondeur à partir du sommet A :\n\nNous visitons d’abord le nœud A, puis nous examinons tous ses voisins non visités, qui sont B et D. Nous choisissons B et continuons notre parcours en profondeur à partir de B.\nNous visitons le nœud B, puis nous examinons tous ses voisins non visités, qui sont C et E. Nous choisissons C et continuons notre parcours en profondeur à partir de C.\nNous visitons le nœud C, puis nous examinons tous ses voisins non visités : il n’y a que F. Nous choisissons F et continuons notre parcours en profondeur à partir de F.\nNous visitons le nœud F, puis nous examinons tous ses voisins non visités, qui sont G et E. Nous choisissons G et continuons notre parcours en profondeur à partir de G.\nNous visitons le nœud G, puis nous examinons tous ses voisins non visités : il n’y en a pas. Nous revenons en arrière et continuons notre parcours en profondeur à partir de F.\nF possède encore un voisin non visité, E. Nous choisissons E et continuons notre parcours en profondeur à partir de E.\nNous visitons le nœud E, puis nous examinons tous ses voisins non visités : il n’y a que D. Nous choisissons D et continuons notre parcours en profondeur à partir de D.\nNous visitons le nœud D, puis nous examinons tous ses voisins non visités : il n’y en a pas.\nIl n’y a plus de nœud non visité. Nous avons terminé notre parcours en profondeur.\n\nLe parcours en profondeur d’abord de ce graphe est donc A, B, C, F, G, E, D.\n\n\n\n\n\n\nRemarque\n\n\n\nLe parcours en profondeur d’abord d’un graphe n’est en général pas unique : quand un sommet a plusieurs voisins non visités, l’un d’entre eux est choisi pour continuer le parcours. Il est donc possible que le parcours en profondeur d’abord d’un même graphe donne des résultats différents.\n\n\n\n\n2. Description de l’algorithme\nVoici les étapes de l’algorithme DFS:\n\n\n\n\n\n\nParcours en profondeur d’abord\n\n\n\n\nChoisir un nœud de départ et le marquer comme visité.\nExplorer tous les voisins du nœud en cours qui n’ont pas encore été visités, et choisir l’un d’eux.\nMarquer le nœud choisi comme visité. Il devient le nœud en cours.\nRépéter l’étape 2 et 3 jusqu’à ce que tous les voisins du nœud en cours aient été visités.\nSi tous les voisins du nœud en cours ont été visités, revenir en arrière au nœud précédent et explorer ses voisins non visités.\nRépéter les étapes 2 à 5 jusqu’à ce que tous les nœuds aient été visités.\n\n\n\nL’algorithme DFS peut être implémenté à l’aide d’une pile, en ajoutant les voisins non visités du nœud en cours à la pile et en explorant le voisin au sommet de la pile. Lorsque tous les voisins d’un nœud ont été visités, nous revenons simplement au nœud précédent en dépilant le sommet de la pile. Cette pile permet de garder une trace de la direction de l’exploration.\n\n\n3. Implémentation en Python\nPour l’implémentation, nous supposerons que nous avons un graphe défini en utilisant le module networkx de Python.\nVoici une implémentation de l’algorithme de parcours en profondeur d’abord en Python.\n\ndef dfs(graph, start):\n    \"\"\"Parcours en profondeur d'abord d'un graphe à partir d'un nœud donné.\n    Args:\n        graph: Le graphe à parcourir.\n        start: Le nœud de départ.\n    Returns:\n        Une liste contenant les nœuds visités dans l'ordre du parcours.\n    \"\"\"\n    visited = []\n    stack = [start]\n    while stack != []:\n        node = stack.pop()\n        if node not in visited:\n            visited.append(node)\n            stack = stack + list((graph.neighbors(node)))\n    return visited\n\nTest de l’algorithme :\n\nimport networkx as nx\n\n# Définition du graphe\ngraph = nx.Graph()\ngraph.add_nodes_from([\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"])\ngraph.add_edges_from([(\"A\", \"B\"), (\"A\", \"D\"), (\"B\", \"C\"), (\"B\", \"E\"), (\"C\", \"F\"), (\"D\", \"E\"), (\"E\", \"F\"), (\"F\", \"G\")])\n\n# Parcours en profondeur d'abord à partir du nœud A\nprint(dfs(graph, \"A\"))\n\n['A', 'D', 'E', 'F', 'G', 'C', 'B']\n\n\nLe parcours en profondeur d’abord se prête aussi naturellement à une implémentation récursive. Voici une implémentation de l’algorithme de parcours en profondeur d’abord en Python, en utilisant une fonction récursive.\n\ndef dfs_recursive(graph, start, visited=None):\n    \"\"\"Parcours en profondeur d'abord d'un graphe à partir d'un nœud donné.\n    Args:\n        graph: Le graphe à parcourir.\n        start: Le nœud de départ.\n        visited: Une liste contenant les nœuds déjà visités.\n    Returns:\n        Une liste contenant les nœuds visités dans l'ordre du parcours.\n    \"\"\"\n    if visited is None:\n        visited = []\n    visited.append(start)\n    for node in graph.neighbors(start):\n        if node not in visited:\n            dfs_recursive(graph, node, visited)\n    return visited\n\nTest de l’algorithme :\n\n# Parcours en profondeur d'abord à partir du nœud A\nprint(dfs_recursive(graph, \"A\"))\n\n['A', 'B', 'C', 'F', 'E', 'D', 'G']\n\n\nVisualisation du parcours en profondeur d’abord\nNous pouvons visualiser le parcours en profondeur d’abord en utilisant le module algorithmx de Python. Ce module permet de visualiser les étapes de l’algorithme de parcours en profondeur d’abord.\n\n\nCode\nfrom algorithmx import jupyter_canvas\nfrom algorithmx.networkx import add_graph\n\ncanvas = jupyter_canvas(buttons=True)\nadd_graph(canvas, graph)\n\ncanvas.pause(2)\n\n# Animation du parcours en profondeur d'abord\ndfs = nx.edge_dfs(graph, \"A\")\nsource = None\nfor e in dfs:\n    if e[0] != source:\n        # Resize the source\n        canvas.node(e[0]).size('1.6x').color('red')\n        if source is not None:\n            canvas.node(source).size('0.8x')\n\n        # Update the source\n        source = e[0]\n        canvas.pause(1)\n\n    # Traverse the edge\n    canvas.edge(e).traverse('blue')\n    canvas.pause(0.5)\n\ncanvas.node(source).size('0.8x')\n\ncanvas\n\n\n\n\n\n\n\n4. Exemples d’applications\nLe parcours en profondeur d’abord est utilisé pour résoudre de nombreux problèmes, notamment :\n\nTrouver un chemin entre deux nœuds : le parcours en profondeur d’abord peut être utilisé pour trouver un chemin entre deux nœuds dans un graphe. Il suffit de s’arrêter lorsque le nœud de destination est atteint.\nTrouver un cycle dans un graphe : le parcours en profondeur d’abord peut être utilisé pour trouver un cycle dans un graphe. Si un nœud déjà visité est rencontré, cela signifie qu’il existe un cycle dans le graphe.\nTrouver un arbre couvrant : le parcours en profondeur d’abord peut être utilisé pour trouver un arbre couvrant dans un graphe. Il suffit de s’arrêter lorsque tous les nœuds ont été visités.\n\nCertaines applications seront développées en exercices."
  },
  {
    "objectID": "11-algos2/exos_graphes.html",
    "href": "11-algos2/exos_graphes.html",
    "title": "Exercices - Parcours de graphes",
    "section": "",
    "text": "Exercices sur les parcours de graphes dans Capytale : https://capytale2.ac-paris.fr/web/c/43e1-1602999"
  },
  {
    "objectID": "11-algos2/exos_graphes.html#première-fiche",
    "href": "11-algos2/exos_graphes.html#première-fiche",
    "title": "Exercices - Parcours de graphes",
    "section": "",
    "text": "Exercices sur les parcours de graphes dans Capytale : https://capytale2.ac-paris.fr/web/c/43e1-1602999"
  },
  {
    "objectID": "11-algos2/exos_graphes.html#deuxième-fiche",
    "href": "11-algos2/exos_graphes.html#deuxième-fiche",
    "title": "Exercices - Parcours de graphes",
    "section": "Deuxième fiche",
    "text": "Deuxième fiche\nRecherche de cycles et de chemins dans un graphe : https://capytale2.ac-paris.fr/web/c/fddc-1603011"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "bac/2023_CE_J1_corrige.html",
    "href": "bac/2023_CE_J1_corrige.html",
    "title": "Centres étrangers 2023 Jour 1",
    "section": "",
    "text": "Schéma relationnel de la relation description (la clé primaire est soulignée et la clé étrangère est précédée du symbole #):\ndescription(id_description : INT, resume : TEXT, duree : INT, #id_emission : INT)\n\nLa requête affiche le résultat suivant :\n\n\n\n\n\n\n\n\ntheme\nannee\n\n\n\n\nLe système d’enseignement supérieur français est-il juste et efficace ?\n2022\n\n\nTrois innovations pour la croissance future (1/3) : La révolution blockchain\n2021\n\n\n\n\nRequête permettant d’afficher les thèmes des podcasts de l’année 2019 :\n\nSELECT theme\nFROM podcast\nWHERE annee = 2019\n\nRequête permettant d’afficher la liste des thèmes et des années de diffusion des podcasts dans l’ordre chronologique des années :\n\nSELECT theme, annee\nFROM podcast\nORDER BY annee\n\nLa requête proposée affiche la liste de tous les thèmes de la relation podcast sans répétition.\nRequête SQL supprimant la ligne contenant l’id_podcast = 40 de la relation podcast :\n\nDELETE FROM podcast\nWHERE id_podcast = 40\n\nRequête SQL permettant de changer le nom de l’animateur de l’émission “Le Temps de débat” en “Emmanuel L”.\nUPDATE emission\nSET animateur = \"Emmanuel L\"\nWHERE nom = \"Le Temps de débat\"\nRequête SQL permettant d’ajouter l’émission “Hashtag” sur la radio “France inter” avec “Mathieu V.”, avec un id_emission égal à 12850.\nINSERT INTO emission (id_emission, nom, radio, animateur)\nVALUES (12850, \"Hashtag\", \"France inter\", \"Mathieu V.\")\n\nRequête permettant de lister les thèmes, le nom des émissions et le résumé des podcasts pour lesquels la durée est strictement inférieure à 5 minutes.\nSELECT podcast.theme, emission.nom, description.resume\nFROM podcast\nJOIN emission ON podcast.id_emission = emission.id_emission\nJOIN description ON emission.id_emission = description.id_emission\nWHERE description.duree &lt; 5\n\n\n\n\n\n\n\n\n\n\n\nLa base de donnée telle que définie dans l’énoncé n’est bien construite. Chaque description est en-effet reliée à une émission unique à travers la clé étrangère id_emission, mais pas au podcast correspondant. Comme il existe plusieurs podcasts pour une émission, il n’y a pas moyen de savoir à quel podcast correspond quelle description."
  },
  {
    "objectID": "bac/2023_CE_J1_corrige.html#exercice-1",
    "href": "bac/2023_CE_J1_corrige.html#exercice-1",
    "title": "Centres étrangers 2023 Jour 1",
    "section": "",
    "text": "Schéma relationnel de la relation description (la clé primaire est soulignée et la clé étrangère est précédée du symbole #):\ndescription(id_description : INT, resume : TEXT, duree : INT, #id_emission : INT)\n\nLa requête affiche le résultat suivant :\n\n\n\n\n\n\n\n\ntheme\nannee\n\n\n\n\nLe système d’enseignement supérieur français est-il juste et efficace ?\n2022\n\n\nTrois innovations pour la croissance future (1/3) : La révolution blockchain\n2021\n\n\n\n\nRequête permettant d’afficher les thèmes des podcasts de l’année 2019 :\n\nSELECT theme\nFROM podcast\nWHERE annee = 2019\n\nRequête permettant d’afficher la liste des thèmes et des années de diffusion des podcasts dans l’ordre chronologique des années :\n\nSELECT theme, annee\nFROM podcast\nORDER BY annee\n\nLa requête proposée affiche la liste de tous les thèmes de la relation podcast sans répétition.\nRequête SQL supprimant la ligne contenant l’id_podcast = 40 de la relation podcast :\n\nDELETE FROM podcast\nWHERE id_podcast = 40\n\nRequête SQL permettant de changer le nom de l’animateur de l’émission “Le Temps de débat” en “Emmanuel L”.\nUPDATE emission\nSET animateur = \"Emmanuel L\"\nWHERE nom = \"Le Temps de débat\"\nRequête SQL permettant d’ajouter l’émission “Hashtag” sur la radio “France inter” avec “Mathieu V.”, avec un id_emission égal à 12850.\nINSERT INTO emission (id_emission, nom, radio, animateur)\nVALUES (12850, \"Hashtag\", \"France inter\", \"Mathieu V.\")\n\nRequête permettant de lister les thèmes, le nom des émissions et le résumé des podcasts pour lesquels la durée est strictement inférieure à 5 minutes.\nSELECT podcast.theme, emission.nom, description.resume\nFROM podcast\nJOIN emission ON podcast.id_emission = emission.id_emission\nJOIN description ON emission.id_emission = description.id_emission\nWHERE description.duree &lt; 5\n\n\n\n\n\n\n\n\n\n\n\nLa base de donnée telle que définie dans l’énoncé n’est bien construite. Chaque description est en-effet reliée à une émission unique à travers la clé étrangère id_emission, mais pas au podcast correspondant. Comme il existe plusieurs podcasts pour une émission, il n’y a pas moyen de savoir à quel podcast correspond quelle description."
  },
  {
    "objectID": "bac/2023_CE_J1_corrige.html#exercice-2",
    "href": "bac/2023_CE_J1_corrige.html#exercice-2",
    "title": "Centres étrangers 2023 Jour 1",
    "section": "Exercice 2",
    "text": "Exercice 2\n\n\nOn convertit les entiers 2 et 13 en binaire sur 8 bits :\n\n\n\n\n2\n13\n\n\n\n\n00000010\n00001101\n\n\n\nL’adresse IP 164.178.2.13 est donc représentée par la chaîne de caractères :\n10100100.10110010.00000010.00001101\n\nL’adresse IP indique que les 24 premiers bits sont réservés à l’identifiant du réseau et les 8 derniers bits sont réservés à l’identifiant de l’hôte. La machine appartient donc au réseau dont l’adresse est 164.178.2.0\n\nPour un paquet émis par A à destination de G, les chemins optimaux en suivant le protocole RIP sont ceux qui minimisent le nombre se sauts :\n\n\n\nChemin\nNombre de sauts\n\n\n\n\nA -&gt; B -&gt; C -&gt; H -&gt; G\n4\n\n\nA -&gt; B -&gt; E -&gt; G\n3\n\n\nA -&gt; D -&gt; E -&gt; G\n3\n\n\nA -&gt; D -&gt; F -&gt; G\n3\n\n\n\nLes chemins optimaux sont donc A -&gt; B -&gt; E -&gt; G, A -&gt; D -&gt; E -&gt; G et A -&gt; D -&gt; F -&gt; G.\n\nLe coût d’une liaison Ethernet est \\(\\frac{10^9}{10^8}=10\\), celui d’une liaison Fast-Ethernet est \\(\\frac{10^9}{10^9}=1\\) et celui d’une liaison fibre est \\(\\frac{10^9}{10^{10}}=0.1\\)\n\n\n\nNous pouvons déterminer le chemin de parcours en utilisant l’algorithme de Dijkstra.\n\n\n\nA\nB\nC\nD\nE\nF\nG\nH\nchoix\n\n\n\n\n0-A\n-\n-\n-\n-\n-\n-\n-\nA(0)\n\n\nX\n1-A\n-\n10-A\n-\n-\n-\n-\nB(1)\n\n\nX\nX\n11-B\n10-A\n11-B\n-\n-\n-\nD(10)\n\n\nX\nX\n11-B\nX\n10.1-D\n11-D\n-\n-\nE(10.1)\n\n\nX\nX\n11-B\nX\nX\n11-D\n20.1-E\n-\nC(11) ou F(11)\n\n\nX\nX\nX\nX\nX\nX\n12-F\n11.1-C\nH(11.1)\n\n\nX\nX\nX\nX\nX\nX\n12-F\nX\nG(12)\n\n\n\nLe chemin optimal est donc A -&gt; D -&gt; F -&gt; G de coût total 12.\nLe routeur F est en panne. Nous appliquons l’algorithme de Dijkstra en supprimant le routeur F\n\n\n\nA\nB\nC\nD\nE\nG\nH\nchoix\n\n\n\n\n0-A\n-\n-\n-\n-\n-\n-\nA(0)\n\n\nX\n1-A\n-\n10-A\n-\n-\n-\nB(1)\n\n\nX\nX\n11-B\n10-A\n11-B\n-\n-\nD(10)\n\n\nX\nX\n11-B\nX\n10.1-D\n-\n-\nE(10.1)\n\n\nX\nX\n11-B\nX\nX\n20.1-E\n-\nC(11)\n\n\nX\nX\nX\nX\nX\n20.1-E\n11.1-C\nH(11.1)\n\n\nX\nX\nX\nX\nX\n12.1-H\nX\nG(12.1)\n\n\n\nLe chemin optimal est donc A -&gt; B -&gt; C -&gt; H -&gt; G de coût total 12.1."
  },
  {
    "objectID": "bac/2023_CE_J1_corrige.html#exercice-3",
    "href": "bac/2023_CE_J1_corrige.html#exercice-3",
    "title": "Centres étrangers 2023 Jour 1",
    "section": "Exercice 3",
    "text": "Exercice 3\n\nFonction permettant l’ajout d’une couleur aléatoire dans la file f :\ndef ajout(f):\n    couleurs = (\"bleu\", \"rouge\", \"jaune\", \"vert\")\n    indice = randint(0, 3)\n    enfiler(f, couleurs[indice])\n    return f\nFonction permettant de vider la séquence f :\ndef vider(f):\n    while not est_vide(f):\n        defiler(f)\nFonction affich_seq complétée :\ndef affich_seq(sequence):\n    stock = creer_file_vide()\n    ajout(sequence)\n    while not est_vide(sequence):\n        c = defiler(sequence)\n        affichage(c)\n        time.sleep(0.5)\n        enfiler(stock, c)\n    while not est_vide(stock):\n        enfiler(sequence, defiler(stock))\n\nFonction tour_de_jeu complétée :\n\ndef tour_de_jeu(sequence):\n    affich_seq(sequence) # zone A\n    stock = creer_file_vide()\n    while not est_vide(sequence):\n        c_joueur = saisie_joueur()\n        c_seq = defiler(sequence) # zone B\n        if c_joueur == c_seq:\n            enfiler(stock, c_seq) # zone C\n        else:\n            vider(sequence) # zone D\n    while not est_vide(stock): # zone E\n        enfiler(sequence, defiler(stock)) # zone F\n\nFonction modifiée :\n\n\ndef tour_de_jeu(sequence):\n    affich_seq(sequence) # zone A\n    stock = creer_file_vide()\n    gagne = True\n    while not est_vide(sequence):\n        c_joueur = saisie_joueur()\n        c_seq = defiler(sequence) # zone B\n        if c_joueur == c_seq:\n            enfiler(stock, c_seq) # zone C\n        else:\n            vider(sequence) # zone D\n            gagne = False\n    while not est_vide(stock): # zone E\n        enfiler(sequence, defiler(stock)) # zone F\n    if gagne:\n        tour_de_jeu(sequence)\n    else:\n        vider(sequence)\n        ajout(sequence)\n        tour_de_jeu(sequence)"
  },
  {
    "objectID": "bac/2023_CE_J2_corrige.html",
    "href": "bac/2023_CE_J2_corrige.html",
    "title": "Centres étrangers 2023 Jour 2",
    "section": "",
    "text": "Toute adresse IP du type 192.168.5.XYZ avec XYZ différente de 000, 255 et 003 est valide pour le routeur F. En effet, l’adresse 192.168.5.0 est celle du réseau lui-même, l’adresse 192.168.5.255 correspond en général à l’adresse de diffusion et l’adresse 192.168.5.3 est déjà utilisée par une machine. On peut donc par exemple affecter l’adresse 192.168.5.1 au routeur F.\nEn tenant compte des remarques précédentes, XYZ peut prendre les valeurs de 1 à 254. Il y a donc 254 adresses IP valides pour le réseau F.\n\n\nLe masque de sous-réseau du réseau B est 255.255.240.0.\nUne des machine du réseau B a pour adresse IP 192.168.2.2. Pour déterminer le masque de sous-réseau, on convertit ces adresses en binaire. On obtient alors 11000000.10101000.00000010.00000010 pour la machine et 11111111.11111111.11110000.00000000 pour le masque. En effectuant un ET logique bit à bit, on obtient 11000000.10101000.00000000.00000000 qui correspond à l’adresse du réseau B. On peut donc conclure que le masque de sous-réseau du réseau B est 192.168.0.0.\nL’interconnexion entre les routeurs A, B, E et F permet, en cas de défaillance de l’un d’entre eux, de maintenir la liaison entre toutes les machines représentées sur le schéma.\n\n\n\n\n\n\n\nIl existe un chemin de longueur 2 entre le routeur A et le routeur E : A - B - E. Il s’agit du plus cours chemin possible en terme de nombre de sauts. Pour aller de F vers B, il existe plusieurs chemins optimaux en termes de nombre de sauts. Ce sont tous les chemins de longueur 3 : F - D - A - B, F - H - G - B et F - H - E - B.\n\nTable de routage du routeur E\n\n\nDestination\nRouteur suivant\nDistance\n\n\n\n\nA\nB\n2\n\n\nB\nB\n1\n\n\nC\nH\n2\n\n\nD\nG\n2\n\n\nE\nE\n0\n\n\nF\nH\n2\n\n\nG\nG\n1\n\n\nH\nH\n1\n\n\n\n\nTable de routage du routeur G\n\n\nDestination\nRouteur suivant\nDistance\n\n\n\n\nA\nB\n2\n\n\nB\nB\n1\n\n\nC\nD\n1\n\n\nD\nD\n1\n\n\nE\nE\n1\n\n\nF\nD\n2\n\n\nG\nG\n0\n\n\nH\nH\n1\n\n\n\n\n\n\nTable de routage du routeur F\n\n\nDestination\nRouteur suivant\nCoût total\n\n\n\n\nA\nD\n1.1\n\n\nB\nH\n10.11\n\n\nC\nD\n1.1\n\n\nD\nD\n0.1\n\n\nE\nH\n10.1\n\n\nG\nD\n1.1\n\n\nH\nH\n0.1\n\n\n\nEntre le routeur E et le routeur D, le chemin optimal est E - H - F - D, dont le coût total est de 10.2."
  },
  {
    "objectID": "bac/2023_CE_J2_corrige.html#exercice-1",
    "href": "bac/2023_CE_J2_corrige.html#exercice-1",
    "title": "Centres étrangers 2023 Jour 2",
    "section": "",
    "text": "Toute adresse IP du type 192.168.5.XYZ avec XYZ différente de 000, 255 et 003 est valide pour le routeur F. En effet, l’adresse 192.168.5.0 est celle du réseau lui-même, l’adresse 192.168.5.255 correspond en général à l’adresse de diffusion et l’adresse 192.168.5.3 est déjà utilisée par une machine. On peut donc par exemple affecter l’adresse 192.168.5.1 au routeur F.\nEn tenant compte des remarques précédentes, XYZ peut prendre les valeurs de 1 à 254. Il y a donc 254 adresses IP valides pour le réseau F.\n\n\nLe masque de sous-réseau du réseau B est 255.255.240.0.\nUne des machine du réseau B a pour adresse IP 192.168.2.2. Pour déterminer le masque de sous-réseau, on convertit ces adresses en binaire. On obtient alors 11000000.10101000.00000010.00000010 pour la machine et 11111111.11111111.11110000.00000000 pour le masque. En effectuant un ET logique bit à bit, on obtient 11000000.10101000.00000000.00000000 qui correspond à l’adresse du réseau B. On peut donc conclure que le masque de sous-réseau du réseau B est 192.168.0.0.\nL’interconnexion entre les routeurs A, B, E et F permet, en cas de défaillance de l’un d’entre eux, de maintenir la liaison entre toutes les machines représentées sur le schéma.\n\n\n\n\n\n\n\nIl existe un chemin de longueur 2 entre le routeur A et le routeur E : A - B - E. Il s’agit du plus cours chemin possible en terme de nombre de sauts. Pour aller de F vers B, il existe plusieurs chemins optimaux en termes de nombre de sauts. Ce sont tous les chemins de longueur 3 : F - D - A - B, F - H - G - B et F - H - E - B.\n\nTable de routage du routeur E\n\n\nDestination\nRouteur suivant\nDistance\n\n\n\n\nA\nB\n2\n\n\nB\nB\n1\n\n\nC\nH\n2\n\n\nD\nG\n2\n\n\nE\nE\n0\n\n\nF\nH\n2\n\n\nG\nG\n1\n\n\nH\nH\n1\n\n\n\n\nTable de routage du routeur G\n\n\nDestination\nRouteur suivant\nDistance\n\n\n\n\nA\nB\n2\n\n\nB\nB\n1\n\n\nC\nD\n1\n\n\nD\nD\n1\n\n\nE\nE\n1\n\n\nF\nD\n2\n\n\nG\nG\n0\n\n\nH\nH\n1\n\n\n\n\n\n\nTable de routage du routeur F\n\n\nDestination\nRouteur suivant\nCoût total\n\n\n\n\nA\nD\n1.1\n\n\nB\nH\n10.11\n\n\nC\nD\n1.1\n\n\nD\nD\n0.1\n\n\nE\nH\n10.1\n\n\nG\nD\n1.1\n\n\nH\nH\n0.1\n\n\n\nEntre le routeur E et le routeur D, le chemin optimal est E - H - F - D, dont le coût total est de 10.2."
  },
  {
    "objectID": "bac/2023_CE_J2_corrige.html#exercice-2",
    "href": "bac/2023_CE_J2_corrige.html#exercice-2",
    "title": "Centres étrangers 2023 Jour 2",
    "section": "Exercice 2",
    "text": "Exercice 2\n\n\nLe résultat de la requête est le suivant :\n\n\n\n\nage\ntaille\npoids\n\n\n\n\n6\n1.70\n100\n\n\n\n\nLa requête est la suivante :\n\nSELECT nom, age \nFROM animal\nWHERE nom_espece = 'bonobo'\nORDER BY age\n\nL’attribut nom_espece peut vraisemblablement servir de clé primaire pour la relation espece car deux espèces différentes doivent avoir des noms différents. L’attribut num_enclos est une clé étrangère relative à la clé primaire num_enclos de la relation enclos.\nSchéma relationnel de la base de données :\n\nanimal(id_animal : INT, nom : VARCHAR, age : INT, taille : FLOAT, poids : INT, #nom_espece : VARCHAR)\nenclos(num_enclos : INT, ecosysteme : VARCHAR, surface : INT, struct : VARCHAR, date_entretien : DATE)\nespece(nom_espece : VARCHAR, classe : VARCHAR, alimentation : VARCHAR, #num_enclos : INT)\n\n\n\nLa requête suivante corrige l’erreur signalée :\n\nUPDATE espece\nSET classe='mammifères'\nWHERE nom_espece='ornithorynque'\n\nLa requête suivante permet d’intégrer le nouveau venu dans la base de données :\n\nINSERT INTO animal VALUES (179, 'Serge', 0, 0.8, 30, 'lama')\n\nRequête permettant de recenser le nom et l’espèce de tous les animaux carnivores vivant en vivarium dans le zoo :\n\nSELECT nom, nom_espece\nFROM animal\nJOIN espece ON animal.nom_espece = espece.nom_espece\nJOIN enclos ON espece.num_enclos = enclos.num_enclos\nWHERE enclos.struct = 'vivarium' and espece.alimentation = 'carnivore'\n\nRequête permettant de connaître le nombre d’oiseaux dans tout le zoo :\n\nSELECT COUNT(*)\nFROM animal\nJOIN espece ON animal.nom_espece = espece.nom_espece\nWHERE espece.classe = 'oiseau'"
  },
  {
    "objectID": "bac/2023_CE_J2_corrige.html#exercice-3",
    "href": "bac/2023_CE_J2_corrige.html#exercice-3",
    "title": "Centres étrangers 2023 Jour 2",
    "section": "Exercice 3",
    "text": "Exercice 3\n\n\nLa fonction retourne : Bonjour Alan !.\nx et y sont deux variable booléennes. x est la valeur de vérité de la comparaison entre les caractères n et j, elle prend donc la valeur False. y est la valeur de vérité de la comparaison entre les caractères o et o, elle prend donc la valeur True.\nLa fonction suivante prend en paramètre une chaîne une_chaine et une lettre une_lettre et retourne le nombre de fois où la lettre une_lettre apparaît dans la chaîne une_chaine :\n\ndef occurrences_lettre(une_chaine, une_lettre):\n    \"\"\"Retourne le nombre d'occurrences de la lettre une_lettre dans la chaîne une_chaine.\"\"\"\n    compteur = 0\n    for lettre in une_chaine:\n        if lettre == une_lettre:\n            compteur += 1\n    return compteur\n\nPour obtenir un arbre binaire de hauteur minimale, on range les mots dans l’ordre alphabétique et on place le mot du milieu à la racine. On répète l’opération sur les deux sous-arbres de gauche et de droite.\nListe dans l’ordre alphabétique : ['chameau', 'gnou', 'pingouin', 'python', 'renard'].\nOn obtient l’arbre :\n\nPour obtenir un arbre de hauteur maximale, on peut placer à la racine le premier mot de la liste classée dans l’ordre alphabétique, puis placer le mot suivant en sous-arbre droit et chaque mot suivant en sous-arbre droit du précédent. On obtient un arbre filiforme.\n\n\n\nmystere(abr_mots_francais) retourne 336 531. Cette fonction calcule en effet de façon récursive le nombre d’éléments de l’arbre binaire donné en paramètre, égal à un (on compte la racine, si l’arbre n’est pas vide) plus le nombre d’éléments de l’arbre binaire de gauche plus le nombre d’éléments de l’arbre binaire de droite.\nFonction permettant de calculer la hauteur d’un arbre binaire :\n\ndef hauteur(un_abr):\n    \"\"\"Retourne la hauteur de l'arbre binaire un_abr.\"\"\"\n    if un_abr.est_vide():\n        return 0\n    else:\n        return 1 + max(hauteur(un_abr.sous_arbre_gauche), hauteur(un_abr.sous_arbre_droit))\n\nCode de la fonction complétée :\n\ndef chercher_mots(liste_mots, longueur, lettre, position):\n    res = []\n    for i in range(len(liste_mots)):\n        if len(liste_mots[i]) == longueur and liste_mots[i][position] == lettre:\n            res.append(liste_mots[i])\n    return res\n\nLa commande chercher_mots(liste_mots_francais, 3, 'x', 2) retourne la liste des mots français de longueur 3 contenant la lettre x à la troisième position. La commande chercher_mots(chercher_mots(liste_mots_francais, 3, 'x', 2), 3, 'a', 1) retourne, parmi ceux-ci, les mots qui possèdent un ‘a’ à la deuxième position, soit à partir de l’exemple donné dans l’énoncé : [‘fax’, ‘max’].\nCode permettant de trouver les mots de 5 lettres qui se terminent par ‘ter’ :\n\nchercher_mots(chercher_mots(chercher_mots(liste_mots_francais, 5, 't', 2), 5, 'e', 3), 5, 'r', 4)"
  },
  {
    "objectID": "bac/annales.html",
    "href": "bac/annales.html",
    "title": "Annales du bac de NSI",
    "section": "",
    "text": "Centres étrangers 2023, jour 1 : Sujet PDF, Corrigé.\nCentres étrangers 2023, jour 2 : Sujet PDF, corrigé.\nPolynésie 2023, jour 1 : Sujet PDF.\nPolynésie 2023, jour 2 : Sujet PDF."
  },
  {
    "objectID": "bac/annales.html#sujets-2023",
    "href": "bac/annales.html#sujets-2023",
    "title": "Annales du bac de NSI",
    "section": "",
    "text": "Centres étrangers 2023, jour 1 : Sujet PDF, Corrigé.\nCentres étrangers 2023, jour 2 : Sujet PDF, corrigé.\nPolynésie 2023, jour 1 : Sujet PDF.\nPolynésie 2023, jour 2 : Sujet PDF."
  },
  {
    "objectID": "bac/index.html",
    "href": "bac/index.html",
    "title": "Épreuve de NSI au bac en Terminale",
    "section": "",
    "text": "Fichier à télécharger…"
  },
  {
    "objectID": "bac/index.html#programme-officiel",
    "href": "bac/index.html#programme-officiel",
    "title": "Épreuve de NSI au bac en Terminale",
    "section": "",
    "text": "Fichier à télécharger…"
  },
  {
    "objectID": "bac/index.html#nature-de-lépreuve-de-nsi-au-bac-en-terminale",
    "href": "bac/index.html#nature-de-lépreuve-de-nsi-au-bac-en-terminale",
    "title": "Épreuve de NSI au bac en Terminale",
    "section": "Nature de l’épreuve de NSI au bac en Terminale",
    "text": "Nature de l’épreuve de NSI au bac en Terminale\nD’après le Bulletin Officiel n°36 du 30 septembre 2022 :\n\nDurée : 3 heures 30 + 1 heure\nCoefficient : 16\nFormat : L’épreuve terminale obligatoire de spécialité est composée de deux parties :\n\nune partie écrite, comptant pour 12 points sur 20,\nune partie pratique comptant pour 8 points sur 20.\n\n\nPartie écrite de l’épreuve de NSI au bac en terminale\n\nDurée : 3 heures 30\nModalités : La partie écrite consiste en la résolution de trois exercices permettant d’évaluer les connaissances et les capacités attendues conformément aux programmes de première et de terminale de la spécialité.\nChaque exercice est noté sur 4 points.\nLe sujet comporte trois exercices indépendants les uns des autres, qui permettent d’évaluer les connaissances et compétences des candidats.\n\n\nPoints du programme évaluables lors de l’épreuve écrite\nRéférence : Bulletin officiel n°36 du 30 septembre 2022\n\nThème 2 – Structures de données\n\nStructures de données, interface et implémentation.\nVocabulaire de la programmation objet : classes, attributs, méthodes, objets.\nListes, piles, files : structures linéaires. Dictionnaires, index et clé.\nArbres : structures hiérarchiques. Arbres binaires : nœuds, racines, feuilles, sous-arbres gauches, sous-arbres droits.\n\nThème 3 – Bases de données\n\nModèle relationnel : relation, attribut, domaine, clef primaire, clef étrangère, schéma relationnel.\nBase de données relationnelle.\nLangage SQL : requêtes d’interrogation et de mise à jour d’une base de données.\n\nThème 4 – Architectures matérielles, systèmes d’exploitation et réseaux\n\nGestion des processus et des ressources par un système d’exploitation.\nProtocoles de routage.\n\nThème 5 – Langages et programmation\n\nRécursivité.\nModularité.\nMise au point des programmes. Gestion des bugs.\n\nThème 6 – Algorithmique\n\nAlgorithmes sur les arbres binaires et sur les arbres binaires de recherche.\nMéthode « diviser pour régner »\n\n\n\n\nPoints du programme non évalués à l’écrit\n\nThème 1 – Histoire de l’informatique\nThème 2 – Structures de données\n\nGraphes : structures relationnelles. Sommets, arcs, arêtes, graphes orientés ou non orientés.\n\nThème 3 – Bases de données\n\nSystème de gestion de bases de données relationnelles.\n\nThème 4 – Architectures matérielles, systèmes d’exploitation et réseaux\n\nComposants intégrés d’un système sur puce.\nSécurisation des communications.\n\nThème 5 – Langages et programmation\n\nNotion de programme en tant que donnée. Calculabilité, décidabilité.\nParadigmes de programmation\n\nThème 6 – Algorithmique\n\nAlgorithmes sur les graphes.\nProgrammation dynamique.\nRecherche textuelle."
  },
  {
    "objectID": "bac/index.html#partie-pratique-de-lépreuve-de-nsi-au-bac-en-terminale",
    "href": "bac/index.html#partie-pratique-de-lépreuve-de-nsi-au-bac-en-terminale",
    "title": "Épreuve de NSI au bac en Terminale",
    "section": "Partie pratique de l’épreuve de NSI au bac en terminale",
    "text": "Partie pratique de l’épreuve de NSI au bac en terminale\n\nDurée : 1 heure\nModalités : La partie pratique consiste en la résolution de deux exercices sur ordinateur, chacun étant noté sur 4 points.\nLe candidat est évalué sur la base d’un dialogue avec un professeur-examinateur.\nUn examinateur évalue au maximum quatre élèves. L’examinateur ne peut pas évaluer un élève qu’il a eu en classe durant l’année en cours.\nL’évaluation de cette partie se déroule au cours du deuxième trimestre pendant la période de l’épreuve écrite de spécialité.\n\nPremier exercice\nLe premier exercice consiste à programmer un algorithme figurant explicitement au programme, ne présentant pas de difficulté particulière, dont on fournit une spécification.\nIl s’agit donc de restituer un algorithme rencontré et travaillé à plusieurs reprises en cours de formation.\nLe sujet peut proposer un jeu de test avec les réponses attendues pour permettre au candidat de vérifier son travail.\nDeuxième exercice\nPour le second exercice, un programme est fourni au candidat.\nCet exercice ne demande pas l’écriture complète d’un programme, mais permet de valider des compétences de programmation suivant des modalités variées : le candidat doit, par exemple, compléter un programme « à trous » afin de répondre à une spécification donnée, ou encore compléter un programme pour le documenter, ou encore compléter un programme en ajoutant des assertions, etc."
  },
  {
    "objectID": "GrandOral/index.html",
    "href": "GrandOral/index.html",
    "title": "Grand Oral et NSI",
    "section": "",
    "text": "Le grand oral est une épreuve orale qui se dérouler en juin. Son coefficient est de 10 (sur un total de 100). Vous devez préparer en première et surtout en terminale deux questions en rapport avec vos spécialités de terminale. Page de présentation officielle du grand oral Article du bulletin officiel (BO) définissant le grand oral."
  },
  {
    "objectID": "GrandOral/index.html#présentation",
    "href": "GrandOral/index.html#présentation",
    "title": "Grand Oral et NSI",
    "section": "",
    "text": "Le grand oral est une épreuve orale qui se dérouler en juin. Son coefficient est de 10 (sur un total de 100). Vous devez préparer en première et surtout en terminale deux questions en rapport avec vos spécialités de terminale. Page de présentation officielle du grand oral Article du bulletin officiel (BO) définissant le grand oral."
  },
  {
    "objectID": "GrandOral/index.html#les-deux-questions",
    "href": "GrandOral/index.html#les-deux-questions",
    "title": "Grand Oral et NSI",
    "section": "Les deux questions",
    "text": "Les deux questions\n\nRépartition des spécialités\nLe BO dit : “ces questions portent sur les deux enseignements de spécialité soit pris isolément, soit abordés de manière transversale”. On comprend qu’il est nécessaire d’aborder les deux enseignements de spécialité, et qu’il est possible de les mélanger. Néanmoins il semblerait qu’il soit nécessaire (pour des raisons d’organisation, voir plus bas) d’avoir une spécialité majeure différente dans chaque question. Voici donc le schéma des répartitions possibles des spécialités (A et B) dans les deux questions (1 et 2) :\n\n\n\nQuestion 1\nQuestion 2\n\n\n\n\nA\nB\n\n\nA\nmajeure B et mineure A\n\n\nmajeure A et mineure B\nB\n\n\nmajeure A et mineure B\nmajeure B et mineure A\n\n\n\nBien sûr, le caractère majeur ou mineur d’une spécialité dans une question peut être sujet à discussion. Cela donne néanmoins un cadre de réflexion.\n\n\nSujet des questions\nEncore une fois le BO est assez concis : Elles mettent en lumière un des grands enjeux du ou des programmes de ces enseignements [de spécialité]. Elles sont adossées à tout ou partie du programme du cycle terminal. Les questions doivent donc avoir un lien avec le programme de terminale ou éventuellement de première. La question de NSI (ou de majeure NSI) doit donc s’inscrire dans les thèmes suivants :\nPour la terminale :\n\nhistoire de l’informatique ;\nstructures de données ;\nbases de données ;\narchitectures matérielles, systèmes d’exploitation et réseaux ;\nlangages et programmation\nalgorithmique\n\nPour la première :\n\nhistoire de l’informatique ;\nreprésentation des données: types et valeurs de base ;\nreprésentation des données: types construits ;\ntraitement de données en tables ;\ninteractions entre l’homme et la machine sur le Web\narchitectures matérielles et systèmes d’exploitation\nlangages et programmation\nalgorithmique\n\nDans ce document offiicel, on peut lire :\n\nL’entrée choisie par l’élève peut être variée : le choix du champ disciplinaire dans un parcours d’orientation ; des exemples de notions mathématiques qui ont changé son regard ou lui ont apporté des clés de lecture ; des obstacles didactiques auxquels il a été confronté ; une notion du programme ; un point de l’histoire des sciences ; une démonstration ; un lien avec une autre spécialité, une attention portée à une notion pour ses enjeux sociétaux ou dans un parcours d’orientation comme l’éducation à la santé, au développement durable, aux médias et à l’information, aux problèmes bioéthiques.\n\nSi la question rentre dans ces critères, elle peut donc être valide.\n\n\nDéroulement\n\nChoix de la question\nVous serez évalué par un jury composé d’un professeur d’une de vos spécialités et d’un professeur d’une autre matière (votre autre spécialité ou non). Le jury choisira donc la question pour laquelle il est compétent.\n\n\n20 minutes de préparation\nUne fois que vous connaissez la question choisie par le jury, vous avez 20 minutes pour mettre vos idées au clair. Vous avez la possibilité de réaliser un support sur ue feuille fournie. Vous pouvez donner ce support au jury au début de l’entretien.\n\n\n20 minutes d’entretien\nL’entretien se déroule en trois temps. Tout l’entretien se fait sans notes et sans support excepté, éventuellement, celui que vous avez créé pendant votre préparation.\n\n\n\n\n\n\nPrécisions au sujet du support papier\n\n\n\nCe support est une aide pour la parole du candidat ; il n’a pas vocation à être donné à lire au jury. Il s’agit de notes, d’un plan d’exposé, de trame de prise de parole, de mots-clefs ou d’idées directrices. Ces notes peuvent aussi servir de document d’appui à l’argumentation (schéma, courbe, diagramme, tableau, formule mathématique…).\nSource : Eduscol\n\n\n\n5 minutes de présentation\nVous disposez de 5 minutes pour :\n\nexpliquer pourquoi vous avez choisi cette question ;\ndévelopper le question ;\ny répondre.\n\nLe jury ne vous interrompt pas sauf si vous dépassez du temps imparti. Tout cela se fait sans notes et sans support.\n\n\n10 minutes d’échange avec le jury\nPendant ce temps, le jury vous interroge sur votre question, il demande des précisions. Il peut élargir les questions au thème abordé puis à tout le programme de terminale et première.\n\n\n5 minutes d’échange sur votre projet d’orientation\nIl est conseillé de faire un lien entre la question traitée et votre projet d’orientation. Vous devez expliquer les étapes de la maturation de votre projet d’orientation et détailler votre projet après le bac.\n\n\n\n\nÉvaluation\nLors de votre présentation, le jury évalue les capacités argumentatives et les qualités oratoires du candidat. Vous n’êtes pas évalué ici sur le fond, mais plutôt sur la forme (je rappelle qu’il y aura vraisemblablement un membre du jury qui n’aura rien compris à ce que vous avez dit).\nLors de l’échange avec le jury, il évalue la solidité des connaissances et les capacités argumentatives du candidat. Vous êtes donc évalué ici sur vos connaissances.\nLors de l’échange sur votre projet d’orientation, le jury mesure la capacité du candidat à conduire et exprimer une réflexion personnelle témoignant de sa curiosité intellectuelle et de son aptitude à exprimer ses motivations. Il n’évalue surtout pas votre projet d’orientation en lui-même."
  },
  {
    "objectID": "GrandOral/index.html#exemples-de-sujets",
    "href": "GrandOral/index.html#exemples-de-sujets",
    "title": "Grand Oral et NSI",
    "section": "Exemples de sujets",
    "text": "Exemples de sujets\n\nExemples issus du document officiel\n\nL’histoire de l’informatique\n\nFemmes et numérique : quelle histoire ? quel avenir ?\nAda Lovelace, pionnière du langage informatique.\nAlan Turing, et l’informatique fut.\nQuelle est la différence entre le web 1.0 et le web 2.0 ?\n\n\n\nLangages et programmation\n\nP = NP, un problème à un million de dollars ?\nTours de Hanoï : plus qu’un jeu d’enfants ?\nLes fractales : informatique et mathématiques imitent-elles la nature ?\nDe la récurrence à la récursivité.\nLes bugs : bête noire des développeurs ?\nComment rendre l’informatique plus sûre ?\n\n\n\nDonnées structurées et structures de données\n\nL’informatisation des métros : progrès ou outil de surveillance ?\nMusique et informatique : une alliance possible de l’art et de la science ?\n\n\n\nAlgorithmique\n\nComment créer une machine intelligente ?\nComment lutter contre les biais algorithmiques ?\nQuels sont les enjeux de la reconnaissance faciale (notamment éthiques) ?\nQuels sont les enjeux de l’intelligence artificielle ?\nTransformation d’images : Deep Fakes, une arme de désinformation massive ? La fin de la preuve par l’image ?\nQu’apporte la récursivité dans un algorithme ?\nQuel est l’impact de la complexité d’un algorithme sur son efficacité ?\n\n\n\nBases de données\n\nDonnées personnelles : la vie privée en voie d’extinction ?\nComment optimiser les données ?\n\n\n\nArchitectures matérielles, systèmes d’exploitation et réseaux\n\nL’ordinateur quantique : nouvelle révolution informatique ?\nLa course à l’infiniment petit : jusqu’où ?\nPeut-on vraiment sécuriser les communications ?\nQuelle est l’utilité des protocoles pour l’internet ?\nCyberguerre : la 3e guerre mondiale ?\n\n\n\nInterfaces Hommes-Machines (IHM)\n\nSmart cities, smart control ?\nLa réalité virtuelle : un nouveau monde ?\nLa voiture autonome, quels enjeux ?\n\n\n\nImpact sociétal et éthique de l’informatique\n\nComment protéger les données numériques sur les réseaux sociaux ?\nQuelle est l’empreinte carbone du numérique en termes de consommation ?\nPourquoi chiffrer ses communications ?\nLes réseaux sociaux sont-ils compatibles avec la politique ?\nLes réseaux sociaux sont-ils compatibles avec le journalisme ?\nLes réseaux sociaux permettent-ils de lutter contre les infox ?\nL’informatique va-t-elle révolutionner le dessin animé ?\nL’informatique va-t-elle révolutionner la composition musicale ?\nL’informatique va-t-elle révolutionner l’art ?\nL’informatique va-t-elle révolutionner le cinéma ?\nL’informatique va-t-elle révolutionner la médecine ?\nL’informatique va-t-elle révolutionner la physique ?\nL’informatique va-t-elle révolutionner l’entreprise ?\nLe numérique : facteur de démocratisation ou de fractures sociales ?\nInformatique : quel impact sur le climat ?\n\n\n\n\nExemples issus des sujets choisis les années précédentes\n\nPourquoi Javascript est-il devenu le langage le plus utilisé au monde ?\nPourquoi chiffrer les communications ?\nL’informatique va-t-elle révolutionner le dessin animé ?\nComment l’informatique a-t-elle révolutionné la vie des gens dans le domaine du divertissement au fil des années ?\nComment fonctionnent les bases de données distribuées ?\nNos informations personnelles sont-elles en sécurité dans les bases de données ?\nComment l’informatique s’inspire du vivant ?\nEnigma et décryptage. En quoi l’informatique a-t-elle fait évoluer les maths ?\nComment évolue la cyber-sécurité ?\nModélisation 3D et graphes.\nL’art algorithmique est-il vraiment un art ?\nComment protéger les données numériques sur les réseaux\nQuels sont les enjeux des cyberguerres ?\nFractales, l’info et les maths imitent-elles la nature ?\nLes réseaux sociaux sont-ils compatibles avec la politique ?\nAvenir de la réalité virtuelle ?\nLes réseaux sociaux sont-ils compatibles avec le journalisme ?\nEn quoi la cryptologie a-t-elle permis de raccourcir la deuxième guerre mondiale ?\nComment fonctionne Tor ?\nComment flash est-il passé du statu d’utilisable à mort en 2021 ?\nPourquoi Python a-t-il été inventé ?\nComment l’automate cellulaire peut-il imiter les êtres vivants par de simples règles informatiques ?\nComment HTML 5 a révolutionné le développement web ?\nQuelles ont été les évolutions de l’utilisation d’internet ?\n(Maths/Info) Quel est l’impact de la complexité d’un algorithme sur son efficacité ?\nComment optimiser le traitement des données ?\nLa machine de Turing est-elle obsolète ?\n(Maths/Info) De la récurrence à la récursivité.\n(Maths/Info) La course à l’infiniment petit, jusqu’où ?\n(Info/Phy?) En quoi l’ordinateur quantique est-il révolutionnaire ?\nQu’apporte la récursivité dans un algorithme ?\nPeut-on vraiment sécuriser les communications ?\nQuels sont les enjeux de l’intelligence artificielle ?\n(Maths/info) P=NP, un problème à un million de dollars.\nComment rendre l’informatique plus sûre ?\n(Info/ Maths) En quoi la machine Enigma a t-elle révolutionnée l’informatique ?\n(Info/ Maths) Un ordinateur peut-il écrire une démonstration mathématique ?\n\n\nSources\n\nhttps://kxs.fr/cours/grand-oral/exemples\nhttps://bfourlegnie.com/Tnsi_2020/cours/Gd_oral/grand_oral_NSI.pdf"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Spécialité NSI - Terminale",
    "section": "",
    "text": "Bienvenue !\nCe site est destiné à regrouper les cours et les exercices concernant l’enseignement de spécialité NSI de terminale du lycée Emile Duclaux d’Aurillac.\nLien vers l’ENT du lycée : https://cas.ent.auvergnerhonealpes.fr/login"
  },
  {
    "objectID": "ressources.html",
    "href": "ressources.html",
    "title": "Sources utilisées",
    "section": "",
    "text": "Pour rédiger ce cours et préparer les exercices, TP, projets présentés ici, j’ai utilisé de nombreuses sources que je vais essayer de citer ici, sans prétendre être exhaustif.\n\nDocuments d’accompagnement Eduscol.\nContenus du MOOC “Numérique et Sciences Informatiques : les fondamentaux” de l’INRIA, disponible sur la plateforme fun-mooc.\nApprendre à programmer avec Python 3, Gérard Swinnen, éditions Eyrolles, 2012. Disponible en ligne\nLe site interstices : https://interstices.info/.\nLes images et illustrations sont soit produites par mes soins, soit issues de Pixabay ou de Wikimedia commons ou encore de Pexels et, dans tous les cas, libres de droits.\nCours de David Roche.\nCours de Frédéric Junier.\nCours de Van Zuijlen Stéphan.\nCours de Konieczko Quentin\nCours de Olivier Lécluse\nCours du Lycée Blaise Pascal de Clermont-Ferrand\nCours du lycée Champollion de Grenoble\nCours du site Lyceum\nCours du site Mon Lycée Numérique\nCours du Lycée Stanislas de Wissembourg\nCours d’informatique de François Brucker (école Centrale de Marseille)\nCours de Philippe Rigaux sur les bases de données.\nCours de Gilles Lassus\nLe site MDN Web Docs : excellentissime ressource pour tout apprendre sur les langages HTML, CSS, Javascript et le protocole HTTP.\nLe site de M. JANVIER."
  }
]