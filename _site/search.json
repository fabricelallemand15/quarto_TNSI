[
  {
    "objectID": "arbresgraphes/tp_graphe_matrice.html",
    "href": "arbresgraphes/tp_graphe_matrice.html",
    "title": "TP - Implémentation des graphes par matrice d’adjacence",
    "section": "",
    "text": "On considère un graphe \\(G\\) dont les sommets sont les entiers de \\(0\\) à \\(n-1\\) et les arêtes sont les couples d’entiers \\((i,j)\\) avec \\(0\\leq i,j\\leq n-1\\).\nL’objectif de ce TP est d’implémenter les graphes en python par matrice d’adjacence.\nOn considère ici que les graphes sont non orientés."
  },
  {
    "objectID": "arbresgraphes/tp_graphe_matrice.html#implémentation-simple",
    "href": "arbresgraphes/tp_graphe_matrice.html#implémentation-simple",
    "title": "TP - Implémentation des graphes par matrice d’adjacence",
    "section": "Implémentation simple",
    "text": "Implémentation simple\nQuestion 1 : Fonction permettant de créer un graphe comportant \\(n\\) sommets et pas d’arêtes.\n\ndef make_graph(n: int) -> list:\n    \"\"\"Crée la matrice d'adjacence d'un graphe de n sommets sans arêtes\"\"\"\n    g = []\n    for i in range(n):\n        line = [0 for j in range(n)]\n        g.append(line)\n    return g\n\n\n# Test de la fonction make_graph\n\ng = make_graph(5)\nprint(g)\n\n[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]\n\n\nQuestion 2 : Fonction permettant d’ajouter une arête entre les sommets \\(i\\) et \\(j\\).\n\ndef add_edge(g: list, i: int, j: int) -> None:\n    \"\"\"Ajoute l'arête (i,j) au graphe g\"\"\"\n    g[i][j] = 1\n    g[j][i] = 1\n\nQuestion 3 - Application : en utilisant les deux fonctions précédentes, créer une variable g représentant le graphe suivant :\n\n\n\ngraphe 1\n\n\n\n# Entrer votre code ici\ng = make_graph(5)\nadd_edge(g, 0, 0)\nadd_edge(g, 0, 1)\nadd_edge(g, 0, 2)\nadd_edge(g, 1, 2)\nadd_edge(g, 1, 3)\nadd_edge(g, 2, 3)\nadd_edge(g, 2, 4)\nadd_edge(g, 3, 4)\nprint(g)\n\n[[1, 1, 1, 0, 0], [1, 0, 1, 1, 0], [1, 1, 0, 1, 1], [0, 1, 1, 0, 1], [0, 0, 1, 1, 0]]\n\n\n\n# Vérification\nassert g == [[1, 1, 1, 0, 0], [1, 0, 1, 1, 0], [1, 1, 0, 1, 1], [0, 1, 1, 0, 1], [0, 0, 1, 1, 0]]\nprint(\"Test réussi !\")\n\nTest réussi !\n\n\nQuestion 4 : Compléter la fonction remove_edge permettant de supprimer une arête entre les sommets \\(i\\) et \\(j\\).\n\ndef remove_edge(g: list, i: int, j: int) -> None:\n    \"\"\"Supprime l'arête (i,j) du graphe g\"\"\"\n    g[i][j] = 0\n    g[j][i] = 0\n\n\n# Test de la fonction remove_edge\nfrom copy import deepcopy\n\nh = deepcopy(g)\nremove_edge(h, 0, 1)\nassert h == [[1, 0, 1, 0, 0], [0, 0, 1, 1, 0], [1, 1, 0, 1, 1], [0, 1, 1, 0, 1], [0, 0, 1, 1, 0]]\nprint(\"Test réussi !\")\n\nTest réussi !\n\n\nQuestion 5 : Compléter les fonctions add_vertex et remove_vertex permettant d’ajouter un sommet et de supprimer un sommet dans un graphe. On rappelle que les sommets sont des entiers successifs. Par exemple, si on supprime le sommet \\(2\\), les sommets \\(3\\) et \\(4\\) deviennent les sommets \\(2\\) et \\(3\\). Par ailleurs, le sommet ajouté par la fonction add_vertex doit être le plus grand sommet du graphe.\n\ndef add_vertex(g: list) -> None:\n    \"\"\"Ajoute un sommet à un graphe g\"\"\"\n    n = len(g)\n    line = [0 for j in range(n+1)]\n    g.append(line)\n    for i in range(n):\n        g[i].append(0)\n\ndef remove_vertex(g: list, i: int) -> None:\n    \"\"\"Supprime le sommet i du graphe g\"\"\"\n    n = len(g)\n    if i < 0 or i >= n:\n        raise IndexError\n    else:\n        for j in range(n):\n            g[j].pop(i)\n        g.pop(i)\n\n\n# Test de la fonction add_vertex\nh = deepcopy(g)\nadd_vertex(h)\nassert h == [[1, 1, 1, 0, 0, 0], [1, 0, 1, 1, 0, 0], [1, 1, 0, 1, 1, 0], [0, 1, 1, 0, 1, 0], [0, 0, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0]]\nprint(\"Test réussi !\")\n\nTest réussi !\n\n\n\n# Test de la fonction remove_vertex\nremove_vertex(h, 5)\nassert h == [[1, 1, 1, 0, 0], [1, 0, 1, 1, 0], [1, 1, 0, 1, 1], [0, 1, 1, 0, 1], [0, 0, 1, 1, 0]]\nprint(\"Test réussi !\")\n\nTest réussi !\n\n\nQuestion 6 : Compléter la fonction est_adjacent qui prend en paramètre un graphe g et deux sommets i et j et qui renvoie True si les sommets sont adjacents et False sinon.\n\ndef is_adjacent(g: list, i: int, j: int) -> bool:\n    \"\"\"Renvoie True si les sommets i et j sont adjacents, False sinon\"\"\"\n    return g[i][j] == 1\n\n\n# Test de la fonction is_adjacent\nassert is_adjacent(g, 0, 1) == True\nassert is_adjacent(g, 0, 4) == False\nprint(\"Test réussi !\")\n\nTest réussi !\n\n\nQuestion 7 : Compléter la fonction neighbors qui prend en paramètre un graphe g et un sommet i et qui renvoie la liste des sommets adjacents au sommet i, puis la fonction degree qui prend en paramètre un graphe g et un sommet i et qui renvoie le degré du sommet i.\n\ndef neighbors(g: list, i: int) -> list:\n    \"\"\"Renvoie la liste des sommets autres que i \n       adjacents au sommet i\"\"\"\n    n = []\n    for j in range(len(g)):\n        if is_adjacent(g, i, j) and i!=j :\n            n.append(j)\n    return n\n\ndef degree(g: list, i: int) -> int:\n    \"\"\"Renvoie le degré du sommet i\"\"\"\n    return len(neighbors(g, i))\n\n\n# Test de la fonction neighbors\nassert neighbors(g, 0) == [1, 2]\nassert neighbors(g, 1) == [0, 2, 3]\n\n# Test de la fonction degree\nassert degree(g, 0) == 2\nassert degree(g, 1) == 3\nprint(\"Test réussi !\")\n\nTest réussi !"
  },
  {
    "objectID": "arbresgraphes/tp_graphe_matrice.html#implémentation-objet",
    "href": "arbresgraphes/tp_graphe_matrice.html#implémentation-objet",
    "title": "TP - Implémentation des graphes par matrice d’adjacence",
    "section": "Implémentation objet",
    "text": "Implémentation objet\nQuestion 8 : Créer une classe Graph permettant de représenter un graphe sous la forme d’une matrice d’adjacence, en reformulant les fonctions définies dans la partie précédente. Cette classe doit contenir les attributs suivants :\n\norder : nombre de sommets du graphe\nmatrix : matrice d’adjacence du graphe\n\nCette classe doit contenir les méthodes suivantes :\n\n__init__ : constructeur de la classe\nadd_edge : ajoute une arête entre les sommets i et j\nremove_edge : supprime une arête entre les sommets i et j\nadd_vertex : ajoute un sommet au graphe\nremove_vertex : supprime un sommet du graphe\nis_adjacent : renvoie True si les sommets i et j sont adjacents et False sinon\nneighbors : renvoie la liste des sommets adjacents au sommet i\ndegree : renvoie le degré du sommet i\n__str__ : renvoie une chaîne de caractères représentant le graphe en affichant les lignes de la matrice d’adjacence l’une en dessous de l’autre.\n\n\nclass Graph:\n\n    def __init__(self, n: int):\n        \"\"\"Crée un graphe de n sommets sans arêtes\"\"\"\n        self.order = n\n        self.matrix = make_graph(n)\n\n    def add_edge(self, i: int, j: int) -> None:\n        \"\"\"Ajoute l'arête (i,j) au graphe\"\"\"\n        add_edge(self.matrix, i, j)\n\n    def remove_edge(self, i: int, j: int) -> None:\n        \"\"\"Supprime l'arête (i,j) du graphe\"\"\"\n        remove_edge(self.matrix, i, j)\n\n    def add_vertex(self) -> None:\n        \"\"\"Ajoute un sommet au graphe\"\"\"\n        add_vertex(self.matrix)\n\n    def remove_vertex(self, i: int) -> None:\n        \"\"\"Supprime le sommet i du graphe\"\"\"\n        remove_vertex(self.matrix, i)\n\n    def is_adjacent(self, i: int, j: int) -> bool:\n        \"\"\"Renvoie True si les sommets i et j sont adjacents, False sinon\"\"\"\n        return is_adjacent(self.matrix, i, j)\n\n    def neighbors(self, i: int) -> list:\n        \"\"\"Renvoie la liste des sommets adjacents au sommet i\"\"\"\n        return neighbors(self.matrix, i)\n    \n    def degree(self, i: int) -> int:\n        \"\"\"Renvoie le degré du sommet i\"\"\"\n        return degree(self.matrix, i)\n\n    def __str__(self):\n        \"\"\"Affiche le graphe\"\"\"\n        rep = \"\"\n        for line in self.matrix:\n            rep += str(line) + \"\\n\"\n        return rep\n\nQuestion 9 - Application : en utilisant la classe Graph, créer une variable g représentant le graphe suivant :\n\n\n\ngraphe 2\n\n\nDéterminer la liste des voisins du sommet \\(2\\).\n\n# Entrer votre code ici\ng = Graph(7)\ng.add_edge(0, 6)\ng.add_edge(1, 2)\ng.add_edge(1, 3)\ng.add_edge(1, 4)\ng.add_edge(2, 4)\ng.add_edge(2, 5)\ng.add_edge(3, 4)\n\ng.neighbors(2)\n\n[1, 4, 5]\n\n\nBonus : Implémenter une fonction draw_graph permettant de dessiner un graphe à partir de sa matrice d’adjacence.\nPour cela, on utilisera la bibliothèque matplotlib.pyplot et le module networkx qui est spécialisé dans l’analyse des graphes. Il s’agit donc de définir un graphe de type networkx à partir de la matrice d’adjacence du graphe et de le dessiner à l’aide de la fonction draw du module networkx.\n\n# Imports nécessaires\nimport networkx as nx\n\nQuelques commandes utiles :\n\ng = nx.Graph() : création d’un graphe vide\ng.add_node(i) : ajoute le sommet i au graphe g\ng.add_edge(i,j) : ajoute une arête entre les sommets i et j\nnx.draw(g) : dessine le graphe g\n\n\ndef draw_graph(g: Graph) -> None:\n    \"\"\"Dessine le graphe g\"\"\"\n    # Création du graphe\n    G = nx.Graph()\n    for i in range(g.order):\n        G.add_node(i)\n    for i in range(g.order):\n        for j in range(i+1, g.order):\n            if g.is_adjacent(i, j):\n                G.add_edge(i, j)\n    # Dessin du graphe\n    nx.draw(G, with_labels=True, node_color='white', font_size=18, edgecolors='black', node_size=500)\n\n\n# Vérification de la fonction draw_graph\ndraw_graph(g)"
  },
  {
    "objectID": "arbresgraphes/implementationArbres.html",
    "href": "arbresgraphes/implementationArbres.html",
    "title": "Implémentation des arbres en Python",
    "section": "",
    "text": "L’objectif de cette partie est d’implémenter la structure d’arbre binaire en Python. Nous allons pour cela utiliser la Programmation Orientée Objet et construire un module réutilisable proposant à l’utilisateur une interface (API) permettant de travailler avec les arbres binaires."
  },
  {
    "objectID": "arbresgraphes/implementationArbres.html#arbres-binaires",
    "href": "arbresgraphes/implementationArbres.html#arbres-binaires",
    "title": "Implémentation des arbres en Python",
    "section": "1. Arbres binaires",
    "text": "1. Arbres binaires\nUne interface souhaitable devrait permettre de :\n\nCréer un arbre vide ;\nAccéder au sous-arbre gauche et au sous-arbre droit d’un nœud ;\nAccéder à une clef ;\nTester si un nœud est une feuille ;\nTester si un arbre est vide ;\nRetourner la taille ;\nRetourner la hauteur.\n\nDe plus, il serait souhaitable de parvenir à afficher un arbre de façon visuelle.\nNous avons vu que la structure d’arbre binaire est une structure récursive : cette propriété est exploitée dans l’implémentation que nous allons présenter. Pour définir un arbre, il suffit de définir un nœud racine ainsi que les deux sous-arbres gauche et droite qui sont eux-même des arbres binaires. Cela revient à assimiler un arbre à sa racine associée à un lien vers ses deux fils.\nNous définissons ci-dessous un objet ArbreBinaire possédant trois attributs clef, gauche, droit. Pour respecter les principes de la POO, et notamment la notion d’encapsulation, nous avons défini des méthodes d’accès aux attributs (elles commencent par get) et des méthodes de modification des attributs (elles commencent par set) et on s’interdira tout accès ou affectation direct(e) du type arbre.racine = ....\nLa méthode setRacine, qui permet de définir la clef d’un nœud assure que chaque nœud a toujours un sous-arbre gauche et un sous-arbre droit, éventuellement vides, ce qui facilite le traitement des arbres dans les algorithmes suivants. On matérialise ici l’aspect récursif de la structure.\nclass ArbreBinaire:\n    \"\"\" Implémentation de la structure d'arbre binaire \"\"\"\n\n    def __init__(self):\n        self.racine = None\n        # les sous-arbres gauche et droit doivent être des \n        # instances de l'objet ArbreBinaire\n        self.gauche = None\n        self.droit = None\n\n    def setRacine(self, racine):\n        \"\"\"définit la clef de la racine de l'instance\n         et crée les sous arbres vides gauches et droits\"\"\"\n        self.racine = racine\n        if self.gauche is None:\n            self.gauche = ArbreBinaire()\n        if self.droit is None:\n            self.droit = ArbreBinaire()\n    \n    def getRacine(self):\n        \"\"\"retourne la clef de la racine de l'arbre\"\"\"\n        return self.racine\n\n    def getSousArbreGauche(self):\n        return self.gauche\n\n    def setSousArbreGauche(self, arbre):\n        if isinstance(arbre, ArbreBinaire):\n            self.gauche = arbre\n\n    def getSousArbreDroit(self):\n        return self.droit\n\n    def setSousArbreDroit(self, arbre):\n        if isinstance(arbre, ArbreBinaire):\n            self.droit = arbre\n\n    def estVide(self) -> bool:\n        return self.racine is None\n\n    def estFeuille(self) -> bool:\n        if self.estVide():\n            return False\n        else:\n            return self.gauche.estVide() and self.droit.estVide()\n\n    def __str__(self):\n        if self.estVide():\n            return \"()\"\n        elif self.estFeuille():\n            return f\"('{self.racine}', (), ())\"\n        else:\n            return f\"('{self.racine}', {self.gauche.__str__()}, {self.droit.__str__()})\"\nLa classe est complétée par une méthode estVide permettant de tester si un arbre est vide ou non et une méthode estFeuille permettant de tester si un nœud est une feuille ou non (on confond un nœud avec un arbre de hauteur 1).\nLa dernière méthode est la méthode spéciale __str__ qui définit la façon dont un arbre va être affiché par la fonction print. Ici, on a choisi un affichage sous forme de tuple du type (clef, sous-arbre gauche, sous-arbre droit).\nPour créer un module, on enregistre le code ci-dessus dans un fichier nommé par exemple structures.py.\nOn peut ensuite utiliser notre nouvelle structure dans un autre fichier Python (dans le même dossier), ou dans la console interactive, en important le module :\nfrom structures import *\n\na = ArbreBinaire()\na.setRacine(8)\na.getSousArbreGauche().setRacine(3)\na.getSousArbreDroit().setRacine(9)\nb = a.getSousArbreGauche()\nc = a.getSousArbreDroit()\nb.getSousArbreGauche().setRacine(7)\nb.getSousArbreDroit().setRacine(5)\nc.getSousArbreDroit().setRacine(1)\nprint(a)\nOn obtient en sortie :\n>>> (8, (3, (7, (), ()), (5, (), ())), (9, (), (1, (), ())))\nCela correspond à l’arbre représenté ci-dessous :\n\n\n\n\n\nOn peut tester les autres méthodes dans la console :\nprint(c)\n>>> (9, (), (1, (), ()))\nc.getSousArbreGauche().estVide()\n>>> True\nc.estFeuille()\n>>> False\nc.getSousArbreDroit().estFeuille()\n>>> True\nNous pouvons maintenant ajouter au fichier structures.py les deux fonctions suivantes (en dehors de la classe ArbreBinaire car ce ne sont pas des méthodes) qui retournent respectivement la taille et la hauteur d’un arbre binaire.\ndef taille(arbre) -> int:\n    \"\"\"Retourne la taille de l'arbre, càd son nombre de noeuds\"\"\"\n    if arbre.racine is None:\n        return 0\n    else:\n        return 1 + taille(arbre.gauche) + taille(arbre.droit)\n\ndef hauteur(arbre) -> int:\n    \"\"\"Retourne la hauteur de l'arbre\"\"\"\n    if arbre.racine is None:\n        return 0\n    else:\n        return 1 + max(hauteur(arbre.gauche), hauteur(arbre.droit))\nPrendre le temps de bien comprendre comment fonctionnent ces deux fonctions …\ntaille(a)\n>>> 6\nhauteur(a)\n>>> 3\nCe module structures sera utilisé en exercices et plus tard dans l’année lorsque nous étudierons les algorithmes sur les arbres."
  },
  {
    "objectID": "arbresgraphes/implementationArbres.html#arbres-binaires-de-recherche-abr",
    "href": "arbresgraphes/implementationArbres.html#arbres-binaires-de-recherche-abr",
    "title": "Implémentation des arbres en Python",
    "section": "2. Arbres binaires de recherche (ABR)",
    "text": "2. Arbres binaires de recherche (ABR)\nLes ABR sont des arbres binaires. Nous pouvons donc créer une classe ABR fille de la classe ArbreBinaire en utilisant la notion d’héritage et de polymorphisme de la POO (voir les compléments de cours à ce sujet). Nous définissons une méthode spécifique : l’insertion d’une clef. Cette méthode ajoute une clef à un ABR existant en s’assurant que l’arbre obtenu est toujours un ABR (le nouveau nœud est toujours une feuille).\nclass ABR(ArbreBinaire):\n    \"\"\" Implémentation de la structure d'arbre binaire de recherche \"\"\"\n\n    def __init__(self):\n        super().__init__()\n\n    def setRacine(self, racine):\n        \"\"\"définit la clef de la racine de l'instance\n         et crée les sous arbres vides gauches et droits\n         Provoque une erreur si la racine casse la structure d'ABR\"\"\"\n        self.racine = racine\n        if self.gauche is None:\n            self.gauche = ABR()\n        if self.droit is None:\n            self.droit = ABR()\n        if not estABR(self):\n            raise Exception(\"Cette affectation de clef casse la structure ABR !!!\")\n\n    def insere(self, racine):\n        \"\"\"insère une clef dans l'arbre en préservant la structure ABR\"\"\"\n        if self.racine is None:\n            self.racine = racine\n            self.gauche = ABR()\n            self.droit = ABR()\n        else:\n            if racine < self.racine:\n                self.gauche.insere(racine)\n            else:\n                self.droit.insere(racine)\nPour définir un arbre binaire de recherche valide, on utilisera toujours la méthode insere car elle permet de s’assurer de toujours conserver un ABR.\nPour faciliter la vérification, nous définissons une fonction estABR qui peut s’appliquer aussi bien à un arbre binaire quelconque qu’à un ABR et qui retourne True si l’arbre est un ABR et False sinon.\ndef estABR(arbre, mini=-float(\"inf\"), maxi=+float(\"inf\")) -> bool:\n    if arbre.getRacine() is None:\n        return True\n    else:\n        return estABR(arbre.getSousArbreGauche(), mini, arbre.getRacine()) and \n               estABR(arbre.getSousArbreDroit(), arbre.getRacine(), maxi) and \n               mini < arbre.racine < maxi\nPrendre le temps de bien comprendre cette fonction …\nUtilisation :\nfrom structures import *\n\na = ABR()\na.setRacine(8)\na.insere(5)\na.insere(3)\na.insere(12)\na.insere(10)\na.insere(15)\nprint(a)\nprint(estABR(a))\n# Affectation directe à proscrire :\n# a.getSousArbreDroit().setRacine(1) ## provoque une erreur\nSortie :\n(8, (5, (3, (), ()), ()), (12, (10, (), ()), (15, (), ())))\nTrue\nL’arbre correspond à :\n\n\n\n\n\nLe module structure.py est à conserver : il sera utilisé en exercices et dans les chapitres suivants.\n\n\n\n\n\n\nComplément\n\n\n\nOn peut ajouter une fonctionnalité de représentation graphique d’un arbre en utilisant les bibliothèques networkx et matplotlib. Ajouter la fonction ci-dessous au fichier structures.py :\nimport networkx as nx\nimport matplotlib.pyplot as plt\n\ndef afficheArbre(arbre, size=(4,4), null_node=False):\n\"\"\"\nsize : tuple de 2 entiers. Si size est int -> (size, size)\nnull_node : si True, trace les liaisons vers les sous-arbres vides\n\"\"\"\narbreAsTuple = eval(arbre.__str__())\ndef parkour(arbre, noeuds, branches, labels, positions, profondeur, \n            pos_courante, pos_parent, null_node):\n    if arbre != ():\n        noeuds[0].append(pos_courante)\n        positions[pos_courante] = (pos_courante, profondeur)\n        profondeur -= 1\n        labels[pos_courante] = str(arbre[0])\n        branches[0].append((pos_courante, pos_parent))\n        pos_gauche = pos_courante - 2 ** profondeur\n        parkour(arbre[1], noeuds, branches, labels, positions, profondeur, \n                pos_gauche, pos_courante, null_node)\n        pos_droit = pos_courante + 2 ** profondeur\n        parkour(arbre[2], noeuds, branches, labels, positions, profondeur, \n                pos_droit, pos_courante, null_node)\n    elif null_node:\n        noeuds[1].append(pos_courante)\n        positions[pos_courante] = (pos_courante, profondeur)\n        branches[1].append((pos_courante, pos_parent))\n\nif arbreAsTuple == ():\n    return\n\nbranches = [[]]\nprofondeur = hauteur(arbre)\npos_courante = 2 ** profondeur\nnoeuds = [[pos_courante]]\npositions = {pos_courante: (pos_courante, profondeur)}\nlabels = {pos_courante: str(arbreAsTuple[0])}\n\nif null_node:\n    branches.append([])\n    noeuds.append([])\n\nprofondeur -= 1\nparkour(arbreAsTuple[1], noeuds, branches, labels, positions, profondeur, \n        pos_courante - 2 ** profondeur, pos_courante, null_node)\nparkour(arbreAsTuple[2], noeuds, branches, labels, positions, profondeur, \n        pos_courante + 2 ** profondeur, pos_courante, null_node)\n\nmon_arbre = nx.Graph()\n\nif type(size) == int:\n    size = (size, size)\nplt.figure(figsize=size)\n\nnx.draw_networkx_nodes(mon_arbre, positions, nodelist=noeuds[0], \n                       node_color=\"white\", node_size=550, edgecolors=\"blue\")\nnx.draw_networkx_edges(mon_arbre, positions, edgelist=branches[0], \n                       edge_color=\"black\", width=2)\nnx.draw_networkx_labels(mon_arbre, positions, labels)\n\nif null_node:\n    nx.draw_networkx_nodes(mon_arbre, positions, nodelist=noeuds[1], \n                           node_color=\"white\", node_size=50, edgecolors=\"grey\")\n    nx.draw_networkx_edges(mon_arbre, positions, edgelist=branches[1], \n                           edge_color=\"grey\", width=1)\n\nax = plt.gca()\nax.margins(0.1)\nplt.axis(\"off\")\nplt.show()\nplt.close()\nUtilisation :\nfrom structures import *\n\na = ABR()\na.setRacine(8)\na.insere(5)\na.insere(3)\na.insere(12)\na.insere(10)\na.insere(15)\n\nafficheArbre(a)\nSortie :"
  },
  {
    "objectID": "arbresgraphes/tp_graphe_liste.html",
    "href": "arbresgraphes/tp_graphe_liste.html",
    "title": "TP - Implémentation des graphes par liste d’adjacence",
    "section": "",
    "text": "On considère un graphe \\(G\\) dont les sommets sont les entiers de \\(0\\) à \\(n-1\\) et les arêtes sont les couples d’entiers \\((i,j)\\) avec \\(0\\leq i,j\\leq n-1\\).\nL’objectif de ce TP est d’implémenter les graphes en python par liste d’adjacence.\nOn considère ici que les graphes sont non orientés."
  },
  {
    "objectID": "arbresgraphes/tp_graphe_liste.html#implémentation-objet",
    "href": "arbresgraphes/tp_graphe_liste.html#implémentation-objet",
    "title": "TP - Implémentation des graphes par liste d’adjacence",
    "section": "1. Implémentation objet",
    "text": "1. Implémentation objet\nCréer une classe Graph qui permet de représenter un graphe par liste d’adjacence.\nLa classe Graph doit contenir les attributs suivants :\n\norder : le nombre de sommets du graphe\nliste : une liste de listes d’entiers représentant la liste d’adjacence du graphe\n\nLa classe Graph doit contenir les méthodes suivantes :\n\n__init__ : initialise un graphe vide de taille order\nadd_edge : ajoute l’arête \\((i,j)\\) au graphe\nremove_edge : supprime l’arête \\((i,j)\\) du graphe\nadd_vertex : ajoute un sommet au graphe\nremove_vertex : supprime le sommet i du graphe\nis_adjacent : retourne True si les sommets i et j sont adjacents, False sinon\nneighbors : retourne la liste des voisins du sommet i\ndegree : retourne le degré du sommet i\n__str__ : retourne une chaîne de caractères représentant le graphe (afficher sur chaque ligne le numéro du sommet suivi de la liste de ses voisins)\ndraw : dessine le graphe (s’inspirer du TP précédent !)\n\n\nimport networkx as nx\n\nclass Graph:\n\n    def __init__(self, n):\n        self.order = n\n        self.liste = [[] for i in range(n)]\n\n    def add_edge(self, u, v):\n        self.liste[u].append(v)\n        self.liste[v].append(u)\n    \n    def remove_edge(self, u, v):\n        self.liste[u].remove(v)\n        self.liste[v].remove(u)\n    \n    def add_vertex(self):\n        self.liste.append([])\n        self.order += 1\n    \n    def remove_vertex(self, u):\n        for v in self.liste[u]:\n            self.liste[v].remove(u)\n        self.liste.pop(u)\n        self.order -= 1\n    \n    def is_adjacent(self, u, v):\n        return v in self.liste[u]\n    \n    def neighbors(self, u):\n        return self.liste[u]\n    \n    def degree(self, u):\n        return len(self.liste[u])\n    \n    def __str__(self):\n        rep = \"\"\n        for i in range(self.order):\n            rep += str(i) + \" : \" + str(self.liste[i]) + \"\\n\"\n        return rep\n    \n    def draw(self):\n        G = nx.Graph()\n        G.add_nodes_from(range(self.order))\n        for i in range(self.order):\n            for j in self.liste[i]:\n                G.add_edge(i, j)\n        nx.draw(G, with_labels=True, node_color='white', font_size=18, edgecolors='black', node_size=500)\n\n\n# Exemple d'utilisation\n\ng = Graph(5)\ng.add_edge(0, 3)\ng.add_edge(1, 2)\ng.add_edge(1, 4)\ng.add_edge(2, 3)\ng.add_edge(2, 4)\ng.add_edge(3, 4)\nprint(g)\ng.draw()\n\n0 : [3]\n1 : [2, 4]\n2 : [1, 3, 4]\n3 : [0, 2, 4]\n4 : [1, 2, 3]"
  },
  {
    "objectID": "arbresgraphes/tp_graphe_liste.html#passage-dune-représentation-à-lautre",
    "href": "arbresgraphes/tp_graphe_liste.html#passage-dune-représentation-à-lautre",
    "title": "TP - Implémentation des graphes par liste d’adjacence",
    "section": "Passage d’une représentation à l’autre",
    "text": "Passage d’une représentation à l’autre\nOn considère un graphe \\(G\\) représenté par liste d’adjacence. On souhaite passer à une représentation par matrice d’adjacence.\nCompléter la fonction list_to_matrix qui prend en paramètre une liste d’adjacence d’un graphe G et retourne la matrice d’adjacence représentant le graphe.\n\ndef list_to_matrix(liste):\n    n = len(liste)\n    mat = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        for j in liste[i]:\n            mat[i][j] = 1\n            mat[j][i] = 1\n    return mat\n\n\n# Test de la fonction list_to_matrix\nmatrice = list_to_matrix(g.liste)\nassert matrice == [[0, 0, 0, 1, 0], [0, 0, 1, 0, 1], [0, 1, 0, 1, 1], [1, 0, 1, 0, 1], [0, 1, 1, 1, 0]]\nprint(\"Test réussi !\")\n\nTest réussi !\n\n\nOpération inverse : compléter la fonction matrix_to_list qui prend en paramètre une matrice d’adjacence d’un graphe G et retourne la liste d’adjacence représentant le graphe.\n\ndef matrix_to_list(matrice):\n    n = len(matrice)\n    liste = [[] for i in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if matrice[i][j] == 1:\n                liste[i].append(j)\n    return liste\n\n\n# Test de la fonction matrix_to_list\nliste = matrix_to_list(matrice)\nassert liste == [[3], [2, 4], [1, 3, 4], [0, 2, 4], [1, 2, 3]]\nprint(\"Test réussi !\")\n\nTest réussi !"
  },
  {
    "objectID": "arbresgraphes/arbres_cours.html",
    "href": "arbresgraphes/arbres_cours.html",
    "title": "Arbres (Cours)",
    "section": "",
    "text": "Définition\n\n\n\nEn informatique, un arbre est une structure de données qui peut se représenter sous forme d’une hiérarchie dont chaque élément est appelé nœud, le nœud initial étant appelé racine.\n\n\n\n\n\n\n\n\n\n\n\n\n\nVocabulaire\n\n\n\n\nChaque nœud a exactement un nœud père, sauf le nœud racine (situé en haut) qui n’a pas de père.\nUn nœud peut avoir une nombre quelconque de fils.\nLes nœuds qui n’ont pas de fils sont appelés des feuilles (situées aux extrémités des branches !).\nLes nœuds possèdent une valeur, ou clef, ou encore étiquette.\n\n\n\nPar exemple, dans l’arbre représenté ci-dessus :\n\n\n\n\n\n\nExemple\n\n\n\n\nLa racine possède l’étiquette D.\nLe nœud père D a trois fils U, L et A.\nLe nœud V a pour père le nœud A.\nLes nœuds C, L et X sont des feuilles.\n\n\n\n\n\n\n\nVoici quelques exemples de situations dans lesquelles une structure de données arborescente est utile.\n\n\nDéjà rencontrée dans le chapitre sur les systèmes d’exploitation en première, une arborescence de dossiers dans un disque dur peut être modélisée par un arbre.\n\n\n\n\n\n\n\n\nLE DOM (Document Object Model) est une interface de programmation pour les pages web dans laquelle une page HTML est modélisée sous la forme d’un arbre.\nPar exemple, le code HTML ci-dessous sera modélisé par l’arbre en-dessous (source : w3.org).\n<TABLE>\n    <ROWS> \n      <TR> \n        <TD>Shady Grove</TD>\n        <TD>Aeolian</TD> \n      </TR> \n      <TR>\n        <TD>Over the River, Charlie</TD>\n        <TD>Dorian</TD> \n      </TR> \n    </ROWS>\n</TABLE>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDifférents paramètres numériques peuvent être définis concernant un arbre.\n\n\n\n\n\n\nDéfinitions\n\n\n\n\nLa taille d’un arbre est son nombre total de nœuds.\nLa profondeur d’un nœud est le nombre de nœuds de la branche allant de la racine à ce nœud, en comptant les extrémités.\nLa hauteur d’un arbre est la profondeur de son nœud le plus profond. Par convention, si l’arbre est vide, sa hauteur vaut 0, si l’arbre n’est composé que d’un nœud racine, sa hauteur vaut 1.\n\n\n\n\n\n\n\n\n\nExemple\n\n\n\nConsidérons l’arbre ci-dessous :\n\n\n\n\n\n\nLa taille de cet arbre est égale à 7.\nLa profondeur du nœud C est égale à 3, celle de X est égale à 4.\nLa hauteur de cet arbre est égale à 4 : X est le nœud le plus profond."
  },
  {
    "objectID": "arbresgraphes/arbres_cours.html#arbres-binaires",
    "href": "arbresgraphes/arbres_cours.html#arbres-binaires",
    "title": "Arbres (Cours)",
    "section": "2. Arbres binaires",
    "text": "2. Arbres binaires\n\n2.1. Définition\n\n\n\n\n\n\nDéfinition\n\n\n\nUn arbre binaire est un arbre dans lequel chaque nœud possède au plus deux fils au niveau inférieur, appelés gauche et droite.\n\n\nL’arbre donné en exemple ci-dessus n’est pas un arbre binaire car le nœud D possède 3 fils.\nL’arbre ci-dessous est un arbre binaire :\n\n\n\n\n\n\n\n2.2. Sous-arbres\nChaque nœud n’ayant que deux fils (au maximum), nous pouvons définir un sous-arbre gauche et un sous-arbre droit qui sont tous les deux également des arbres binaires (éventuellement vides).\n\n\n\n\n\n\n\n\n\n\n\nExemple\n\n\n\nPour l’arbre représenté ci-dessous, nous avons mis en évidence le sous-arbre gauche et le sous-arbre droit du nœud racine C.\nLe nœud Q admet comme sous-arbre gauche le nœud H et comme sous-arbre droit, l’arbre vide.\n\n\nCette notion de sous arbre permet de mettre en évidence la structure récursive d’un arbre binaire : un arbre binaire est un arbre dans lequel chaque nœud possède un arbre fils gauche et un arbre fils droit qui sont tous deux des arbres binaires.\n\n\n2.3. Hauteur d’un arbre binaire\nNous avons défini plus haut les notions de taille et de hauteur d’un arbre.\nNotons ici \\(n\\) la taille d’un arbre binaire et \\(h\\) sa hauteur. Ces deux entiers ne sont pas indépendants l’un de l’autre.\nUn cas extrême est le cas de l’arbre filiforme dans lequel chaque nœud n’a qu’un fils. La figure ci-dessous est réalisée avec \\(n=7\\).\n\n\n\n\n\nDans ce cas, nous avons \\(n=h\\) : la hauteur de l’arbre est égale au nombre de nœuds de l’arbre.\nUn autre cas “extrême” est le cas d’un arbre complet : il s’agit d’un arbre binaire dans lequel tous les nœuds (sauf les feuilles) ont exactement deux fils et toutes les feuilles ont la même profondeur. La figure ci-dessous représente un arbre complet à 7 nœuds.\n\n\n\n\n\nDans un tel arbre, le nombre de nœuds est doublé à chaque niveau. Si la hauteur est \\(h\\), le nombre total de nœuds est donc égal à :\n\\[n=1+2^1+2^2+2^3+\\ldots+2^{h-1}\\]\n(on numérote les niveaux de \\(0\\) à \\(h-1\\))\nOn obtient donc le résultat suivant :\n\n\n\n\n\n\nLien entre hauteur et taille d’un arbre binaire complet\n\n\n\nSoit un arbre binaire complet de taille \\(n\\) et de hauteur \\(h\\).\nOn a alors :\n\\[n=2^h-1\\]\n\n\n\n\n\n\n\n\nPreuve\n\n\n\n\n\nNous avons vu que \\(n=1+2^1+2^2+2^3+\\ldots+2^{h-1}\\). Cette somme est la somme des premiers termes d’une suite géométrique de raison 2.\nOn peut donc utiliser la formule de calcul vue en première en Mathématiques :\n\\[1+2^1+2^2+2^3+\\ldots+2^{h-1} = \\frac{2^h-1}{2-1}=2^h-1\\]\nPour ceux qui n’auraient jamais vu cette formule, sa preuve n’est pas difficile : il suffit de calculer le produit \\((2-1)(1+2^1+2^2+2^3+\\ldots+2^{h-1})\\) en développant :\n\\[(2-1)(1+2^1+2^2+2^3+\\ldots+2^{h-1})= 2^1+2^2+2^3+\\ldots+2^{h} -1-2^1-2^2-2^3-\\ldots-2^{h-1}\\]\nTous les termes s’annulent sauf \\(2^{h}\\) et \\(-1\\), d’où le résultat.\n\n\n\nTout arbre étant situé entre ces deux cas extrêmes, nous pouvons écrire un encadrement du nombre de nœuds \\(n\\) en fonction de la hauteur \\(h\\), valable pour tout arbre binaire :\n\\[h\\leqslant n\\leqslant 2^h-1\\]\nÀ partir de cet encadrement de \\(n\\), on peut déduire un encadrement de \\(h\\). Nous avons déjà de façon évidente \\(h\\leqslant n\\). La seconde inégalité \\(n\\leqslant 2^h-1\\) est équivalente à \\(n+1\\leqslant 2^h\\).\nPour isoler \\(h\\) dans cette inégalité, nous avons besoin de la fonction logarithme binaire. Le logarithme binaire d’un entier positif est son exposant quand on l’écrit sous la forme d’une puissance de 2. Par exemple \\(\\log_2(8)=3\\) car \\(2^3=8\\) et \\(\\log_2(2^h)=h\\). Cette fonction \\(\\log_2\\) étant intuitivement croissante, nous obtenons, en l’appliquant à l’inégalité \\(n+1\\leqslant 2^h\\) : \\(\\log_2(n+1)\\leqslant h\\).\nNous avons finalement l’encadrement suivant :\n\n\n\n\n\n\nEncadrement de la hauteur d’un arbre binaire\n\n\n\nSoit un arbre binaire de taille \\(n\\) et de hauteur \\(h\\).\nOn a alors :\n\\[\\log_2(n+1)\\leqslant h\\leqslant n\\]\n\n\nCet encadrement nous sera utile lors du calcul du coût d’exécution des algorithmes sur les arbres."
  },
  {
    "objectID": "arbresgraphes/arbres_cours.html#arbres-binaires-de-recherche",
    "href": "arbresgraphes/arbres_cours.html#arbres-binaires-de-recherche",
    "title": "Arbres (Cours)",
    "section": "3. Arbres binaires de recherche",
    "text": "3. Arbres binaires de recherche\n\n\n\n\n\n\nDéfinition\n\n\n\nUn arbre binaire de recherche (ABR) est un arbre binaire dont les clefs des nœuds (leur valeur) vérifient les propriétés suivantes :\n\nla clef d’un nœud est supérieure à celle de chaque nœud de son sous-arbre gauche.\nla clef d’un nœud est inférieure à celle du chaque nœud de son sous-arbre droit.\n\n\n\nCette définition n’a de sens que dans le cas où les clefs des nœuds sont toujours comparables entre elles. Dans la pratique, nous travaillerons toujours avec des clefs numériques ou alphanumériques (ordre alphabétique).\nNous supposerons toujours que toutes les clefs sont différentes.\n\n\n\n\n\n\n\n\n\n\n\nRemarque\n\n\n\nDans un ABR, pour un nœud donné, tous les nœuds de son sous-arbre gauche ont des clefs inférieures et tous les nœuds de son sous-arbre droit ont des clefs supérieures."
  },
  {
    "objectID": "arbresgraphes/graphes_exercices.html",
    "href": "arbresgraphes/graphes_exercices.html",
    "title": "Exercices sur les graphes",
    "section": "",
    "text": "Les exercices précédés du symbole  sont à faire sur machine, en sauvegardant le fichier si nécessaire.\nLes exercices précédés du symbole  doivent être résolus par écrit."
  },
  {
    "objectID": "arbresgraphes/graphes_exercices.html#fa-solid-pencil-alt-exercice-1",
    "href": "arbresgraphes/graphes_exercices.html#fa-solid-pencil-alt-exercice-1",
    "title": "Exercices sur les graphes",
    "section": " Exercice 1",
    "text": "Exercice 1\nOn dit qu’un graphe est simple s’il n’y a pas de boucle ni de double arête. Un graphe simple est dit complet s’il est non orienté et que chaque paire de sommets est reliée par une arête.\nDessiner un graphe complet d’ordre 3, puis un graphe complet d’ordre 4."
  },
  {
    "objectID": "arbresgraphes/graphes_exercices.html#fa-solid-pencil-alt-exercice-2",
    "href": "arbresgraphes/graphes_exercices.html#fa-solid-pencil-alt-exercice-2",
    "title": "Exercices sur les graphes",
    "section": " Exercice 2",
    "text": "Exercice 2\nDonner la matrice d’adjacence du graphe suivant :"
  },
  {
    "objectID": "arbresgraphes/graphes_cours.html",
    "href": "arbresgraphes/graphes_cours.html",
    "title": "Graphes (Cours)",
    "section": "",
    "text": "Définition\n\n\n\nUn graphe non orienté est constitué :\n\nd’un ensemble fini de sommets (représentés par des points) ;\nd’un ensemble d’arêtes (représentées par des traits) qui relient des sommets entre eux.\n\n\n\nLa figure ci-dessous représente un graphe dont les sommets sont numérotés de 0 à 6.\n\n\n\nFigure 1: Graphe non orienté\n\n\n\n\n\n\n\n\nDéfinition\n\n\n\nUn graphe orienté est constitué :\n\nd’un ensemble fini de sommets (représentés par des points) ;\nd’un ensemble d’arcs (représentés par des flèches) qui relient des sommets entre eux.\n\n\n\nLa figure ci-dessous représente un graphe orienté dont les sommets sont numérotés de 0 à 6.\n\n\n\nFigure 2: Graphe orienté\n\n\n\nUn peu de vocabulaire :\n\ndeux sommets reliés par une arête (ou un arc) sont dits adjacents, ou voisins ;\nun sommet est dit isolé s’il n’est relié à aucun autre sommet ;\nl’ordre d’un graphe est le nombre de ses sommets ;\nle degré d’un sommet \\(S\\), noté \\(deg(S)\\), est le nombre d’arêtes (ou d’arcs) qui le relient à d’autres sommets ;\n\n\n\n\nLa structure d’arbre déjà rencontrée dans le cours est un cas particulier de graphe non orienté.\n\n\n\n\n\n\nDéfinition\n\n\n\nUn arbre est un graphe non orienté qui satisfait les conditions suivantes :\n\nil est connexe ;\nil n’a pas de cycle.\n\n\n\nExplications : connexe signifie que tous les sommets sont reliés entre eux par un chemin (il n’y a pas de points isolés). pas de cycle signifie que l’on ne peut pas revenir au même sommet en passant par le même chemin.\nEn particulier le graphe ci-dessus (Figure 1) n’est pas un arbre, car il n’est pas connexe (le sommet 6 n’est pas relié au sommet 1) et il contient un cycle (le chemin 1-2-4-1).\n\n\n\nVoici quelques situations pouvant être modélisées par un graphe :\n\nun réseau routier ;\nun réseau de télécommunications ;\nun réseau social ;\nun réseau électrique ;"
  },
  {
    "objectID": "arbresgraphes/graphes_cours.html#implémentations-dun-graphe",
    "href": "arbresgraphes/graphes_cours.html#implémentations-dun-graphe",
    "title": "Graphes (Cours)",
    "section": "2. Implémentations d’un graphe",
    "text": "2. Implémentations d’un graphe\nL’objectif de cette section est de définir une structure de données en Python permettant de représenter un graphe.\nLes opérations suivantes doivent être possibles (cf. FORTIER (2022)):\n\ncréer un graphe vide ;\najouter un sommet ;\najouter une arête (ou un arc) ;\nsupprimer un sommet ;\nsupprimer une arête (ou un arc) ;\nvérifier si deux sommets sont adjacents ;\nconnaître la liste des sommets adjacents à un sommet donné.\n\nNous étudions deux implémentations : par matrice d’adjacence et par liste d’adjacence.\n\n2.1. Matrice d’adjacence\nRappel : une matrice est un tableau à deux dimensions, où chaque élément est identifié par un couple de coordonnées (ligne, colonne). En Python, on peut représenter une matrice par une liste de listes.\n\n\n\n\n\n\nDéfinition\n\n\n\nLa matrice d’adjacence d’un graphe \\(G\\) (orienté ou non) est une matrice carrée \\(A\\) de taille \\(n\\) telle que :\n\n\\(A_{i,j} = 1\\) si les sommets \\(i\\) et \\(j\\) sont adjacents ;\n\\(A_{i,j} = 0\\) si les sommets \\(i\\) et \\(j\\) ne sont pas adjacents.\n\n\n\nExemple : la matrice d’adjacence du graphe non orienté de la figure ci-dessus (Figure 1) est la suivante :\n\n\n\n\n\nGraphe Fig.1\n\n\n\n\\[\n\\begin{pmatrix}\n0 & 0 & 0 & 0 & 0 & 0 & 1 \\\\\n0 & 0 & 1 & 1 & 1 & 0 & 0 \\\\\n0 & 1 & 0 & 0 & 1 & 1 & 0\\\\\n0 & 1 & 0 & 0 & 1 & 0 & 0\\\\\n0 & 1 & 1 & 1 & 0 & 0 & 0\\\\\n0 & 0 & 1 & 0 & 0 & 0 & 0\\\\\n1 & 0 & 0 & 0 & 0 & 0 & 0\n\\end{pmatrix}\n\\]\n\n\n\nRemarques : dans le cas d’un graphe non orienté, la matrice d’adjacence est symétrique par rapport à la diagonale principale. Dans le cas d’un graphe orienté, la matrice d’adjacence n’est pas forcément symétrique.\n\n\n\n\n\n\nTP Python\n\n\n\nTP Python : implémentation des graphes par matrice d’adjacence\n\n\n\n\n\n2.2. Liste d’adjacence\n\n\n\n\n\n\nDéfinition : liste d’adjacence\n\n\n\nLa liste d’adjacence d’un graphe \\(G\\) (orienté ou non) dont les sommets sont les entiers compris entre 0 et \\(n-1\\) est une liste \\(L\\) de taille \\(n\\) telle que :\n\n\\(L[i]\\) est la liste des sommets adjacents au sommet \\(i\\).\n\n\n\nExemple : la liste d’adjacence du graphe non orienté de la figure ci-dessus (Figure 1) est la suivante :\n\n\n\n\n\nGraphe Fig.1\n\n\n\n\\[\n\\begin{array}{|c|c|}\n\\hline\n0 & [6] \\\\\n\\hline\n1 & [2,3,4] \\\\\n\\hline\n2 & [1,4,5] \\\\\n\\hline\n3 & [1,4] \\\\\n\\hline\n4 & [1,2,3] \\\\\n\\hline\n5 & [2] \\\\\n\\hline\n6 & [0] \\\\\n\\hline\n\\end{array}\n\\]\n\n\n\nDans le cas d’un graphe comportant peu d’arêtes, la liste d’adjacence occupe moins de mémoire que la matrice d’adjacence. Mais certaines opérations, comme la vérification de l’adjacence de deux sommets ou la suppression d’une arête, sont plus coûteuses en temps d’exécution.\n\n\n\n\n\n\nTP Python\n\n\n\nDans le TP ci-dessous, vous devez implémenter la structure de graphe par liste d’adjacence. Vous devez également implémenter les fonctions permettant de passer d’une représentation à l’autre.\nTP Python : implémentation des graphes par liste d’adjacence"
  },
  {
    "objectID": "arbresgraphes/index.html",
    "href": "arbresgraphes/index.html",
    "title": "Programme",
    "section": "",
    "text": "Contenus\nCapacités attendues\nCommentaires\n\n\n\n\nArbres : structures hiérarchiques. Arbres binaires : nœuds, racines, feuilles, sous-arbres gauches, sous-arbres droits.\nIdentifier des situations nécessitant une structure de données arborescente. Évaluer quelques mesures des arbres binaires (taille, encadrement de la hauteur, etc.).\nOn fait le lien avec la rubrique « algorithmique ».\n\n\n\n\n\n\n\n\n\n\n\nContenus\nCapacités attendues\nCommentaires\n\n\n\n\nGraphes : structures relationnelles. Sommets, arcs, arêtes, graphes orientés ou non orientés.\nModéliser des situations sous forme de graphes. Écrire les implémentations correspondantes d’un graphe : matrice d’adjacence, liste de successeurs/de prédécesseurs. Passer d’une représentation à une autre.\nOn s’appuie sur des exemples comme le réseau routier, le réseau électrique, Internet, les réseaux sociaux. Le choix de la représentation dépend du traitement qu’on veut mettre en place : on fait le lien avec la rubrique « algorithmique »."
  },
  {
    "objectID": "arbresgraphes/TParbres.html",
    "href": "arbresgraphes/TParbres.html",
    "title": "TP - Manipulation d’arbres",
    "section": "",
    "text": "Ce T.P. est à réaliser et à rendre dans Capytale.\n\nOuvrez le lien ci-dessus ;\nConnectez-vous avec vos identifiants ENT ;\nEntrez le code du TP : 15c9-991659\nCliquez sur “Go !”."
  },
  {
    "objectID": "arbresgraphes/arbres_exercices.html",
    "href": "arbresgraphes/arbres_exercices.html",
    "title": "Exercices sur les arbres",
    "section": "",
    "text": "Les exercices précédés du symbole  sont à faire sur machine, en sauvegardant le fichier si nécessaire.\nLes exercices précédés du symbole  doivent être résolus par écrit."
  },
  {
    "objectID": "arbresgraphes/arbres_exercices.html#fa-solid-pencil-alt-exercice-1",
    "href": "arbresgraphes/arbres_exercices.html#fa-solid-pencil-alt-exercice-1",
    "title": "Exercices sur les arbres",
    "section": " Exercice 1",
    "text": "Exercice 1\nOn considère l’arbre binaire ci-dessous :\n\n\n\n\n\n\nDéterminer la profondeur du nœud 6.\nDéterminer la hauteur de cet arbre.\nExpliquer pourquoi cet arbre n’est pas un arbre binaire de recherche.\nModifier l’arbre (en conservant les mêmes clefs) pour en faire un ABR."
  },
  {
    "objectID": "arbresgraphes/arbres_exercices.html#fa-solid-pencil-alt-exercice-2",
    "href": "arbresgraphes/arbres_exercices.html#fa-solid-pencil-alt-exercice-2",
    "title": "Exercices sur les arbres",
    "section": " Exercice 2",
    "text": "Exercice 2\nOn considère l’arbre binaire ci-dessous :\n\n\n\n\n\n\nJustifier qu’il s’agit bien d’un arbre binaire.\nDonner la clef de la racine.\nDonner le sous-arbre droit du nœud A.\nLe nœud C est-il une feuille ? Justifier.\nDonner la taille de cet arbre.\nDonner la profondeur du nœud B.\nDonner la hauteur de cet arbre."
  },
  {
    "objectID": "arbresgraphes/arbres_exercices.html#fa-solid-pencil-alt-exercice-3",
    "href": "arbresgraphes/arbres_exercices.html#fa-solid-pencil-alt-exercice-3",
    "title": "Exercices sur les arbres",
    "section": " Exercice 3",
    "text": "Exercice 3\nSoit les valeurs suivantes : 14, 22, 8, 47, 42, 13, 1, 24, 33, 74.\nConstruire un arbre binaire de recherche à partir de ces valeurs."
  },
  {
    "objectID": "structures/files_cours.html",
    "href": "structures/files_cours.html",
    "title": "Files (Cours)",
    "section": "",
    "text": "Définition\n\n\n\nLa file, comme la liste et la pile, permet de stocker des données et d’y accéder. La différence se situe au niveau de l’ajout et du retrait d’éléments.\n\nLe prochain élément auquel on peut accéder est le premier élément ajouté à la structure ;\nLes nouveaux éléments viennent en bout de file : on ne pourra y accéder que lorsque tous les éléments ayant été ajoutés avant eux seront sortis de la file.\n\n\n\nOn parle de mode FIFO (First in, First out, en anglais, premier arrivé, premier sorti), c’est-à-dire que le premier élément ayant été ajouté à la structure sera le prochain élément auquel on accédera. Les derniers éléments ajoutés devront « attendre » que tous les éléments ayant été ajoutés avant eux soient sortis de la file. Contrairement aux listes, on ne peut donc pas accéder à n’importe quelle valeur de la structure (pas d’index).\nPour gérer cette contrainte, la pile est caractérisée par deux « emplacements » :\n\nla tête de file, sortie de la file (début de la structure), où les éléments sont retirés ;\nle bout de file, entrée de la file (fin de la structure), où les éléments sont ajoutés.\n\nOn peut s’imaginer une file d’attente, dans un cinéma par exemple. Les premières personnes à pouvoir acheter leur place sont les premières arrivées, et les nouveaux arrivants se placent au bout de la file.\n\n\n\n\n\nUne file est une collection de données. On appelle tête de file le premier élément de la structure et bout de file le dernier élément. Quand un élément est ajouté à la file, on l’ajoute en bout de file et il devient le nouveau bout de file c’est-à-dire l’élément « suivant » l’élément situé précédemment en bout de file. Quand un élément est retiré de la file, on le sélectionne à la tête de la file et la nouvelle tête est l’élément qui suivait l’ancienne tête. Lorsqu’on ajoute un élément à une file vide, celui-ci est donc à la fois la tête et le bout de la file.\n\n\n\n\n\n6 primitives constituent l’interface permettant de définir le type abstrait de données “file” :\n\ncreer(), qui crée une file vide ;\ntaille(file), qui permet de connaître le nombre d’éléments contenus dans la file ;\nest_vide(file), qui renvoie vrai si la file est vide, faux sinon ;\nenfiler(file, element), qui ajoute un élément au bout de la file (et devient le nouveau bout de file) ;\ndefiler(file), qui retire et renvoie l’élément situé à la tête de la file (la nouvelle tête devient l’élément qui suivait l’ancienne tête) ;\ntete(file), qui renvoie l’élément situé à la tête de la file (sans le retirer).\n\nEnfiler se dit enqueue en anglais et défiler se dit dequeue.\n\n\n\n\n\n\nLa file est utile dans différents types de problèmes\n\n\n\n\npour une imprimante, gestion de la file d’attente des documents à imprimer ;\nmodélisation du jeu de la bataille (on révèle la carte au-dessus du paquet et on place celles gagnées en dessous…) ;\ngestion de mémoires tampon, pour gérer les flux de lecture et d’écriture dans un fichier, par exemple ;\nmatérialisation d’une file d’attente, pour un logiciel (visioconférence par exemple) ou un jeu (gestion des connexions des utilisateurs, des tours de jeu…),…\nalgorithme du parcours en largeur pour les arbres et les graphes, par exemple, pour trouver le plus court trajet sur une carte, ou récupérer les valeurs d’une structure dans l’ordre croissant.. (voir séquence 6).\n\n\n\n\n\n\n\n\n\nExemple\n\n\n\nSupposons implémenté le type abstrait file. Nous disposons d’une interface composée des six primitives décrites ci-dessus. On considère une file F composée des éléments suivants : 12, 14, 8, 7, 19 et 22 (la tête = premier élément entré dans la file est 22, le dernier élément entré est 12). On exécute le code suivant ligne par ligne :\n    enfiler(F,42)\n    defiler(F)\n    defiler(F)\n    taille(F)\n    estVide(F)\n    tete(F)\n\nL’exécution de la ligne 1 ajoute l’élément 42 au bout de la file qui contient alors 42, 12, 14, 8, 7, 19, 22 ;\nL’exécution de la ligne 2 affiche 22 et retire cet élément de la file qui contient maintenant 42, 12, 14, 8, 7, 19 ;\nL’exécution de la ligne 3 affiche 19 et retire cet élément de la file qui contient maintenant 42, 12, 14, 8, 7 ;\nLa ligne 4 renvoie la taille de F : 5 ;\nLa file n’est pas vide, on obtient dont False."
  },
  {
    "objectID": "structures/files_cours.html#du-point-de-vue-concepteur-implémentations",
    "href": "structures/files_cours.html#du-point-de-vue-concepteur-implémentations",
    "title": "Files (Cours)",
    "section": "2. Du point de vue concepteur : implémentation(s)",
    "text": "2. Du point de vue concepteur : implémentation(s)\nL’implémentation utilisant des listes Python est possible, mais l’opération defiler() est inefficace dans ce cas (on a une complexité en \\(\\mathcal{O}(n)\\)).\nNous allons tout d’abord étudier une implémentation utilisant deux piles.\n\nImplémentation utilisant deux piles\nComme le programme le suggère, il est possible d’implanter une file en utilisant deux piles. Le procédé est le suivant :\n\nla file est, au départ, composée de deux piles vides ;\nla première pile est une pile dite « d’entrée » et la seconde « de sortie » ;\nquand on ajoute un élément dans la file, on le place dans la pile « d’entrée » ;\nQuand on retire (ou qu’on accède) au premier élément de la file, on a deux cas :\n\nsoit la pile « de sortie » est vide et on dépile chaque élément de la pile « d’entrée » pour les empiler immédiatement dans la pile « de sortie » ;\nsoit il y a au moins un élément dans la pile « de sortie », auquel cas on ne fait rien de plus.\nEnfin, on sélectionne le sommet de la pile « de sortie » ;\n\ncomme il y a deux piles, la taille de la file (et le fait qu’elle soit vide ou non) doit se baser sur les éléments contenus dans les deux piles.\n\n\n\n\n\n\nDans notre implémentation, on propose de matérialiser la file sous la forme d’un tuple contenant deux piles, crées (et manipulées) avec les méthodes du module modélisant le type abstrait de données pile en utilisant les listes Python, définit plus tôt dans la section sur les piles. Ce module, nommé piles.py sera importé dans le présent fichier. On introduit également une nouvelle méthode « transferer » qui sert à effectuer le transfert entre les piles (si nécessaire) avant de retirer ou de récupérer le premier élément de la file.\nimport piles\n\n\"\"\"Implémentation du type abstrait \"file\" avec deux piles\"\"\"\n\n\ndef creer_file():\n    \"\"\"Retourne une file vide\"\"\"\n    pile_in = piles.creer()\n    pile_out = piles.creer()\n    return (pile_in, pile_out)\n\n\ndef taille_file(file):\n    \"\"\"Retourne le nombre d'éléments dans la file\"\"\"\n    return piles.taille(file[0]) + piles.taille(file[1])\n\n\ndef est_vide_file(file):\n    \"\"\"Retourne True si la file est vide, False sinon\"\"\"\n    return piles.est_vide(file[0]) and piles.est_vide(file[1])\n\n\ndef enfiler(file, element):\n    \"\"\"Ajoute un nouvel élément à l'arrière de la file\"\"\"\n    piles.empiler(file[0], element)\n\n\ndef transferer(file):\n    \"\"\"Transfère les éléments de la pile d'entrée vers la pile de sortie\"\"\"\n    while piles.taille(file[0]) != 0:\n        item = piles.depiler(file[0])\n        piles.empiler(file[1], item)\n\n\ndef defiler(file):\n    \"\"\"Retourne l'élément situé en tête de la file et le supprime de la file\"\"\"\n    if taille_file(file) == 0:\n        return None\n    else:\n        if piles.sommet(file[1]) is None:\n            transferer(file)\n        return file[1].pop()\n\n\ndef tete_file(file):\n    \"\"\"Retourne l'élément situé en tête de la file\"\"\"\n    if taille_file(file) == 0:\n        return None\n    else:\n        if piles.sommet(file[1]) is None:\n            transferer(file)\n        return piles.sommet(file[1])\nCette implémentation sera testée en exercices.\n\n\nImplémentation utilisant la POO\nOn reprend l’idée du chaînon, mais cette fois-ci, un chaînon est lié à son élément précédent dans la file, et non à son élément suivant : en effet, quand un élément sort de la file, c’est le précédent qui prend la tête.\n\"\"\"\"Implémentation du type abstrait file en POO\"\"\"\n\n\nclass Chainon:\n    def __init__(self, element=None, precedent=None):\n        \"\"\"element est la valeur du chainon et precedent est le chainon qui suit\"\"\"\n        self.element = element\n        self.precedent = precedent\n\n\nclass File():\n    def __init__(self):\n        self.front = None\n        self.back = None\n\n    def taille(self) -> int:\n        \"\"\"Retourne le nombre d'éléments dans la file\"\"\"\n        long = 0\n        chainon = self.front\n        while chainon is not None:\n            chainon = chainon.precedent\n            long = long + 1\n        return long\n\n    def est_vide(self) -> bool:\n        \"\"\"Retourne True si la file est vide et False sinon\"\"\"\n        return self.front is None\n\n    def enfiler(self, element):\n        \"\"\"Ajoute un nouvel élément à l'arrière de la file\"\"\"\n        new_back = Chainon(element, None)   # Création d'un nouveau chaînon\n        if self.taille() == 0:\n            # dans ce cas la file est vide et la tête est la queue\n            self.front = new_back\n        else:\n            self.back.precedent = new_back    # On relie l'ancien dernier élément au nouveau\n        self.back = new_back    # On définit le nouveau dernier élément\n\n    def defiler(self):\n        \"\"\"Retourne l'élément situé en tête de la file et le supprime de la file\"\"\"\n        item = self.front.element\n        self.front = self.front.precedent\n        return item\n\n    def tete(self):\n        \"\"\"Retourne l'élément situé en tête de la file\"\"\"\n        return self.front.element\n\n    def __str__(self):\n        chainon = self.front\n        res = str(chainon.element)\n        while chainon.precedent is not None:\n            res = \" <-- \" + res\n            chainon = chainon.precedent\n            res = str(chainon.element) + res\n        return res\nLa méthode enfiler demande un peu d’attention et doit être bien comprise.\nExemple d’utilisation de cette interface en console :\n>>> a = File()\n>>> a.taille()\n0\n>>> a.est_vide()\nTrue\n>>> for k in range(5):\n        a.enfiler(10*k)\n>>> a.est_vide()\nFalse\n>>> a.taille()\n5\n>>> print(a)\n40 <-- 30 <-- 20 <-- 10 <-- 0\n>>> a.tete()\n0\n>>> a.defiler()\n0\n>>> a.defiler()\n10\n>>> a.taille()\n3\n\n\n\n\n\n\nRemarque (extrait de la documentation Python)\n\n\n\nIl est également possible d’utiliser une liste comme une file, où le premier élément ajouté est le premier récupéré (« premier entré, premier sorti » ou FIFO pour first-in, first-out) ; toutefois, les listes ne sont pas très efficaces pour réaliser ce type de traitement. Alors que les ajouts et suppressions en fin de liste sont rapides, les insertions ou les retraits en début de liste sont lents (car tous les autres éléments doivent être décalés d’une position).\nPour implémenter une file, utilisez plutôt la classe collections.deque qui a été conçue spécialement pour réaliser rapidement les opérations d’ajout et de retrait aux deux extrémités. Par exemple :\n>>> from collections import deque\n>>> queue = deque([\"Eric\", \"John\", \"Michael\"])\n>>> queue.append(\"Terry\")           # Terry arrives\n>>> queue.append(\"Graham\")          # Graham arrives\n>>> queue.popleft()                 # The first to arrive now leaves\n'Eric'\n>>> queue.popleft()                 # The second to arrive now leaves\n'John'\n>>> queue                           # Remaining queue in order of arrival\ndeque(['Michael', 'Terry', 'Graham'])"
  },
  {
    "objectID": "structures/listes_exercices.html",
    "href": "structures/listes_exercices.html",
    "title": "Listes, Piles et Files (Exercices)",
    "section": "",
    "text": "Les exercices précédés du symbole  sont à faire sur machine, en sauvegardant le fichier si nécessaire.\nLes exercices précédés du symbole  doivent être résolus par écrit."
  },
  {
    "objectID": "structures/listes_exercices.html#fa-desktop-exercice-1-listes",
    "href": "structures/listes_exercices.html#fa-desktop-exercice-1-listes",
    "title": "Listes, Piles et Files (Exercices)",
    "section": " Exercice 1 (listes)",
    "text": "Exercice 1 (listes)\nOn reprend l’implémentation des listes avec des tuples présentée dans le cours.\nPrévoir l’effet et l’affichage en console des instructions suivantes, puis vérifier en exécutant ces instructions dans la console interactive après avoir créé et importé un fichier contenant le code du cours :\n>>> L = creer()\n>>> est_vide(L)\n>>> L = ajouter(5, ajouter(4, ajouter(3, ajouter(2, ajouter(1, ajouter(0,()))))))\n>>> est_vide(L)\n>>> longueur(L)\n>>> L = ajouter(6,L)\n>>> longueur(L)\n>>> tete(L)\n>>> queue(L)\n>>> longueur(queue(L))"
  },
  {
    "objectID": "structures/listes_exercices.html#fa-solid-pencil-alt-exercice-2-listes",
    "href": "structures/listes_exercices.html#fa-solid-pencil-alt-exercice-2-listes",
    "title": "Listes, Piles et Files (Exercices)",
    "section": " Exercice 2 (listes)",
    "text": "Exercice 2 (listes)\nSoit la suite d’instructions suivantes :\nL = creer()\nL = ajouter(2, ajouter(15, ajouter (23, L)))\nL1 = queue(L)\na = tete(L1)\nL1 = ajouter(4, ajouter(3, L1))\nDonnez le contenu des listes L et L1 et la valeur de a."
  },
  {
    "objectID": "structures/listes_exercices.html#fa-solid-pencil-alt-exercice-3-piles",
    "href": "structures/listes_exercices.html#fa-solid-pencil-alt-exercice-3-piles",
    "title": "Listes, Piles et Files (Exercices)",
    "section": " Exercice 3 (piles)",
    "text": "Exercice 3 (piles)\nSoit une pile P initialement vide. Soit les instructions suivantes (implémentation des piles avec des listes Python) :\n>>> empiler(P,4)\n>>> empiler(P,7)\n>>> a = depiler(P)\n>>> b = taille(P)\n>>> c = depiler(P)\n>>> empiler(P,3)\n>>> empiler(P,2)\n>>> d = taille(P)\nDonnez le contenu de la pile P, la valeur de a, la valeur de b, la valeur de c et la valeur de d."
  },
  {
    "objectID": "structures/listes_exercices.html#fa-solid-pencil-alt-exercice-4-piles",
    "href": "structures/listes_exercices.html#fa-solid-pencil-alt-exercice-4-piles",
    "title": "Listes, Piles et Files (Exercices)",
    "section": " Exercice 4 (piles)",
    "text": "Exercice 4 (piles)\nSoit le programme Python suivant (on utilise l’implémentation des piles en POO) :\npile = Pile()\ntab = [5,8,6,1,3,7]\nfor k in tab:\n    pile.empiler(k)\npile.empiler(5)\npile.empiler(10)\npile.empiler(8)\npile.empiler(15)\nfor k in tab:\n    if k > 5:\n        pile.depiler()\nDonnez l’état de la pile pile après l’exécution de ce programme."
  },
  {
    "objectID": "structures/listes_exercices.html#fa-solid-pencil-alt-fa-desktop-exercice-5-piles",
    "href": "structures/listes_exercices.html#fa-solid-pencil-alt-fa-desktop-exercice-5-piles",
    "title": "Listes, Piles et Files (Exercices)",
    "section": "  Exercice 5 (piles)",
    "text": "Exercice 5 (piles)\nCe problème propose une application concrète des piles. Il s’agit d’écrire une fonction qui contrôle si une expression mathématique, donnée sous forme d’une chaîne de caractères, est bien parenthésée, c’est- à-dire s’il y a autant de parenthèses ouvrantes que de fermantes, et qu’elles sont bien placées\nPar exemple :\n\n(..(..)..) est bien parenthésée\n(…(..(..)…) ne l’est pas\n\nL’algorithme :\n\nOn crée une pile\nOn parcourt l’expression de gauche à droite.\nÀ chaque fois que l’on rencontre une parenthèse ouvrante “(” on l’empile\nSi on rencontre une parenthèse fermante ” ) ” et que la pile n’est pas vide on dépile ( sinon on retourne faux )\nÀ la fin la pile doit être vide…\n\n\nEn utilisant l’une des structures pile du cours, écrire une fonction verification(expr) qui vérifie si une expression mathématique passée en paramètre est correctement parenthésée.\nProposer un jeu de tests unitaires vérifiant le bon fonctionnement de la fonction.\nFaire en sorte que le programme tienne compte également des [."
  },
  {
    "objectID": "structures/listes_exercices.html#fa-solid-pencil-alt-exercice-6-files",
    "href": "structures/listes_exercices.html#fa-solid-pencil-alt-exercice-6-files",
    "title": "Listes, Piles et Files (Exercices)",
    "section": " Exercice 6 (files)",
    "text": "Exercice 6 (files)\nSoit une file F initialement vide. Soit les instructions suivantes :\nenfiler(F,6)\nenfiler(F,3)\na = defiler(F)\nenfiler(F,9)\nb = taille_file(F)\nenfiler(F,17)\nc = defiler(F)\nenfiler(F,2)\nd = taille_file(F)\nDonnez le contenu de la file F, la valeur de a, la valeur de b, la valeur de c et la valeur de d."
  },
  {
    "objectID": "structures/listes_exercices.html#fa-solid-pencil-alt-exercice-7-files",
    "href": "structures/listes_exercices.html#fa-solid-pencil-alt-exercice-7-files",
    "title": "Listes, Piles et Files (Exercices)",
    "section": " Exercice 7 (files)",
    "text": "Exercice 7 (files)\nSoit le programme Python suivant :\nfile = File()\ntab = [2,78,6,89,3,17]\nfile.enfiler(5)\nfile.enfiler(10)\nfile.enfiler(8)\nfile.enfiler(15)\nfor i in tab:\n    if i > 50:\n        file.defiler()\nDonnez l’état de la file file après l’exécution de ce programme"
  },
  {
    "objectID": "structures/listes_exercices.html#fa-solid-pencil-alt-exercices-tombés-au-bac",
    "href": "structures/listes_exercices.html#fa-solid-pencil-alt-exercices-tombés-au-bac",
    "title": "Listes, Piles et Files (Exercices)",
    "section": " Exercices tombés au bac",
    "text": "Exercices tombés au bac\n\n2021 Métropole Jour 1 : exo 2.\n2021 Centres étrangers Jour 2 : exo 1.\n2021 Centres étrangers Jour 1 : exo 5.\n2021 Amérique du Nord Jour1 : exo 5.\n2021 Sujet zéro : exo 1.\n2022 Centres étrangers Jour 1 : exo 2.\n2022 Métropole Jour 1 : exo 1.\n2022 Métropole Jour 2 : exo 2.\n2022 Mayotte Liban Jour 1 : exo 1.\n2022 Mayotte Liban Jour 2 : exo 1.\n2022 Amérique du Nord Jour 1 : exo 5."
  },
  {
    "objectID": "structures/index.html",
    "href": "structures/index.html",
    "title": "Programme",
    "section": "",
    "text": "Points du programme traités dans cette séquence :\n\n\n\n\n\n\n\n\nContenus\nCapacités attendues\nCommentaires\n\n\n\n\nStructures de données, interface et implémentation.\nSpécifier une structure de données par son interface. Distinguer interface et implémentation. Écrire plusieurs implémentations d’une même structure de données.\nL’abstraction des structures de données est introduite après plusieurs implémentations d’une structure simple comme la file (avec un tableau ou avec deux piles)\n\n\nListes, piles, files : structures linéaires. Dictionnaires, index et clé.\nDistinguer des structures par le jeu des méthodes qui les caractérisent. Choisir une structure de données adaptée à la situation à modéliser. Distinguer la recherche d’une valeur dans une liste et dans un dictionnaire.\nOn distingue les modes FIFO (first in first out) et LIFO (last in first out) des piles et des files."
  },
  {
    "objectID": "structures/listes_cours.html",
    "href": "structures/listes_cours.html",
    "title": "Listes (Cours)",
    "section": "",
    "text": "Attention !\n\n\n\nEn Première, nous avons utilisé le type de données list de Python pour représenter des tableaux de d’éléments de même type. Le vocabulaire propre à Python peut induire en erreur et amener à penser que le type “liste” est déjà connu. La structure list de Python réalise en fait l’implémentation du type abstrait de données “tableau dynamique” et doit être laissée de côté, malgré l’utilisation du même vocabulaire.\nCela ne nous empêchera pas d’implémenter le type abstrait de données liste en utilisant des structures de type list en Python."
  },
  {
    "objectID": "structures/listes_cours.html#du-point-de-vue-utilisateur-interface",
    "href": "structures/listes_cours.html#du-point-de-vue-utilisateur-interface",
    "title": "Listes (Cours)",
    "section": "1. Du point de vue utilisateur : interface",
    "text": "1. Du point de vue utilisateur : interface\n\n\n\n\n\n\nDéfinition\n\n\n\nUne liste est une structure de données qui permet de stocker des données et d’y accéder directement.\nC’est un type abstrait de données :\n\nlinéaire : les données sont stockées dans une structure unidimensionnelle ;\nindexé : chaque donnée est associée à une valeur ;\nordonné : les données sont présentées les unes après les autres.\n\n\n\nUne liste est une collection finie de données. On appelle tête le premier élément de la liste et queue la liste privée de son premier élément. Il est seulement possible d’ajouter et de lire une donnée en tête de la liste.\nL’interface minimale permettant de définir le type abstrait de données “liste” comporte cinq fonctions, qui sont appelées primitives :\n\ncreer(), qui crée une liste vide ;\najouter(element, liste), qui ajoute un élément en tête de liste ; ces deux première primitives peuvent parfois se regrouper en une seule ;\ntete(liste), qui renvoie la valeur de l’élément en tête de liste ;\nqueue(liste), qui renvoie la liste privée de son premier élément ;\nest_vide(liste), qui renvoie vrai si la liste est vide, faux sinon.\n\nCe type abstrait de données est non mutable (il n’y a pas de primitive permettant de modifier la valeur d’un élément de la liste).\nRemarque : on peut selon les besoins ajouter d’autres fonctions permettant par exemple de renvoyer la longueur d’une liste, de rechercher un élément ou d’accéder au ième élément …\n\n\n\n\n\n\nExemple\n\n\n\nSupposons implémenté le type abstrait liste. Nous disposons d’une interface composée des cinq primitives décrites ci-dessus. On exécute le code suivant ligne par ligne :\nL = creer()\nest_vide(L)\nL1 = ajouter(12, L)\nest_vide(L1)\nL1 = ajouter(15, L1)\nL1 = ajouter(1, ajouter(11,L1))\ntete(L1)\nL2 = queue(L1)\n\nLa ligne 1 créée une liste vide L ;\nLa ligne 2 affiche True car la liste L est vide ;\nAprès exécution de la ligne 3, la liste L1 contient l’élément unique 12 ;\nLa ligne 4 affiche False car la liste L1 n’est pas vide ;\nAprès exécution de la ligne 5, la liste L1 contient les éléments 12 et 15 ;\nLa ligne 6 montre que l’on peut composer les ajouts pour ajouter en une seule fois plusieurs éléments. Après exécution de la ligne 6, la liste L1 contient les éléments 12, 15, 11 et 1 ;\nLa ligne 7 affiche 1 : c’est la tête de la liste (il s’agit du dernier élément ajouté) ;\nLa ligne 8 définit une liste L2 égale à la queue de la liste L1. L2 contient donc les éléments 12, 15 et 11."
  },
  {
    "objectID": "structures/listes_cours.html#du-point-de-vue-concepteur-implémentations",
    "href": "structures/listes_cours.html#du-point-de-vue-concepteur-implémentations",
    "title": "Listes (Cours)",
    "section": "2. Du point de vue concepteur : implémentation(s)",
    "text": "2. Du point de vue concepteur : implémentation(s)\nNous allons implémenter le type abstrait “liste” en Python de deux façons différentes.\n\nImplémentation avec des tuples\nNous allons ici utiliser des tuples et la programmation fonctionnelle (rappel : fonctions pures, pas d’affectations, pas de boucles).\n\"\"\" Implémentation du type abstrait \"liste\" avec des tuples\"\"\"\n\n\ndef creer() -> tuple:\n    \"\"\"Retourne une liste vide\"\"\"\n    return ()\n\n\ndef ajouter(element: all, liste: tuple) -> tuple:\n    \"\"\"Retourne la liste avec l'élément ajouté en tête de liste\"\"\"\n    return (element, liste)\n\n\ndef est_vide(liste: tuple) -> bool:\n    \"\"\"Retourne True si la liste est vide et False sinon\"\"\"\n    return liste == ()\n\n\ndef tete(liste: tuple) -> all:\n    \"\"\"Retourne la tête de la liste\"\"\"\n    assert not est_vide(liste), \"Erreur : liste vide\"\n    return liste[0]\n\n\ndef queue(liste: tuple) -> tuple:\n    \"\"\"Retourne la queue de la liste\"\"\"\n    assert not est_vide(liste), \"Erreur : liste vide\"\n    return liste[1]\n\n\ndef longueur(liste: tuple) -> int:\n    \"\"\"Retourne le nombre d'éléments de la liste\"\"\"\n    if est_vide(liste):\n        return 0\n    else:\n        return 1 + longueur(liste[1])\nAvec cette représentation une liste est toujours un tuple à deux éléments dont le premier est la tête de la liste (le dernier élément ajouté) et le deuxième est la queue (c’est donc une liste).\n\\[L=(1, (11, (15, (12, ()))))\\]\nOn remarquera que la fonction longueur est codée sans boucle, mais de façon récursive, afin de correspondre au paradigme fonctionnel.\n\n\nImplémentation en POO\nConformément au programme, on se limite à une version naïve de la POO. On pourra à titre d’exercice reprendre cette implémentation en respectant les règles plus strictes édictées dans les compléments de cours sur la POO.\nOn définit ci-dessous une liste chaînée : chaque chaînon est constitué de l’élément qui fait partie de la liste et de la référence à l’élément suivant. C’est la classe Chainon qui implémente cette structure. L’objet Liste est défini à partir de son premier élément (tête) et ses primitives sont définies sous forme de méthodes.\n\"\"\"Implémentation du type abstrait liste en POO\"\"\"\n\n\nclass Chainon:\n    def __init__(self, element=None, suivant=None):\n        \"\"\"element est la valeur du chainon et suivant est le chainon qui suit\"\"\"\n        self.element = element\n        self.suivant = suivant\n\n\nclass Liste:\n    def __init__(self):\n        \"\"\"Crée une liste vide\"\"\"\n        self.head = Chainon()\n\n    def est_vide(self) -> bool:\n        \"\"\"Retourne True si la liste est vide et False sinon\"\"\"\n        return self.head.element is None\n\n    def ajouter(self, element):\n        \"\"\"Ajoute element en tête de la liste\"\"\"\n        self.head = Chainon(element, self.head)\n\n    def tete(self):\n        \"\"\"Retourne la valeur de la tête de la liste\"\"\"\n        return self.head.element\n\n    def queue(self):\n        \"\"\"Retourne la queue de la liste, c.-à-d. la liste privée de sa tête\"\"\"\n        new_liste = Liste()\n        new_liste.head = self.head.suivant\n        return new_liste\n\n    def longueur(self):\n        \"\"\"Retourne la longueur de la liste\"\"\"\n        long = 0\n        chainon = self.head\n        while chainon.element is not None:\n            chainon = chainon.suivant\n            long = long + 1\n        return long\nOn peut améliorer l’implémentation en redéfinissant les méthodes spéciales __len__ (qui permettra de taper len(L) au lieu de L.longueur()) et __str__ (qui permettra d’utiliser l’instruction print(L)).\n    def __len__(self):\n        return self.longueur()\n\n    def __str__(self):\n        rep = \"\"\n        chainon = self.head\n        while chainon.element is not None:\n            rep = rep + str(chainon.element) + \" --> \"\n            chainon = chainon.suivant\n        return rep[:-4]\n>>> L=Liste()\n>>> L.ajouter(11)\n>>> L.ajouter(12)\n>>> L.ajouter(13)\n>>> print(L)\n13 --> 12 --> 11"
  },
  {
    "objectID": "structures/piles_cours.html",
    "href": "structures/piles_cours.html",
    "title": "Piles (Cours)",
    "section": "",
    "text": "Définition\n\n\n\nLa pile est une structure de données qui permet de stocker des données et d’y accéder. Une pile se comporte comme une pile d’assiettes :\n\non ajoute des nouvelles assiettes au sommet de la pile ;\nquand on veut en retirer une, on est obligé de prendre celle située au sommet.\n\n\n\nOn parle de mode LIFO (Last In, First Out, en anglais, dernier arrivé, premier sorti), c’est-à-dire que le dernier élément ajouté à la structure sera le prochain élément auquel on accédera. Les premiers éléments ayant été ajoutés devront « attendre » que tous les éléments qui ont été ajoutés après eux soient sortis de la pile. Contrairement aux listes, on ne peut donc pas accéder à n’importe quelle valeur de la structure (pas d’index). Pour gérer cette contrainte, on définit le sommet de la pile qui caractérise l’emplacement pour ajouter ou retirer des éléments.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nL’interface suivante permet de définir le type abstrait de données pile :\n\ncreer(), qui crée une pile vide ;\ntaille(pile), qui permet de connaître le nombre d’éléments contenus dans la pile ;\nest_vide(pile), qui renvoie vrai si la pile est vide, faux sinon ;\nempiler(pile, element), qui ajoute un élément au sommet de la pile (qui devient le nouveau sommet) ;\ndepiler(pile), qui retire et renvoie l’élément situé au sommet de la pile (le nouveau sommet devient l’élément qui suivait l’ancien sommet) ;\nsommet(pile), qui renvoie l’élément situé au sommet de la pile (sans le retirer).\n\nL’opération d’empilement se dit “push” en anglais, l’opération de dépilement se dit “pop”.\n\n\n\n\n\n\nLa pile est utile dans différents types de problèmes\n\n\n\n\nalgorithme d’un navigateur pour pouvoir mémoriser les pages web et revenir en arrière (ou ré-avancer) sur certaines pages ;\nstocker des actions et les annuler (ou les réappliquer), sur l’ordinateur (fonction CTRL+Z, et CTRL+Y) ;\ncoder une calculatrice en notation polonaise inversée (voir exercices) ;\nalgorithme du parcours en profondeur pour les arbres et les graphes, par exemple, pour résoudre un labyrinthe, trouver un trajet sur une carte… (voir séquence 6) ;\nécrire des versions itératives de certains algorithmes récursifs (voir séquence 1) ;\nillustration du fonctionnement de la pile d’appels des fonctions lors de l’exécution d’un programme.\n\n\n\n\n\n\n\n\n\nExemple\n\n\n\nSupposons implémenté le type abstrait pile. Nous disposons d’une interface composée des six primitives décrites ci-dessus. On considère une pile P composée des éléments suivants : 12, 14, 8, 7, 19 et 22 (le sommet de la pile est 22). On exécute le code suivant ligne par ligne :\n    depiler(P)\n    empiler(P,42)\n    depiler(P)\n    taille(P)\n    estVide(P)\n\nL’exécution de la ligne 1 renvoie la valeur 22 et la pile est maintenant composée des éléments 12, 14, 8, 7 et 19 ;\nL’exécution de la ligne 2 place l’élément 42 au sommet de la pile ;\nL’exécution de la ligne 3 renvoie la valeur 42 et la pile est maintenant à nouveau composée des éléments 12, 14, 8, 7 et 19 ;\nLa ligne 4 renvoie la taille de P : 5 ;\nLa pile n’est pas vide, on obtient dont False."
  },
  {
    "objectID": "structures/piles_cours.html#du-point-de-vue-concepteur-implémentations",
    "href": "structures/piles_cours.html#du-point-de-vue-concepteur-implémentations",
    "title": "Piles (Cours)",
    "section": "2. Du point de vue concepteur : implémentation(s)",
    "text": "2. Du point de vue concepteur : implémentation(s)\n\nImplémentation avec listes Python\nPremière solution, on peut implémenter une pile en utilisant des listes Python. Cette solution est très facile, car les méthodes append et pop des objets de type list correspondent exactement aux primitives empiler et dépiler de la structure pile.\n\"\"\"Implémentation des piles avec des listes Python\"\"\"\n\n\ndef creer():\n    \"\"\"Retourne une pile vide\"\"\"\n    return []\n\n\ndef taille(pile):\n    \"\"\"Retourne le nombre d'éléments de la pile\"\"\"\n    return len(pile)\n\n\ndef est_vide(pile):\n    \"\"\"Retourne True si la pile est vide, False sinon\"\"\"\n    return pile == []\n\n\ndef empiler(pile, element):\n    \"\"\"Empile un nouvel élément au sommet de la pile\"\"\"\n    pile.append(element)\n\n\ndef depiler(pile):\n    \"\"\"Retourne l'élément situé au sommet de la pile\n    et le supprime de celle-ci\"\"\"\n    if not est_vide(pile):\n        return pile.pop()\n    else:\n        return None\n\n\ndef sommet(pile):\n    \"\"\"Retourne l'élément situé au sommet de la pile\"\"\"\n    if not est_vide(pile):\n        return pile[-1]\n    else:\n        return None\nCette implémentation sera testée en exercices.\n\n\nImplémentation en POO\nConformément au programme, on se limite à une version naïve de la POO. On pourra à titre d’exercice reprendre cette implémentation en respectant les règles plus strictes édictées dans les compléments de cours sur la POO.\nOn reprend l’idée de chaînon utilisée pour les listes.\n\"\"\"Implémentation du type abstrait pile en POO\"\"\"\n\n\nclass Chainon:\n    def __init__(self, element=None, suivant=None):\n        \"\"\"element est la valeur du chainon et suivant est le chainon qui suit\"\"\"\n        self.element = element\n        self.suivant = suivant\n\n\nclass Pile:\n    def __init__(self):\n        \"\"\"Crée une pile vide\"\"\"\n        self.summit = Chainon()\n\n    def taille(self):\n        \"\"\"Retourne le nombre d'éléments dans la pile\"\"\"\n        long = 0\n        chainon = self.summit\n        while chainon.element is not None:\n            chainon = chainon.suivant\n            long = long + 1\n        return long\n\n    def est_vide(self) -> bool:\n        \"\"\"Retourne True si la pile est vide et False sinon\"\"\"\n        return self.summit.element is None\n\n    def empiler(self, element):\n        \"\"\"Empile element qu sommet de la pile\"\"\"\n        self.summit = Chainon(element, self.summit)\n\n    def depiler(self):\n        \"\"\"Retourne l'élément situé au sommet de la pile\n        et le supprime de celle-ci\"\"\"\n        item = self.summit.element\n        self.summit = self.summit.suivant\n        return item\n\n    def sommet(self):\n        \"\"\"Retourne la valeur du sommet de la pile\"\"\"\n        return self.summit.element\n\nCette implémentation sera testée en exercices.\n\n\n\n\n\n\nComparaison des deux implémentations\n\n\n\nOn peut comparer en termes de temps d’exécution l’efficacité de ces deux implémentations.\nOn utilise pour cela la bibliothèque timeit présentée dans cet article.\nPour cela, on ajoute les lignes suivantes au code de la version “listes Python” :\nimport timeit\n\nma_pile = creer()\nprint(timeit.timeit('empiler(ma_pile,1)', number=10000000, globals=globals()))\non obtient :\n2.2605971000011778\net les lignes suivantes au code de la version “POO” :\nimport timeit\n\nma_pile = Pile()\nprint(timeit.timeit('ma_pile.empiler(1)', number=10000000, globals=globals()))\non obtient :\n7.292327400005888\nOn constate donc que la version utilisant les listes Python est beaucoup plus efficace. Cela s’explique notamment par le fait que l’implantation avec les listes Python repose sur une programmation avancée et optimisée, contrairement à l’implantation objet qui a été construite sans utiliser de structure externe.\nNéanmoins, on peut montrer que, dans les deux implémentations, les opérations d’empilement et de dépilement sont en \\(\\mathcal{O}(1)\\), ce qui signifie que le temps d’exécution ne dépend pas du nombre de données.\nL’utilisation des listes est la plus efficace. Néanmoins, l’implantation objet a pour avantage de montrer et d’assimiler le fonctionnement interne de cette structure. C’est donc un meilleur outil d’apprentissage des concepts."
  },
  {
    "objectID": "structures/interfaces_cours.html",
    "href": "structures/interfaces_cours.html",
    "title": "Interfaces et implémentations (Cours)",
    "section": "",
    "text": "Nous allons dans ce chapitre nous intéresser aux structures de données comme les listes, les piles, les files et les dictionnaires.\nLes dictionnaires ont déjà été rencontrés en première. Plus précisément, c’est l’implémentation du type abstrait “dictionnaire” en Python qui a été utilisée.\nToutes ces structures de données sont des types abstraits qui doivent être définis dans un langage de programmation pour pouvoir être utilisés.\n\n\n\n\n\n\nDéfinition\n\n\n\nImplémenter un algorithme, c’est le traduire dans un langage de programmation.\n\n\nPour un type abstrait donné, disons les dictionnaires, plusieurs implémentations sont possibles. Elles peuvent se différencier par leur rapidité d’exécution ou leur capacité à travailler avec des données de grande taille par exemple.\nUne fois implémenté, le type abstrait doit pouvoir être utilisé par un programmeur (utilisateur). Cet utilisateur n’a pas besoin de connaître comment le type “dictionnaire” a été concrètement implémenté dans le langage de programmation qu’il utilise. Par contre, il faut qu’il connaisse précisément les actions qu’i peut réaliser sur ce type de données.\nPar exemple, un dictionnaire associe à un ensemble de clés un ensemble de valeurs (ce sont les données) et permet notamment les opérations :\n\nd’ajout d’un couple clé-valeur ;\nde suppression d’une clé, et donc de la valeur correspondante ;\nde modification de la valeur associée à une clé et ;\nde recherche de la valeur correspondant à une clé.\n\nL’ensemble des fonctions (méthodes) associées à un type abstrait constitue son interface. Ces fonctions et leurs spécifications, permettent à l’utilisateur d’utiliser le type abstrait dans son programme.\nQuand on utilise une bibliothèque contenant l’implémentation de structures de données, l’ensemble de ces spécifications est nommée API (Application Programming Interface, Interface de Programmation en français).\n\n\n\n\n\n\nDéfinition (d’après Wikipedia)\n\n\n\nEn informatique, une interface de programmation (souvent désignée par le terme API pour Application Programming Interface) est un ensemble normalisé de classes, de méthodes, de fonctions et de constantes qui sert de façade par laquelle un logiciel offre des services à d’autres logiciels. Elle est offerte par une bibliothèque logicielle ou un service web, le plus souvent accompagnée d’une description qui spécifie comment des programmes consommateurs peuvent se servir des fonctionnalités du programme fournisseur.\n\n\nL’usage des bibliothèques permet à chaque programmeur d’ajouter des structures réalisant des types abstraits de données, cette implémentation n’étant pas nécessairement connue de l’utilisateur de la structure. Cette méthode de conception logicielle, utilisant l’encapsulation, permet à la fois :\n\nle développement séparé de l’application et de l’implémentation de la structure ;\nla modification de l’implémentation sans modification de ses utilisations (on préserve l’interface) ;\nl’utilisation facile de l’implémentation de la structure dans des programmes à venir ;\nla limitation des erreurs ;\nl’ajout :\n\nde vérifications sous forme d’assertions ;\nd’outils de correction des problèmes de programmation ;\n\nune meilleure lisibilité du code de l’application.\n\nDans la suite de ce chapitre, nous allons étudier successivement les listes, les piles, les files et les dictionnaires du point de vue du concepteur (implémentation) et de l’utilisateur (interface)."
  },
  {
    "objectID": "langagesProgr/recursivite_cours.html",
    "href": "langagesProgr/recursivite_cours.html",
    "title": "Récursivité (Cours)",
    "section": "",
    "text": "Un algorithme est dit récursif s’il s’appelle lui-même directement ou indirectement via l’appel d’une ou de plusieurs autres fonctions qui elles-mêmes finissent par l’appeler.\nLa récursivité est un concept fondamental en informatique qui met naturellement en pratique un mode de pensée puissant qui consiste à pouvoir découper la tâche à réaliser en sous-tâches de mêmes natures mais plus petites qui finalement sont simples à résoudre.\nPrenons par exemple le calcul de la factorielle d’un nombre entier \\(n\\). Par définition pour un \\(n\\) entier strictement positif, \\(n!\\) est égale au produit des entiers strictement positifs inférieurs à \\(n\\). Par convention on a aussi \\(0! = 1\\).\nPar exemple, on a : \\(5!=1\\times 2\\times 3\\times 4\\times 5 = 120\\).\nDonnons le code itératif d’une fonction calculant la factorielle:\n  def fact(n):\n    \"\"\"Renvoie la factorielle de n.\"\"\"\n    res = 1\n    for i in range(1,n+1):\n      res = res * i  \n    return res\nLa définition récursive se base sur le fait que \\(n! = n\\times (n-1)!\\) pour tout \\(n>0\\).\nOn obtient le code:\n  def fact(n):\n    \"\"\"Renvoie la factorielle de n (méthode récursive).\"\"\"\n    if n == 0:\n      res = 1\n    else:\n      res = n*fact(n-1)\n    return res\nPour commencer à comprendre comment fonctionne cette fonction récursive, nous pouvons visualiser le calcul de fact(4) grâce à l’outil Python Tutor ci-dessous."
  },
  {
    "objectID": "langagesProgr/recursivite_cours.html#mécanisme",
    "href": "langagesProgr/recursivite_cours.html#mécanisme",
    "title": "Récursivité (Cours)",
    "section": "2. Mécanisme",
    "text": "2. Mécanisme\nConsidérons la fonction foo ci-dessous :\ndef foo(n):\n    if n == 0:\n        print(\"Cas de base : \", n)\n    else:\n        print(\"Début avec n = \" , n)\n        foo(n-1)\n        print(\"Fin avec n = \" , n)\n\n\nfoo(3)\nCe programme génère la sortie suivante :\nDébut avec n =  3\nDébut avec n =  2\nDébut avec n =  1\nCas de base :  0\nFin avec n =  1\nFin avec n =  2\nFin avec n =  3\nL’observation de ces résultats permet de comprendre que le système, lors de l’exécution de ce programme, utilise une pile d’exécution. Une pile d’exécution permet d’enregistrer des informations sur les fonctions en cours d’exécution dans un programme. On parle de pile, car les exécutions successives “s’empilent” les unes sur les autres, comme une pile d’assiettes, ou de crêpes. Si nous nous intéressons à la pile d’exécution du programme étudié ci-dessus, nous obtenons le schéma suivant :\n\n\n\nPile d’exécution\n\n\nIl est important de bien comprendre que la fonction située au sommet de la pile d’exécution est en cours d’exécution. Toutes les fonctions situées “en dessous” sont mises en pause jusqu’au moment où elles se retrouveront au sommet de la pile. Quand une fonction termine son exécution, elle est automatiquement retirée du sommet de la pile (on dit que la fonction est dépilée).\nLa pile d’exécution permet de retenir la prochaine instruction à exécuter au moment où une fonction sera sortie de son “état de pause” (qu’elle se retrouvera au sommet de la pile d’exécution). Elle enregistre aussi le contexte, c’est-à-dire par exemple ici la valeur de la variable locale \\(n\\) associée à chaque appel de la fonction.\nNous pouvons comprendre que ce sont plusieurs copies (on dira plutôt des instances) de la fonction foo qui sont présentent dans la pile, chacune ayant son propre espace de noms : la variable \\(n\\) de la fonction située en haut de la pile n’est pas la même que la variable \\(n\\) de la fonction située en-dessous.\n\n\n\n\n\n\nLimitation propre à Python\n\n\n\nLe langage Python limite à 1000 le nombre d’appels récursifs d’une fonction, autrement dit la hauteur de la pile.\nRecursionError: maximum recursion depth exceeded while calling a Python object"
  },
  {
    "objectID": "langagesProgr/recursivite_cours.html#écrire-un-algorithme-récursif",
    "href": "langagesProgr/recursivite_cours.html#écrire-un-algorithme-récursif",
    "title": "Récursivité (Cours)",
    "section": "3. Écrire un algorithme récursif",
    "text": "3. Écrire un algorithme récursif\nLors de l’écriture d’un algorithme récursif, trois règles doivent toujours être vérifiées :\n\n\n\n\n\n\nLes trois règles de récursivité\n\n\n\n\nLa fonction s’appelle elle-même !\nLa fonction comporte un “cas de base” qui correspond à une condition d’arrêt.\nL’algorithme conduit vers le cas de base : il n’y a pas une infinité d’appels récursifs.\n\n\n\nLa troisième règle est assurée par la preuve de terminaison qui se fait souvent en identifiant la construction d’une suite strictement décroissante d’entiers positifs ou nuls."
  },
  {
    "objectID": "langagesProgr/recursivite_cours.html#fonction-récursive-et-fonction-itérative",
    "href": "langagesProgr/recursivite_cours.html#fonction-récursive-et-fonction-itérative",
    "title": "Récursivité (Cours)",
    "section": "4. Fonction récursive et fonction itérative",
    "text": "4. Fonction récursive et fonction itérative\nLa programmation récursive n’est ni meilleure, ni pire que, la programmation itérative. Toute fonction récursive peut aussi être programmée de façon itérative. Cependant, en cas de nombreux appels récursifs, la mémoire de la machine sera trop fortement sollicitée et l’exécution ralentie, voire impossible.\nLe choix entre une solution récursive ou une solution itérative est donc guidé par le type de problème à résoudre car certains problèmes s’écrivent naturellement de façon récursive."
  },
  {
    "objectID": "langagesProgr/POO_exercices.html",
    "href": "langagesProgr/POO_exercices.html",
    "title": "Programmation orientée objets (Exercices)",
    "section": "",
    "text": "Les exercices précédés du symbole  sont à faire sur machine, en sauvegardant le fichier si nécessaire.\nLes exercices précédés du symbole  doivent être résolus par écrit."
  },
  {
    "objectID": "langagesProgr/POO_exercices.html#fa-desktop-exercice-1",
    "href": "langagesProgr/POO_exercices.html#fa-desktop-exercice-1",
    "title": "Programmation orientée objets (Exercices)",
    "section": " Exercice 1",
    "text": "Exercice 1\nOn considère la classe suivante :\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def deplace(self, dx, dy):\n        self.x = self.x + dx\n        self.y = self.y + dy\n\n    def symetrique(self):\n        return Point(-self.x, -self.y)\n\n    def __repr__(self):\n        return f\"Point({self.x}, {self.y})\"\n\nQuelle instruction entrer dans la console pour créer le point a d’abscisse 2 et d’ordonnée 4 ?\nQuels sont les attributs et les méthodes de cette classe ? Dresser le diagramme de classe de cette classe.\nLa méthode spéciale __repr__ permet de définir comment l’objet sera affiché dans la console Python.\nQu’affichent les instructions suivantes dont la sortie a été effacée ?\n>>> b = Point(1, 2)\n>>> b\n...\n>>> b.deplace(3, 5)\n>>> b\n...\nDéfinir une méthode abscisse qui renvoie l’abscisse du point.\nRecommencer avec la méthode ordonnee."
  },
  {
    "objectID": "langagesProgr/POO_exercices.html#fa-desktop-exercice-2",
    "href": "langagesProgr/POO_exercices.html#fa-desktop-exercice-2",
    "title": "Programmation orientée objets (Exercices)",
    "section": " Exercice 2",
    "text": "Exercice 2\nSoit la classe Date définie par le diagramme de classe (Figure 1).\n\n\n\nFigure 1: Diagramme de classe de la classe Date\n\n\n\nImplémenter cette classe en Python.\nCréer deux dates le 20 janvier 2012 et le 14 février 2022.\nDans la méthode d’initialisation d’instance de la classe, prévoir un dispositif pour éviter les dates impossibles (du genre 32/14/2020). Dans ce cas, la création doit provoquer une erreur, chose possible grâce à l’instruction raise (documentation à rechercher !).\nAjouter une méthode __repr__ et une méthode __str__permettant d’afficher la date sous la forme “25 janvier 1989”. Les noms des mois seront définis en tant qu’attribut de classe à l’aide d’une liste.\nAjouter une méthode __lt__ qui permet de comparer deux dates. L’expression d1 < d2 (d1 et d2 étant deux objets de type Date) doit grâce à cette méthode renvoyer True ou False ."
  },
  {
    "objectID": "langagesProgr/POO_exercices.html#fa-solid-pencil-alt-exercice-3-bac-2022-extrait",
    "href": "langagesProgr/POO_exercices.html#fa-solid-pencil-alt-exercice-3-bac-2022-extrait",
    "title": "Programmation orientée objets (Exercices)",
    "section": " Exercice 3 (Bac 2022, extrait)",
    "text": "Exercice 3 (Bac 2022, extrait)\nSimon souhaite créer en Python le jeu de cartes « la bataille » pour deux joueurs. Les questions qui suivent demandent de reprogrammer quelques fonctions du jeu. On rappelle ici les règles du jeu de la bataille :\nPréparation :\n\nDistribuer toutes les cartes aux deux joueurs.\nLes joueurs ne prennent pas connaissance de leurs cartes et les laissent en tas face cachée devant eux.\n\nDéroulement :\n\nÀ chaque tour, chaque joueur dévoile la carte du haut de son tas.\nLe joueur qui présente la carte ayant la plus haute valeur emporte les deux cartes qu’il place sous son tas.\nLes valeurs des cartes sont : dans l’ordre de la plus forte à la plus faible : As, Roi, Dame, Valet, 10, 9, 8, 7, 6, 5, 4, 3 et 2 (la plus faible).\n\nSi deux cartes sont de même valeur, il y a “bataille”.\n\nChaque joueur pose alors une carte face cachée, suivie d’une carte face visible sur la carte dévoilée précédemment.\nOn recommence l’opération s’il y a de nouveau une bataille sinon, le joueur ayant la valeur la plus forte emporte tout le tas.\n\nLorsque l’un des joueurs possède toutes les cartes du jeu, la partie s’arrête et ce dernier gagne.\nPour cela Simon crée une classe Python Carte. Chaque instance de la classe a deux attributs : un pour sa valeur et un pour sa couleur. Il donne au valet la valeur 11, à la dame la valeur 12, au roi la valeur 13 et à l’as la valeur 14. La couleur est une chaîne de caractères: “trefle”, “carreau”, “coeur” ou “pique”.\nSimon a écrit la classe Python Carte suivante, ayant deux attributs valeur et couleur, et dont le constructeur prend deux arguments: val et coul.\n\nRecopier et compléter les pointillés des lignes ci-dessous.\nclass Carte:\n    def __init__(self, val, coul):\n        ... .valeur = ...\n        ... . ... = coul\nParmi les propositions ci-dessous quelle instruction permet de créer l’objet « 7 de cœur » sous le nom c7 ?\n\nc7. init (self, 7, \"coeur\")\nc7 = Carte(self, 7, \"coeur\")\nc7 = Carte ( 7, \"coeur\")\nfrom Carte import 7, \"coeur\"\n\nOn souhaite créer le jeu de cartes. Pour cela, on écrit une fonction initialiser() :\n\nsans paramètre\nqui renvoie une liste de 52 objets de la classe Carte représentant les 52 cartes du jeu.\n\nVoici une proposition de code. Recopier et compléter les lignes suivantes pour que la fonction réponde à la demande :\ndef initialiser() :\n    jeu = [] \n    for c in [\"coeur\", \"carreau\", \"trefle\", \"pique\"]:\n        for v in range( ... ) :\n            carte_cree = ...\n            jeu.append(carte_cree)\n    return jeu\nÉcrire une fonction comparer(cartel, carte2) qui prend en paramètres deux objets de la classe Carte. Cette fonction renvoie :\n\n0 si la force des deux cartes est identique,\n1 si la carte cartel est strictement plus forte que carte2\n-1 si la carte carte2 est strictement plus forte que cartel\n\n\nVoir le corrigé"
  },
  {
    "objectID": "langagesProgr/POO_exercices.html#fa-solid-pencil-alt-exercice-4-bac-2022",
    "href": "langagesProgr/POO_exercices.html#fa-solid-pencil-alt-exercice-4-bac-2022",
    "title": "Programmation orientée objets (Exercices)",
    "section": " Exercice 4 (Bac 2022)",
    "text": "Exercice 4 (Bac 2022)\nUn fabricant de brioches décide d’informatiser sa gestion des stocks. Il écrit pour cela un programme en langage Python. Une partie de son travail consiste à développer une classe Stock dont la première version est la suivante :\nclass Stock:\n    def __init__(self):\n        self.qt_farine = 0 # quantité de farine initialisée à 0 g\n        self.nb_oeufs = 0 # nombre d’œufs (0 à l’initialisation)\n        self.qt_beurre = 0 # quantité de beurre initialisée à 0 g\n\nÉcrire une méthode ajouter_beurre(self, qt) qui ajoute la quantité qt de beurre à un objet de la classe Stock.\nOn admet que l’on a écrit deux autres méthodes ajouter_farine et ajouter_oeufs qui ont des fonctionnements analogues.\nÉcrire une méthode afficher(self) qui affiche la quantité de farine, d’œufs et de beurre d’un objet de type Stock. L’exemple ci-dessous illustre l’exécution de cette méthode dans la console :\n>>> mon_stock = Stock() \n>>> mon_stock.afficher() \nfarine: 0 \noeuf: 0 \nbeurre: 0 \n>>> mon_stock.ajouter_beurre(560) \n>>> mon_stock.afficher() \nfarine: 0 \noeuf: 0 \nbeurre: 560 \nPour faire une brioche, il faut 350 g de farine, 175 g de beurre et 4 oeufs. Écrire une méthode stock_suffisant_brioche(self) qui renvoie un booléen : VRAI s’il y a assez d’ingrédients dans le stock pour faire une brioche et FAUX sinon.\nOn considère la méthode supplémentaire produire(self) de la classe Stock donnée par le code suivant :\ndef produire(self):\n    res = 0 \n    while self.stock_suffisant_brioche():\n        self.qt_beurre = self.qt_beurre - 175 \n        self.qt_farine = self.qt_farine - 350 \n        self.nb_oeufs = self.nb_oeufs - 4 \n        res = res + 1\n    return res\nOn considère un stock défini par les instructions suivantes :\n>>> mon_stock=Stock()\n>>> mon_stock.ajouter_beurre(1000) \n>>> mon_stock.ajouter_farine(1000) \n>>> mon_stock.ajouter_oeufs(10)\n\nOn exécute ensuite l’instruction : >>> mon_stock.produire(). Quelle valeur s’affiche dans la console ? Que représente cette valeur ?\nOn exécute ensuite l’instruction : >>> mon_stock.afficher(). Que s’affiche-t-il dans la console ?\n\nL’industriel possède n lieux de production distincts et donc n stocks distincts.\nOn suppose que ces stocks sont dans une liste dont chaque élément est un objet de type Stock. Écrire une fonction Python nb_brioches(liste_stocks) possédant pour unique paramètre la liste des stocks et qui renvoie le nombre total de brioches produites.\n\nVoir le corrigé"
  },
  {
    "objectID": "langagesProgr/TPPOOBataille.html",
    "href": "langagesProgr/TPPOOBataille.html",
    "title": "TP - Bataille",
    "section": "",
    "text": "TP : le jeu de la bataille\nDans ce TP, vous mettrez en œuvre la POO pour créer un programme qui joue à la bataille.\n\n\n\nJeu de carte\n\n\n\n\n\n\n\n\nObjectifs\n\n\n\n\nDéfinir une classe et ses membres.\nUtiliser des objets, leurs attributs, leurs méthodes.\nRépondre à un cahier des charges.\n\n\n\nL’énoncé au format PDF est disponible ci-dessous.\n\n\n\n\n\n\nCritères d’évaluation\n\n\n\n\nRespect du cahier de charges.\nDocumentation, spécification des méthodes créées.\nLe jeu se déroule sans erreur.\nBonus : tenir compte des compléments sur la POO.\n\n\n\nFichier Python à télécharger et à compléter : bataille_eleves.py"
  },
  {
    "objectID": "langagesProgr/TPHanoi.html",
    "href": "langagesProgr/TPHanoi.html",
    "title": "TP Tours de Hanoï",
    "section": "",
    "text": "Dans ce TP, vous mettrez en œuvre une procédure récursive afin de résoudre le célèbre problème des tours de Hanoï.\n\n\n\n\n\n\nObjectifs\n\n\n\n\nComprendre un algorithme.\nÉcrire une procédure récursive.\nCalculer une complexité.\n\n\n\nL’énoncé au format PDF est disponible ci-dessous.\n\n\n\n\n\n\nCritères d’évaluation\n\n\n\n\nReprésentation correcte des solutions “à la main”.\nLa procédure résout le problème.\nLa procédure fournit l’affichage demandé.\nJustification correcte du calcul de complexité (en nombre de déplacements)."
  },
  {
    "objectID": "langagesProgr/recursivite_exercices.html",
    "href": "langagesProgr/recursivite_exercices.html",
    "title": "Récursivité (Exercices)",
    "section": "",
    "text": "Les exercices précédés du symbole  sont à faire sur machine, en sauvegardant le fichier si nécessaire.\nLes exercices précédés du symbole  doivent être résolus par écrit."
  },
  {
    "objectID": "langagesProgr/recursivite_exercices.html#fa-solid-pencil-alt-exercice-1-factorielle",
    "href": "langagesProgr/recursivite_exercices.html#fa-solid-pencil-alt-exercice-1-factorielle",
    "title": "Récursivité (Exercices)",
    "section": " Exercice 1 : factorielle",
    "text": "Exercice 1 : factorielle\nOn rappelle l’exemple du premier paragraphe du cours concernant le calcul de la factorielle \\(n!=1\\times 2\\times 3\\times\\ldots\\times n\\) d’un entier naturel \\(n\\), dans sa version récursive.\n  def fact(n):\n    \"\"\"Renvoie la factorielle de n (méthode récursive).\"\"\"\n    if n == 0:\n      res = 1\n    else:\n      res = n*fact(n-1)\n    return res\n\nDans cette fonction, quel est le cas de base ?\nDémontrer que l’algorithme se termine (preuve de terminaison) dès lors que l’argument \\(n\\) donné initialement est un entier naturel.\nQue se passe-t-il si on appelle la fonction fact avec \\(n=-2\\) ? Proposer une modification de la fonction pour traiter ce type de cas.\nPour démontrer que cet algorithme renvoie bien \\(n!\\) lorsque \\(n\\) est un entier naturel, on peut procéder par un raisonnement par récurrence.\n\nCas de base : pour \\(n=0\\), la fonction renvoie-t-elle \\(0!\\) ?\nHypothèse : on suppose que, pour une certaine valeur de l’entier naturel non nul \\(n\\), fact(n-1) renvoie \\((n-1)!\\). Montrer que, sous cette hypothèse, fac(n) renvoie bien \\(n!\\).\nConclusion : en déduire que fac(n) renvoie \\(n!\\) pour tout entier naturel \\(n\\).\n\nPour évaluer la complexité de cet algorithme, nous allons compter le nombre de multiplications et de comparaisons effectuées. Démontrer, à l’aide d’un raisonnement pas récurrence, que la complexité de cet algorithme est en \\(\\mathcal{O}(n)\\).\n\n\n\n\n\n\n\nÀ retenir …\n\n\n\n\nLe principe de la preuve de terminaison.\nLe principe du raisonnement pas récurrence"
  },
  {
    "objectID": "langagesProgr/recursivite_exercices.html#fa-solid-pencil-alt-fa-desktop-exercice-2-suite-de-fibonacci",
    "href": "langagesProgr/recursivite_exercices.html#fa-solid-pencil-alt-fa-desktop-exercice-2-suite-de-fibonacci",
    "title": "Récursivité (Exercices)",
    "section": "  Exercice 2 : suite de Fibonacci",
    "text": "Exercice 2 : suite de Fibonacci\nLa suite de Fibonacci est une suite de nombres entiers notés \\(F_n\\), définie par \\(F_0=0\\), \\(F_1=1\\) et dans laquelle chaque terme est égal à la somme des deux termes qui le précèdent.\n\nCalculer \\(F_n\\) à la main pour les valeurs de \\(n\\) allant de 2 jusqu’à 5.\nRecopier et compléter le code de la fonction fibo_iter qui retourne \\(F_n\\) en utilisant un algorithme itératif.\ndef fibo_iter(n: int) -> int:\n    \"\"\"Suite de Fibonacci, version itérative\"\"\"\n    if n == 0:\n        return 0\n    else:\n        f0, f1 = 0, 1\n        for k in range(1, n):\n            f0, f1 = ...  # Ligne à compléter ...\n        return f1\n\n\nfor k in range(10):\n    print(fibo_iter(k))\nÉvaluer la complexité en termes de nombre d’additions.\nD’après la définition de la suite, on a, pour tout entier naturel \\(n\\geqslant 2\\) :\n\\[F_{n}=F_{n-2}+F_{n-1}\\]\nEn déduire une version récursive de l’algorithme de calcul de \\(F_n\\). Cet algorithme a ceci de particulier que chaque fonction procède à deux appels récursifs. On pourra recopier et compléter le code ci-dessous.\ndef fibo_rec(n: int) -> int:\n    \"\"\"Suite de Fibonacci version récursive\"\"\"\n    # Cas de base\n    if ...:\n        return n\n    # Récursion\n    else:\n        return ...\n\n\nfor k in range(10):\n    print(fibo_rec(k))\nUtiliser chacune des deux versions pour calculer la valeur de \\(F_{50}\\). Que constate-t-on ? Expliquer.\n\n\n\n\n\n\n\nRemarques et compléments\n\n\n\n\n\nLa version récursive se révèle beaucoup moins efficace. Pour comprendre pourquoi, nous pouvons représenter par un arbre les appels récursifs nécessaires.\n\n\n\n\n\nOn retrouve les cas de base dans les feuilles de l’arbre. Nous pouvons constater que le nombre d’appels récursifs est très grand. Il est possible de démontrer que ce nombre augmente de façon exponentielle. Pour calculer \\(F_{100}\\), il y aurait environ \\(10^{20}\\) opérations. À raison de \\(10^9\\) opérations par seconde, la calcul prendra de l’ordre de \\(10^{11}\\) secondes, soit environ 3 000 ans !\nUn autre constat qui montre l’inefficacité de ce programme : plusieurs calculs identiques sont répétés plusieurs fois. On calcule par exemple \\(F_3\\) deux fois et \\(F_2\\) trois fois. Une solution meilleure serait de garder en mémoire les éléments déjà calculés et de ne calculer que les nouveaux éléments encore jamais rencontrés. Une telle démarche relève de la programmation dynamique qui sera abordée en fin d’année.\nPour satisfaire votre curiosité insatiable, vous pouvez déjà observer et tester le programme ci-dessous :\ndef fibo_dyn(n: int, suite: dict = {0: 0, 1: 1}) -> int:\n    \"\"\"Suite de Fibonacci version dynamique\"\"\"\n    # Cas de base\n    if n == 0 or n == 1:\n        return n\n    # Récursion\n    else:\n        # Si Fn est déjà calculé, on le retourne\n        if n in suite.keys():\n            return suite[n]\n        else:\n            # Sinon, on le calcule et on le garde en mémoire\n            f = fibo_dyn(n-2, suite) + fibo_dyn(n-1, suite)\n            suite[n] = f\n            return f\n\n\nfor k in range(10):\n    print(fibo_dyn(k))\nUne exécution dans PythonTutor est instructive :\n\n\nVoir cet article du blog qui explique comment visualiser le temps d’exécution d’une fonction."
  },
  {
    "objectID": "langagesProgr/recursivite_exercices.html#fa-solid-pencil-alt-fa-desktop-exercice-3-calcul-de-xn",
    "href": "langagesProgr/recursivite_exercices.html#fa-solid-pencil-alt-fa-desktop-exercice-3-calcul-de-xn",
    "title": "Récursivité (Exercices)",
    "section": "  Exercice 3 : calcul de \\(x^n\\)",
    "text": "Exercice 3 : calcul de \\(x^n\\)\nPour tout nombre réel \\(x\\) et tout entier naturel \\(n\\), \\(x^n\\) est défini par \\(x^0=1\\) et, pour \\(n>0\\), \\(x^n=x\\times x\\times x\\times \\ldots \\times x\\) : produit de \\(n\\) facteurs tous égaux à \\(x\\).\nLes règles de calcul sur les exposants permettent d’affirmer que, pour \\(n>0\\), \\(x^n=x\\times x^{n-1}\\).\n\nÉcrire la fonction récursive puissance(x,n) qui calcule le nombre \\(x^n\\) pour tout entier naturel \\(n\\).\nDessiner l’arbre d’appels de cette fonction pour \\(x=3\\) et \\(n=5\\).\nPour les plus rapides\n\n\n\n\n\n\n\nQuestion bonus\n\n\n\nUn autre méthode de calcul de \\(x^n\\) consiste à distinguer le cas où \\(n\\) est pair et celui où \\(n\\) est impair :\n\nsi \\(n=0\\), alors \\(x^n=1\\) ;\nsi \\(n\\) est pair, alors \\(x^n=\\left(x^{n/2}\\right)^2\\) ;\nsi \\(n\\) est impair, alors \\(x^n=x\\times\\left(x^{(n-1)/2}\\right)^2\\).\n\nL’algorithme qui découle de cette définition porte également le nom d’exponentiation rapide. Comme son nom l’indique, il s’agit d’un algorithme particulièrement efficace pour calculer rapidement de grandes puissances entières.\nÉcrire la fonction récursive puissancev2(x,n) qui calcule le nombre \\(x^n\\) pour tout entier naturel n selon la méthode d’exponentiation rapide."
  },
  {
    "objectID": "langagesProgr/recursivite_exercices.html#fa-solid-pencil-alt-exercice-4-maximum-dune-liste",
    "href": "langagesProgr/recursivite_exercices.html#fa-solid-pencil-alt-exercice-4-maximum-dune-liste",
    "title": "Récursivité (Exercices)",
    "section": " Exercice 4 : maximum d’une liste",
    "text": "Exercice 4 : maximum d’une liste\nOn considère le programme ci-dessous :\ndef maximum(a, b):\n    if a > b:\n        return a\n    else:\n        return b\n\ndef maximum_tab(tab):\n    if len(tab) == 1:\n        return tab[0]\n    else:\n        return maximum(tab[0], maximum_tab(tab[1:]))\n\nfrom random import randint\n\nmon_tab = []\nfor i in range(20):\n    mon_tab.append(randint(-100, 100))\nprint(mon_tab)\nprint(maximum_tab(mon_tab))\n\nDécrire, en langage usuel, le principe de fonctionnement de la fonction maximum_tab.\nExpliquer en quoi la fonction maximum_tab est récursive. Quel est le cas de base ?\nProuver la terminaison de cette fonction.\nEffectuer par récurrence la preuve de cet algorithme (c’est-à-dire prouver que la fonction retourne bien le maximum du tableau donné en argument).\nDessiner l’arbre d’appels de cette fonction pour l’appel maximum_tab([-4,55,-1,-35,-52,31])."
  },
  {
    "objectID": "langagesProgr/recursivite_exercices.html#fa-desktop-exercice-5-palindromes",
    "href": "langagesProgr/recursivite_exercices.html#fa-desktop-exercice-5-palindromes",
    "title": "Récursivité (Exercices)",
    "section": " Exercice 5 : palindromes",
    "text": "Exercice 5 : palindromes\nOn appelle palindrome un mot qui se lit dans les deux sens comme « été » ou « radar ».\nÉcrire une fonction récursive palindrome qui teste si un mot est un palindrome.\n\nEntrée : Un mot (type str).\nSortie : Un booléen égal à True si le mot est un palindrome, False sinon.\n\nOn considérera les deux cas suivant comme cas de base :\n\nsi le mot est la chaîne vide, c’est un palindrome ;\nsi le mot ne contient qu’une seule lettre, c’est un palindrome"
  },
  {
    "objectID": "langagesProgr/recursivite_exercices.html#fa-solid-pencil-alt-fa-desktop-exercice-6-flocon-de-von-koch",
    "href": "langagesProgr/recursivite_exercices.html#fa-solid-pencil-alt-fa-desktop-exercice-6-flocon-de-von-koch",
    "title": "Récursivité (Exercices)",
    "section": "  Exercice 6 : flocon de von Koch",
    "text": "Exercice 6 : flocon de von Koch\nUne image qui a une apparence similaire quelle que soit l’échelle à laquelle on l’observe est appelée une fractale (il y a d’autres types de fractales).\nUn exemple simple de fractale est le flocon de Von Koch, dont voici une représentation (pour un degré 4).\n\n\n\nFlocon de von Koch\n\n\nOn peut la créer à partir d’un segment de droite, en modifiant récursivement chaque segment de droite de la façon suivante :\n\non divise le segment de droite en trois segments de longueurs égales ;\non construit un triangle équilatéral ayant pour base le segment médian de la première étape ;\non supprime le segment de droite qui était la base du triangle de la deuxième étape.\n\nVoici le résultat obtenu en une étape :\n\n\n\nÉtape de construction\n\n\nPour continuer, il suffit de considérer chaque segment de cette dernière figure comme segment de départ.\nfrom turtle import *\n\n\ndef Koch(n, d):\n    if n == 0:\n        forward(d)\n    else:\n        Koch(n-1, d/3)\n        left(60)\n        Koch(n-1, d/3)\n        right(120)\n        Koch(n-1, d/3)\n        left(60)\n        Koch(n-1, d/3)\n    return None\n\n\ndef flocon(n, d):\n    for k in range(3):\n        Koch(n, d)\n        right(120)\n    return None\n\n\nflocon(4, 300)\nexitonclick()\n\nIdentifier le cas de base de la fonction récursive Koch(n, d). Que fait-il ?\nModifier les paramètres n et d lors de l’appel à la fonction flocon et observer l’impact de ces modifications sur le dessin.\nCombien d’appels récursifs sont-ils réalisés lors de l’appel de la fonction Koch(4, 300) ?"
  },
  {
    "objectID": "langagesProgr/recursivite_exercices.html#fa-solid-pencil-alt-exercice-7-type-bac",
    "href": "langagesProgr/recursivite_exercices.html#fa-solid-pencil-alt-exercice-7-type-bac",
    "title": "Récursivité (Exercices)",
    "section": " Exercice 7 (type bac)",
    "text": "Exercice 7 (type bac)"
  },
  {
    "objectID": "langagesProgr/POO_complements.html",
    "href": "langagesProgr/POO_complements.html",
    "title": "Programmation orientée objets (Compléments)",
    "section": "",
    "text": "Avertissement\n\n\n\nLes compléments présentés ici sont hors programme. Ils peuvent néanmoins apporter une connaissance et une compréhension plus fine de la POO et être utiles dans le cadre du travail sur les projets."
  },
  {
    "objectID": "langagesProgr/POO_complements.html#principes-et-définitions",
    "href": "langagesProgr/POO_complements.html#principes-et-définitions",
    "title": "Programmation orientée objets (Compléments)",
    "section": "Principes et définitions",
    "text": "Principes et définitions\n\nObjet\n\nUn objet est une donnée manipulable par un programme : il s’agit d’un conteneur pour une valeur ou un état auquel est associé un ensemble d’opérations. Cet objet est associé à un type, défini comme l’ensemble des valeurs possibles, cette liste d’opérations, ainsi que leur codage (binaire).\n\n\nUn objet est identifié dans un programme par un nom ou une notation littérale, mais peut parfois être anonyme (comme les variables temporaires ou les composantes d’un tableau).\nEt pour une définition d’un langage orienté objet, l’idée première que l’on retrouve dans la définition de wikipédia offre un cadre intéressant : un langage objet doit permettre l’analyse et le développement logiciel fondés sur des relations entre objets.\nConcrètement, un objet est une structure de données qui répond à un ensemble de messages. Cette structure de données définit son état tandis que l’ensemble des messages qu’il comprend décrit son comportement :\n\nles données, ou champs, qui décrivent sa structure interne sont appelées ses attributs ;\nl’ensemble des messages forme ce que l’on appelle l’interface de l’objet ; c’est seulement au travers de celle-ci que les objets interagissent entre eux. La réponse à la réception d’un message par un objet est appelée une méthode (méthode de mise en œuvre du message) ; elle décrit quelle réponse doit être donnée au message.\n\nLes attributs et les méthodes constituent les membres d’un objet. Un objet possède un type.\nEn Python, un objet la création d’un objet se fait en utilisant une classe : un objet est alors une instance de sa classe. La classe est un type, un ensemble d’objets partageant les mêmes propriétés concrétisées par une liste de membres.\n\nLangage orienté objet\n\nUn langage orienté objet est un langage de programmation qui comporte de manière native les éléments suivants : l’encapsulation, l’héritage, le polymorphisme et la programmation générique."
  },
  {
    "objectID": "langagesProgr/POO_complements.html#les-principes-clés-de-la-poo",
    "href": "langagesProgr/POO_complements.html#les-principes-clés-de-la-poo",
    "title": "Programmation orientée objets (Compléments)",
    "section": "Les principes clés de la POO",
    "text": "Les principes clés de la POO\n\nL’encapsulation\nCertains membres (ou plus exactement leur représentation informatique) sont cachés : c’est le principe d’encapsulation. Ainsi, le programme peut modifier la structure interne des objets ou leurs méthodes associées sans avoir d’impact sur les utilisateurs de l’objet. C’est un des principes fondamentaux notamment pour la robustesse du code.\nEn particulier, les bonnes pratiques de POO recommandent de na pas permettre un accès direct aux attributs d’un objet à l’extérieur de celui-ci. On appelle interface d’un objet l’ensemble de ses membres qui sont accessibles à l’extérieur de celui-ci. L’interface ne devrait donc contenir que des méthodes. Pas forcément toutes, certaines méthodes (comme __init__) restent privées.\nContrairement à d’autres langages, Python offre une totale liberté de modification sur les membres d’un objet. C’est au programmeur de rester vigilant. Il existe néanmoins des conventions permettant d’identifier les membres de l’interface des autres membres d’un objet.\n\n\n\n\n\n\nConventions de nommage en Python\n\n\n\n\nun nom d’attribut commençant par un double underscore __ désigne un attribut privé.\nune méthode dont le nom est de la forme __nom__ désigne une méthode privée.\n\n\n\nMais alors si les attributs doivent rester privés, comment y accéder, et comment les modifier ?\nIl convient pour cela, en toute rigueur, de définir des méthodes ad-hoc : une méthode qui permet d’accéder à un attribut est un getter, une période qui permet de changer la valeur d’un attribut est un setter.\nVoici par exemple une nouvelle définition de la classe “Rectangle” tenant compte des remarques précédentes.\nclass Rectangle:\n    \"\"\"Représente un rectangle\"\"\"\n\n    def __init__(self, largeur=2, hauteur=3):\n        self.__largeur = largeur\n        self.__hauteur = hauteur\n\n    def get_largeur(self):\n        return self.__largeur\n\n    def set_largeur(self, largeur):\n        self.__largeur = largeur\n\n    def get_hauteur(self):\n        return self.__hauteur\n\n    def set_hauteur(self, hauteur):\n        self.__hauteur = hauteur\n\n    def perimetre(self):\n        \"\"\"Retourne le périmètre\"\"\"\n        return 2 * (self.__largeur + self.__hauteur)\n\n    def aire(self):\n        \"\"\"Retourne l'aire\"\"\"\n        return self.__largeur * self.__hauteur\nUtilisation :\n>>> rec = Rectangle(10, 5)\n>>> rec.__hauteur\nAttributeError: 'Rectangle' object has no attribute '__hauteur'\n>>> rec.get_hauteur()\n5\nNous voyons que l’accès direct à l’attribut n’est plus possible.\nCela n’est pas très pratique et change nos habitudes : nous aimerions en effet pouvoir accéder à la valeur d’un attribut en utilisant la notation pointée. Deux remarques à ces objections. D’une part, ces règles de programmation ne sont pas là pour nous embêter ! Il s’agit de sécuriser notre code : la définition d’un setter par exemple, peut permettre de vérifier la validité des arguments entrés et afficher un message d’erreur si besoin (par exemple si on appelle set_hauteur(-10). Deuxième remarque : Python propose une fonctionnalité avancée, appelée décorateurs et qui permet de retrouver, en apparence, l’accès direct aux attributs. Voici une nouvelle version de la classe “Rectangle” avec l’utilisation du décorateur @property et la redéfinition des getter et setter (qui doivent maintenant porter le même nom que le pseudo argument). On a introduit dans les setter des tests de validité des données.\nclass Rectangle:\n    \"\"\"Représente un rectangle\"\"\"\n\n    def __init__(self, largeur=2, hauteur=3):\n        self.__largeur = largeur\n        self.__hauteur = hauteur\n\n    @property\n    def largeur(self):\n        return self.__largeur\n\n    @largeur.setter\n    def largeur(self, largeur):\n        if isinstance(largeur, (int, float)) and largeur >= 0:\n            self.__largeur = largeur\n        else:\n            print(\"Argument invalide, largeur inchangée !\")\n\n    @property\n    def hauteur(self):\n        return self.__hauteur\n\n    @hauteur.setter\n    def hauteur(self, hauteur):\n        if isinstance(hauteur, (int, float)) and hauteur >= 0:\n            self.__hauteur = hauteur\n        else:\n            print(\"Argument invalide, hauteur inchangée !\")\n\n    def perimetre(self):\n        \"\"\"Retourne le périmètre\"\"\"\n        return 2 * (self.__largeur + self.__hauteur)\n\n    def aire(self):\n        \"\"\"Retourne l'aire\"\"\"\n        return self.__largeur * self.__hauteur\n\n\nrec = Rectangle(10, 25)\nprint(rec.largeur)\nrec.largeur = -15\nprint(rec.largeur)\nSortie en console :\n10\nArgument invalide, largeur inchangée !\n10\n\n\nL’héritage\nL’héritage est une relation asymétrique entre deux classes : l’une est la classe mère (aussi nommée classe parente, superclasse, classe de base), l’autre la classe-fille. L’héritage permet une économie d’écriture par la réutilisation automatique, lors de la définition de la classe-fille, de tous les membres et autres éléments définis dans la classe mère. Ainsi, les objets de la classe-fille héritent de toutes les propriétés de leur classe mère.\nPar exemple, nous pouvons définir une classe carre, fille de la classe Rectangle. Les attributs et les méthodes définis pour la classe Rectangle existent alors automatiquement aussi pour la classe carre.\nVoici la syntaxe Python pour définir une classe fille :\nclass Carre(Rectangle):\n\n    def __init__(self, cote=2):\n        Rectangle.__init__(self, cote, cote)\nUtilisation :\n>>> car = Carre(5)\n>>> car.perimetre()\n20\nLa méthode perimetre est héritée de la classe mère Rectangle.\n\n\n\n\n\n\nHéritage et initialiseur\n\n\n\nLa méthode initialiseur de la classe Carre fait appel à la méthode initialiseur de sa classe parente par la commande Rectangle.__init__(self, cote, cote). Cet appel est nécessaire afin que les membres de la classe Carre soient définis de la même manière que les membres de la classe Rectangle. La méthode __init__ est un initialiseur d’instance : elle n’est pas invoquée automatiquement lorsqu’on instancie des objets d’une classe fille.\n\n\n\n\nLe polymorphisme et la redéfinition\nLa redéfinition des méthodes permet à un objet de raffiner une méthode définie avec la même en-tête dans la classe mère. Une même méthode pourra ainsi avoir un comportement différent selon qu’elle s’applique à la classe mère ou à la classe fille : on parle de polymorphisme d’héritage.\nPar exemple, nous pouvons redéfinir la méthode aire de la classe Carre comme ci-dessous : appliquée à un objet Carre, la nouvelle définition sera utilisée à la place de la méthode héritée.\nclass Carre(Rectangle):\n\n    def __init__(self, cote=2):\n        self.__largeur = cote\n        self.__hauteur = cote\n    \n    def aire(self):\n        \"\"\"Retourne l'aire\"\"\"\n        return self.__largeur ** 2"
  },
  {
    "objectID": "langagesProgr/POO_complements.html#les-méthodes-spéciales",
    "href": "langagesProgr/POO_complements.html#les-méthodes-spéciales",
    "title": "Programmation orientée objets (Compléments)",
    "section": "Les méthodes spéciales",
    "text": "Les méthodes spéciales\nUn bon exemple de polymorphisme est fourni par la redéfinition des méthodes spéciales.\nNous savons que la fonction dir() renvoie tous les membres d’un objet.\nAppliquons cette commande à notre objet rec, instance de la classe Rectangle :\n>>> dir(rec)\n['__class__',\n '__delattr__',\n '__dict__',\n '__dir__',\n '__doc__',\n '__eq__',\n '__format__',\n '__ge__',\n '__getattribute__',\n '__gt__',\n '__hash__',\n '__init__',\n '__init_subclass__',\n '__le__',\n '__lt__',\n '__module__',\n '__ne__',\n '__new__',\n '__reduce__',\n '__reduce_ex__',\n '__repr__',\n '__setattr__',\n '__sizeof__',\n '__str__',\n '__subclasshook__',\n '__weakref__',\n '_hauteur',\n '_largeur',\n 'aire',\n 'hauteur',\n 'largeur',\n 'perimetre']\nNous reconnaissons en fin de liste les attributs et méthodes que nous avons définis, mais nous découvrons l’existence d’un grand nombre de méthodes spéciales privées (puisque leur nom est entouré de __) qui sont en fait héritées d’une classe Object parente de toutes les classes. Parmi celles-ci, nous avons déjà rencontré __init__, la méthode initialiseur.\nLes curieux pourront rechercher le rôle de chacune de ces méthodes spéciales. Le voici pour certaines d’entre elles :\n\n\n\nMéthode spéciale\nUsage\n\n\n\n\nadd\n+\n\n\nmul\n*\n\n\nsub\n-\n\n\neq\n==\n\n\nne\n!=\n\n\nlt\n<\n\n\nge\n<=\n\n\ngt\n>\n\n\nge\n>=\n\n\nrepr\naffichage dans la console >>> obj\n\n\nstr\nstr(obj), print(obj)\n\n\n\nLa redéfinition de la méthode __add__ permettrait par exemple de donner un sens à l’utilisation du symbole + entre deux objets (instruction du type rec1 + rec 2).\nDans notre exemple, nous allons redéfinir la méthode __str__ pour spécifier ce qui doit s’afficher quand l’instruction print(rec) est exécutée.\nPour l’instant, on obtient :\n>>> print(rec)\n<__main__.Rectangle object at 0x000002386735C730>\nAjoutons la méthode ci-dessous dans la classe Rectangle :\ndef __str__(self):\n    return f\"Rectangle de largeur {self.__largeur} et de hauteur {self.__hauteur}.\"\nOn obtient maintenant :\n>>> print(rec)\nRectangle de largeur 10 et de hauteur 25."
  },
  {
    "objectID": "langagesProgr/paradigmes_exercices.html",
    "href": "langagesProgr/paradigmes_exercices.html",
    "title": "Paradigmes de programmation (Exercices)",
    "section": "",
    "text": "Les exercices précédés du symbole  sont à faire sur machine, en sauvegardant le fichier si nécessaire.\nLes exercices précédés du symbole  doivent être résolus par écrit."
  },
  {
    "objectID": "langagesProgr/paradigmes_exercices.html#fa-solid-pencil-alt-exercice-1",
    "href": "langagesProgr/paradigmes_exercices.html#fa-solid-pencil-alt-exercice-1",
    "title": "Paradigmes de programmation (Exercices)",
    "section": " Exercice 1",
    "text": "Exercice 1\nVoici différents algorithmiques permettant l’affichage des 10 chiffres entiers dans l’ordre décroissant.\nPréciser pour chacun des algorithme le type de paradigme auquel il correspond.\nAlgorithme 1 :\ndef decompter(n:int)->None:\n    if n>=0: \n        print(n)\n        decompter(n-1)\ndecompter(9)\nAlgorithme 2 :\nfor i in range(10):\n    print(9-i)\nAlgorithme 3 :\nclass Nombres():\n\n    def __init__(self,valeur):\n        self.valeur = valeur\n\n    def diminuer(self):\n        self.valeur -= 1\n\n    def __str__(self):\n        return str(self.valeur)\n\nn = Nombres(9)\nwhile n.valeur >= 0 :\n    print(n)\n    n.diminuer()"
  },
  {
    "objectID": "langagesProgr/paradigmes_exercices.html#fa-solid-pencil-alt-exercice-2",
    "href": "langagesProgr/paradigmes_exercices.html#fa-solid-pencil-alt-exercice-2",
    "title": "Paradigmes de programmation (Exercices)",
    "section": " Exercice 2",
    "text": "Exercice 2\nVoici deux versions d’une fonction teste_ordre_liste dont l’objectif est de savoir si une liste est ordonnée par ordre croissant. Indiquer quel paradigme est utilisé dans chacune des deux versions et expliquer votre réponse.\nVersion 1\n# -*- coding: utf-8 -*-\n\ndef test_ordre(a,b) :\n    if a < b :\n        return True\n    else :\n        return False\n\ndef test_ordre_liste(liste) :\n    if len(liste) < 2 :\n        return True\n    return test_ordre(liste[0],liste[1]) and test_ordre_liste(liste[1:])\n\ntest_ordre_liste([2,3,2])\nVersion 2\n# -*- coding: utf-8 -*-\n\ndef test_ordre(a,b) :\n    if a < b :\n        return True\n    else :\n        return False\n\ndef test_ordre_liste(liste) :\n    if len(liste) < 2 :\n        return True\n    else :\n        if test_ordre(liste[0],liste[1]) == False :\n            return False\n        else :\n            del liste[0]\n            return test_ordre_liste(liste)\n\ntest_ordre_liste([2,3,2])"
  },
  {
    "objectID": "langagesProgr/paradigmes_exercices.html#fa-solid-pencil-alt-exercice-3",
    "href": "langagesProgr/paradigmes_exercices.html#fa-solid-pencil-alt-exercice-3",
    "title": "Paradigmes de programmation (Exercices)",
    "section": " Exercice 3",
    "text": "Exercice 3\nLe programme ci-dessous ne respecte pas le paradigme fonctionnel. Pourquoi ?\ni = 5\n\ndef fct():\n  if i > 5:\n    return True\n  else :\n    return False\n\nfct()\nModifier le programme pour qu’il respecte le paradigme fonctionnel."
  },
  {
    "objectID": "langagesProgr/paradigmes_exercices.html#fa-solid-pencil-alt-exercice-4",
    "href": "langagesProgr/paradigmes_exercices.html#fa-solid-pencil-alt-exercice-4",
    "title": "Paradigmes de programmation (Exercices)",
    "section": " Exercice 4",
    "text": "Exercice 4\nMême exercice avec le programme ci-dessous :\nl = [4,7,3]\n\ndef ajout(i):\n  l.append(i)\n\n\n\n\n\n\nComplément pour les curieux\n\n\n\nPour ceux qui voudraient découvrir un langage fonctionnel, cette page fournit une introduction pas à pas aux bases de OCamL. Ce langage est utilisé en CPGE scientifiques dans le cadre de l’option informatique. Une autre introduction, pour la prépa, est disponible ici. On peut programmer en OCamL en ligne ici."
  },
  {
    "objectID": "langagesProgr/POO_cours.html",
    "href": "langagesProgr/POO_cours.html",
    "title": "Programmation orientée objets (Cours)",
    "section": "",
    "text": "Objectifs\n\n\n\n\nConnaître le vocabulaire de la POO : classes, attributs, méthodes objets.\nÉcrire la définition d’une classe.\nAccéder aux méthodes et attributs d’une classe.\nDes compléments sur la POO sont proposés à la suite de ce cours."
  },
  {
    "objectID": "langagesProgr/POO_cours.html#introduction",
    "href": "langagesProgr/POO_cours.html#introduction",
    "title": "Programmation orientée objets (Cours)",
    "section": "Introduction",
    "text": "Introduction\nLa Programmation Orientée Objets (POO) pour les intimes (que vous allez devenir !) est un paradigme (c’est-à-dire une manière de faire) de programmation\nPour un bref aperçu historique de l’idée d’objet en programmation, lire l’encadré ci-dessous, en grande partie tiré de l’article Object-oriented programming de Wikipedia en anglais.\n\n\n\n\n\n\nUn peu d’histoire\n\n\n\nLes termes objets orienté au sens moderne de la programmation orientée objet ont fait leur première apparition au MIT à la fin des années 1950 et au début des années 1960. Dans l’environnement du groupe d’intelligence artificielle, dès 1960, “objet” pouvait désigner des éléments identifiés avec des propriétés (attributs).\nC’est l’informaticien Alan Kay (1940-) qui est considéré comme l’un de pères de la programmation orientée objets.\n\nJe pensais que les objets étaient comme des cellules biologiques et / ou des ordinateurs individuels sur un réseau, uniquement capables de communiquer avec des messages.\nAlan Kay\n\nLe langage Simula dans les années 1960, puis Smalltalk dans les années 1970 posent les bases toujours actuelles de ce paradigme.\nAu début et au milieu des années 1990, la programmation orientée objet s’est développée comme le paradigme de programmation dominant lorsque les langages de programmation prenant en charge ces techniques sont devenus largement disponibles. Ceux-ci incluent par exemple C++ ou Delphi. Sa domination a été renforcée par la popularité croissante des interfaces utilisateur graphiques, qui reposent fortement sur des techniques de programmation orientées objet.\nDes fonctionnalités orientées objet ont été ajoutées à de nombreux langages existants, notamment Ada, BASIC, Fortran, Pascal et COBOL.\nPlus récemment, un certain nombre de langages ont émergé qui sont principalement orientés objet, mais qui sont également compatibles avec la méthodologie procédurale. Deux de ces langages sont Python et Ruby. Les langages orientés objet récents les plus importants sur le plan commercial sont probablement Java, développé par Sun Microsystems, ainsi que C# et Visual Basic.NET (VB.NET), tous deux conçus pour la plate-forme.NET de Microsoft.\n*[MIT] : Massachusetts Institute of Technology\n\n\nAlors de quoi s’agit-il ? Une approche intuitive consiste à dire que cette méthode de programmation nous permet de définir des nouveaux types de données, de nouveaux objets, correspondant à un objectif précis. Ces nouveaux types sont appelés classes. En définissant une classe, nous pouvons également définir ses attributs, c’est-à-dire les variables qui lui sont associées et ses méthodes, c’est-à-dire les fonctions sui lui sont propres.\nVoici ce que Gérard SWINNEN écrit dans son livre Apprendre à programmer avec Python 3 :\n\nLes classes sont les principaux outils de la programmation orientée objet (Object Oriented Programming ou OOP). Ce type de programmation permet de structurer les logiciels complexes en les organisant comme des ensembles d’objets qui interagissent, entre eux et avec le monde extérieur.\nLe premier bénéfice de cette approche de la programmation réside dans le fait que les différents objets utilisés peuvent être construits indépendamment les uns des autres (par exemple par des programmeurs différents) sans qu’il n’y ait de risque d’interférence. Ce résultat est obtenu grâce au concept d’encapsulation : la fonctionnalité interne de l’objet et les variables qu’il utilise pour effectuer son travail, sont en quelque sorte « enfermées » dans l’objet. Les autres objets et le monde extérieur ne peuvent y avoir accès qu’à travers des procédures bien définies : l’interface de l’objet.\nEn particulier, l’utilisation de classes dans vos programmes va vous permettre – entre autres avantages – d’éviter au maximum l’emploi de variables globales. Vous devez savoir en effet que l’utilisation de variables globales comporte des risques, d’autant plus importants que les programmes sont volumineux, parce qu’il est toujours possible que de telles variables soient modifiées, ou même redéfinies, n’importe où dans le corps du programme (ce risque s’aggrave particulièrement si plusieurs programmeurs différents travaillent sur un même logiciel).\n\nEn utilisant Python, nous avons déjà fréquenté des classes d’objets : il est usuel de lire qu’en Python “tout est objet”, même si Python ne permet pas vraiment de faire de la POO dans toute sa rigueur.\nPar exemple, définissons une chaîne de caractères et demandons à Python quel est son type :\n>>> a = \"Coucou !\"\n>>> type(a)\n<class 'str'>\nLe type ‘str’ bien connu est en fait une classe d’objet prédéfinie. On dit que a est une instance de l’objet str.\nUn exemple de méthode rattachée à la classe str est la fonction capitalize qui met le premier caractère en majuscule. Cette méthode est appelée par la notation pointée déjà rencontrée.\n>>> a.capitalize()\n'Coucou !'\nLa commande help(str) affiche toutes les méthodes prédéfinies pour les objets de la classe str."
  },
  {
    "objectID": "langagesProgr/POO_cours.html#classe-initialiseur-attributs",
    "href": "langagesProgr/POO_cours.html#classe-initialiseur-attributs",
    "title": "Programmation orientée objets (Cours)",
    "section": "Classe, initialiseur, attributs",
    "text": "Classe, initialiseur, attributs\nEn Python, la définition d’une classe se fait avec le mot-clef class suivi du nom de la classe.\nSupposons par exemple que nous voulons définir une classe pour représenter des rectangles. Nous avons besoin, pour chaque rectangle, de connaître sa largeur et se hauteur, ce qui nous permettra de faire quelques calculs.\nObservons le code suivant :\nclass Rectangle:\n    \"\"\"Représente un rectangle\"\"\"\n    \n    def __init__(self, largeur = 2, hauteur = 3):\n        self.largeur = largeur\n        self.hauteur = hauteur\nÀ l’intérieur de la classe Rectangle, la méthode __init__ est l’initialiseur : elle est toujours exécutée lorsqu’une instance de l’objet Rectangle est créée (on parle aussi de constructeur). Cette fonction accepte des paramètres qui seront les valeurs à donner aux attributs à la création de l’objet (ici on a aussi donné des valeurs par défaut à ces paramètres) ; le premier paramètre est particulier : ce sera toujours le mot-clé self : ce mot-clef désigne l’instance qui est en train d’être définie au moment où cette fonction s’exécute.\n\n\n\n\n\n\nRemarque\n\n\n\nIl est d’usage, et recommandé, de nommer une classe par un nom commençant par une majuscule.\n\n\nObservons les lignes suivantes dans la console Python :\n>>> rec1 = Rectangle()\n>>> rec2=Rectangle(15, 25)\n>>> rec1.largeur\n2\n>>> rec2.largeur\n15\nrec1 est une instance de l’objet Rectangle. Aucun paramètre n’étant donné lors de sa création, les valeurs par défaut ont été appliquées. rec2 est une autre instance de l’objet Rectangle pour laquelle on a défini les attributs d’instance largeur et hauteur. On accède à ces attributs par la notation pointée."
  },
  {
    "objectID": "langagesProgr/POO_cours.html#méthodes",
    "href": "langagesProgr/POO_cours.html#méthodes",
    "title": "Programmation orientée objets (Cours)",
    "section": "Méthodes",
    "text": "Méthodes\nUne méthode, c’est ce qui permet à une instance de réaliser des actions. Techniquement se sont des fonctions définies dans le corps de la classe, et qui prennent toujours au moins un premier paramètre qui est self.\nCertaines méthodes sont particulières, leurs noms commencent par un double undescore (le caractère _). On a vu une première de ces méthodes : l’initialiseur __init__.\nDéfinissons ici une méthode permettant de calculer le périmètre d’un rectangle et une autre pour l’aire :\nclass Rectangle:\n    \"\"\"Représente un rectangle\"\"\"\n\n    def __init__(self, largeur=2, hauteur=3):\n        self.largeur = largeur\n        self.hauteur = hauteur\n\n    def perimetre(self):\n        \"\"\"Retourne le périmètre\"\"\"\n        return 2 * (self.largeur + self.hauteur)\n\n    def aire(self):\n        \"\"\"Retourne l'aire\"\"\"\n        return self.largeur * self.hauteur\nUtilisation :\n>>> rec = Rectangle(10, 5)\n>>> rec.perimetre()\n30\n>>> rec.aire()\n50\nUne méthode peut modifier la valeur d’un attribut. Définissons par exemple une méthode permettant de doubler la largeur d’un rectangle.\ndef double_largeur(self):\n    \"\"\"Double la largeur du rectangle)\"\"\"\n    self.largeur *= 2\n>>> rec = Rectangle(10, 5)\n>>> rec.double_largeur()\n>>> rec.largeur\n20\nLa POO encourage à n’exposer que des méthodes vers l’extérieur (on parle d’interface) en masquant les attributs. Il s’agit d’un des quatre éléments constitutifs de l’orienté objet : l’encapsulation.\n\n\n\n\n\n\nRemarque\n\n\n\nNous avons présenté ci-dessus les attributs d’instance, mais il est aussi possible de définir des attributs de classe qui seront donc les mêmes pour toutes les instances d’une même classe créées dans un programme. Ces attributs sont définis à l’intérieur de la classe, sans le préfixe self (puisque celui-ci fait référence à l’instance en train d’être créée).\nPar exemple, dans la définition de la classe Atome ci-dessous, la liste table est un attribut de classe, alors que l’entier np est un attribut d’instance. Dans la méthode __init__, on accède à l’attribut de classe en le préfixant par le nom de la classe Atome.table et on accède à l’attribut d’instance en le préfixant par le nom de l’instance self.np.\nclass Atome:\n\"\"\"atomes simplifiés, choisis parmi les 10 premiers éléments du TP\"\"\"\ntable = [None, ('hydrogène', 0), ('hélium', 2), ('lithium', 4), ('béryllium', 5),\n            ('bore', 6), ('carbone', 6), ('azote', 7), ('oxygène', 8), ('fluor', 10), ('néon', 10)]\n\ndef __init__(self, nat):\n    \"le n° atomique détermine le n. de protons, d'électrons et de neutrons\"\n    self.np, self.ne = nat, nat  # nat = numéro atomique\n    self.nn = Atome.table[nat][1]\n\ndef affiche(self):\n    print()\n    print(\"Nom de l'élément :\", Atome.table[self.np][0])\n    print(f\"{self.np} protons, {self.ne} électrons, {self.nn} neutrons\")\nDe la même façon, il est possible de définir des méthodes de classe."
  },
  {
    "objectID": "langagesProgr/POO_cours.html#représentation-simplifiée-dune-classe",
    "href": "langagesProgr/POO_cours.html#représentation-simplifiée-dune-classe",
    "title": "Programmation orientée objets (Cours)",
    "section": "Représentation simplifiée d’une classe",
    "text": "Représentation simplifiée d’une classe\nLorsqu’un module comportant plusieurs définitions de classe est développé, on peut réaliser une représentation graphique, appelée diagramme de classes qui permet de visualiser le nom de chaque classe, son interface (c’est-à-dire l’ensemble de ses attributs et méthodes publiques) et les relations éventuelles entre les différentes classes.\nUne présentation détaillée de ce type de diagramme n’est pas au programme, mais de manière simplifiée, le diagramme correspondant à la classe Rectangle pourrait ressembler à ce qui suit :\n\n\n\nDiagramme de classe\n\n\nDans des cases séparées, on place d’abord le nom de la classe, puis ses attributs et enfin ses méthodes. Un codage spécifique permet de préciser le type des différents membres, leur caractère public ou privé (voir les compléments à ce sujet) ou même leur état.\nUn attribut de classe ou une méthode de classe seront soulignés dans un tel diagramme.\nPour en savoir un peu plus sur les diagrammes de classes, je vous conseille ce document ou encore ce cours plus difficile.\n\nDes compléments sur la POO sont proposés à la suite de ce cours."
  },
  {
    "objectID": "langagesProgr/index.html",
    "href": "langagesProgr/index.html",
    "title": "Programme",
    "section": "",
    "text": "Points du programme traités dans cette séquence :\n\n\n\n\n\n\n\n\nContenus\nCapacités attendues\nCommentaires\n\n\n\n\nRécursivité.\nÉcrire un programme récursif. Analyser le fonctionnement d’un programme récursif.\nDes exemples relevant de domaines variés sont à privilégier.\n\n\nParadigmes de programmation.\nDistinguer sur des exemples les paradigmes impératif, fonctionnel et objet. Choisir le paradigme de programmation selon le champ d’application d’un programme.\nAvec un même langage de programmation, on peut utiliser des paradigmes différents. Dans un même programme, on peut utiliser des paradigmes différents.\n\n\nVocabulaire de la programmation objet : classes, attributs, méthodes, objets.\nÉcrire la définition d’une classe. Accéder aux attributs et méthodes d’une classe.\nOn n’aborde pas ici tous les aspects de la programmation objet comme le polymorphisme et l’héritage."
  },
  {
    "objectID": "langagesProgr/paradigmes_cours.html",
    "href": "langagesProgr/paradigmes_cours.html",
    "title": "Paradigmes de programmation (Cours)",
    "section": "",
    "text": "Tout d’abord, nous pouvons nous demander ce que signifie le mot paradigme. Parmi les trois définitions fournies par le dictionnaire Le Robert, celle qui nous intéresse est la suivante :\n\n\n\n\n\n\nDéfinition\n\n\n\n\nParadigme\n\nModèle de pensée.\n\n\n\n\nEn programmation, un paradigme est donc une manière de penser un programme, une méthode de programmation.\nUn programme est un texte, avec ses conventions d’écriture. Il s’agit bien d’un langage écrit, au sens commun, mais il doit toujours avoir un sens univoque et non contextuel.\nIl faut que la formulation textuelle d’un programme soit :\n\nsuffisamment proche d’un code réel, conforme à une famille d’ordinateurs particuliers ;\nstandardisée et générale pour permettre une adaptation immédiate et automatique — on parle de « portabilité » — à d’autres contextes similaires ;\nparfaitement univoque, non ambiguë, puisque destinée à un traitement automatique ;\nintelligible par un être humain.\n\nVu le grand nombre de langages existants, une classification s’est fait jour. On regroupe en général les langages en « familles » selon le paradigme de programmation auquel ils sont (le mieux) adaptés.\nConformément au programme, nous allons définir les paradigmes impératif, fonctionnel et objet.\nNotons tout d’abord que la plupart des langages de programmation modernes sont multiparadigmes : ils permettent de programmer aussi bien de façon impérative, fonctionnelle qu’avec des objets."
  },
  {
    "objectID": "langagesProgr/paradigmes_cours.html#paradigme-impératif",
    "href": "langagesProgr/paradigmes_cours.html#paradigme-impératif",
    "title": "Paradigmes de programmation (Cours)",
    "section": "Paradigme impératif",
    "text": "Paradigme impératif\nLa programmation impérative est la méthode de programmation que vous avez le plus couramment utilisée jusqu’à présent.\nIl s’agit d’un paradigme de programmation qui décrit les opérations en séquences d’instructions exécutées par l’ordinateur pour modifier l’état du programme.\nLa programmation impérative se concentre sur la description du fonctionnement d’un programme.\nLa plupart des langages de haut niveau comporte cinq types d’instructions principales :\n\nla séquence d’instructions\nl’assignation ou affectation\nl’instruction conditionnelle (if, else)\nla boucle (for, while)\nles branchements.\n\nCe type de programmation est le plus ancien et utilisé, il est facile à comprendre, souvent efficace, car proche des instructions réalisées par les processeurs. Par contre, il est assez difficile à tester, car l’état du programme ne cesse de changer et il est difficile de tester une petite partie du programme au milieu de son exécution par exemple, car elle nécessite que toutes les instructions précédentes aient déjà été appliquées correctement.\nLes langages C, C++, Java, JavaScript, Python et beaucoup d’autres permettent la programmation impérative."
  },
  {
    "objectID": "langagesProgr/paradigmes_cours.html#paradigme-fonctionnel",
    "href": "langagesProgr/paradigmes_cours.html#paradigme-fonctionnel",
    "title": "Paradigmes de programmation (Cours)",
    "section": "Paradigme fonctionnel",
    "text": "Paradigme fonctionnel\n\nIntroduction\nLe paradigme fonctionnel est un paradigme de programmation qui reprend les principes du lambda-calcul introduit par Alonzo Church dans les années 1930.\nL’idée fondamentale du lambda-calcul est de considérer que les fonctions sont des données comme les autres. Ainsi, elles peuvent être par exemple passées en paramètre à d’autres fonctions.\nD’autres principes découlent également de la thèse de Church :\n\nles fonctions sont des fonctions au sens mathématique du terme : elles se contentent de renvoyer une valeur en fonction de leurs arguments ;\nil n’y a pas de notion « d’état », ni à l’extérieur des fonctions, ni dans les fonctions. Un programme n’est donc qu’une composition de fonctions.\n\nLe paradigme fonctionnel a d’abord été implanté au sein de langages dédiés, plus ou moins « purement fonctionnel ». Parmi les langages dits fonctionnels, on peut citer :\n\nLISP (List Processing) : 1958 ;\nSML (Standard Meta Language) : 1983 ;\nCAML (Categorical Abstract Machine Language) : 1987, puis son extension objet OCAML ;\nHaskell : 1990 ;\nClojure : 2007.\n\nMais certains aspects du paradigme fonctionnel ont fini par être intégrés dans des langages impératifs, car ils présentent certains avantages :\n\nfonctions pures ;\nfonctions d’ordre supérieur ;\nlambda-expressions ;\névaluation paresseuse.\n\nEn programmation fonctionnelle, les variables sont toujours constantes : une fois qu’elles ont été affectées, leur valeur ne doit plus changer ; de plus les boucles sont remplacées par des appels récursifs.\n\n\nMise en œuvre en Python\n\nFonctions pures\nUne fonction pure est une fonction qui ne modifie rien ; elle ne fait que renvoyer des valeurs en fonction de ses paramètres. Et les valeurs renvoyées ne doivent dépendre que de ses paramètres, et pas de variables extérieures à la fonction.\nLes modifications qu’une fonction peut effectuer sur l’état du système sont appelées effets de bord. Un affichage à l’écran est un exemple d’effet de bord.\nEn Python, rien n’impose d’implémenter des fonctions pures. Notamment, étant donné la façon dont les arguments sont passés à une fonction en Python (utilisation d’une copie de la référence initiale), rien n’interdit qu’une fonction modifie l’objet référencé par l’un de ses paramètres.\nVoici un tel exemple :\ndef retirer_dernier(liste) :\n    liste.pop()\nOn utilise cette fonction ainsi :\n>>> ma_liste = [1, 2, 3]\n>>> retirer_dernier(ma_liste)\nL’inconvénient de ce type de fonction est qu’elle modifie la variable ma_liste qui, à l’issue de l’exécution des deux lignes précédentes contient [1, 2]. Cela peut rendre le code plus difficile à comprendre et générer des comportements inattendus. Une fonction pure, au contraire, doit renvoyer la valeur calculée sans modifier ses paramètres. Ainsi, on peut réécrire le traitement précédent de la façon suivante :\ndef retirer_dernier_pure(liste) :\n    retour = liste[:]\n    retour.pop()\n    return retour\nCette fonction s’utilise ainsi :\n>>> l1 = [1, 2, 3]\n>>> l2 = retirer_dernier_pure(l1)\nDans ce dernier cas, le fait que l’appel à retirer_dernier_pure ne modifie par l1 est bien plus intuitif.\n\n\n\n\n\n\nÀ retenir\n\n\n\nPour faciliter l’écriture de fonctions pures en Python, on peut :\n\nutiliser au maximum des données non mutables (tuples plutôt que listes par exemple) ;\ncopier systématiquement au début des fonctions les paramètres référençant des données mutables et utiliser ces copies dans la fonction.\non veille à ne pas modifier de valeur existante, mais plutôt à créer une nouvelle valeur à partir de la valeur existante.\n\n\n\nEssayer de n’écrire que des fonctions pures permet de limiter les risques de bugs et facilite la relecture des programmes. Il s’agit donc d’un style de programmation à privilégier.\n\n\n\nFonctions d’ordre supérieur\nLes fonctions étant considérées comme des données comme les autres, il est possible de définir des fonctions dont les arguments sont d’autres fonctions. On parle alors de fonctions d’ordre supérieur.\nPython fournit des fonctions d’ordre supérieur dans sa bibliothèque standard. Voyons par exemple la fonction map qui permet d’appliquer une fonction à tous les éléments d’une liste. Quelques remarques et explications s’imposent :\n\nmap peut s’appliquer à tout objet itérable, donc aux chaînes de caractères, aux tuples, aux listes.\nmap retourne un objet itérable : les valeurs résultat ne sont pas toutes calculées par avance, elles le seront à la demande. Cet itérable peut être transformé en liste en tapant list(map(...)) ou être utilisé dans une boucle for item in map(...):. Ce calcul des valeurs à la demande est une mise en œuvre du principe de l’évaluation paresseuse caractéristique de la programmation fonctionnelle.\n\nConsidérons le programme suivant :\ndef carre(x):\n    return x**2\n\n\ndef capit(ch):\n    return ch.capitalize()\n\n\nma_str = \"azerty\"\nmon_tuple = (1, 2, 3, 4, 5)\nma_liste = [1, 2, 3, 4, 5]\n\niter1 = map(capit, ma_str)\niter2 = map(carre, mon_tuple)\niter3 = map(carre, ma_liste)\n\nfor car in iter1:\n    print(car, end=\"\")\nprint()\nprint(tuple(iter2))\nprint(list(iter3))\nOn obtient en sortie :\nAZERTY\n(1, 4, 9, 16, 25)\n[1, 4, 9, 16, 25]\n\n\n\n\n\n\nRemarque\n\n\n\nLe programme ci-dessus est donné pour illustrer l’idée de fonction d’ordre supérieur, mais il n’est pas rédigé, notamment sa partie itérative, dans l’esprit de la programmation fonctionnelle !\n\n\nLes langages OCamL, Haskell, F#, Rust par exemple sont des langages fonctionnels."
  },
  {
    "objectID": "langagesProgr/paradigmes_cours.html#paradigme-objet",
    "href": "langagesProgr/paradigmes_cours.html#paradigme-objet",
    "title": "Paradigmes de programmation (Cours)",
    "section": "Paradigme objet",
    "text": "Paradigme objet\nLa POO consiste en la définition et l’interaction de briques logicielles appelées objets; un objet représente un concept, une idée ou toute entité du monde physique, comme une voiture, une personne ou encore une page d’un livre.\nUn objet possède:\n\ndes données: ses attributs et\ndes fonctions: ses méthodes\n\nLes différents principes de la conception orientée objet aident à la réutilisation du code, au masquage des données, etc. Les bases de la POO sont détaillées dans le cours précédent, avec ses compléments."
  },
  {
    "objectID": "langagesProgr/paradigmes_cours.html#à-quel-paradigme-se-vouer",
    "href": "langagesProgr/paradigmes_cours.html#à-quel-paradigme-se-vouer",
    "title": "Paradigmes de programmation (Cours)",
    "section": "À quel paradigme se vouer ?",
    "text": "À quel paradigme se vouer ?\nComment choisir entre les différents paradigmes existants ?\nIl est important de bien comprendre qu’un programmeur doit maitriser plusieurs paradigmes de programmation (impératif, objet ou encore fonctionnelle). En effet, il sera plus facile d’utiliser le paradigme objet dans certains cas alors que dans d’autres situations, l’utilisation du paradigme fonctionnel sera préférable. Être capable de choisir le “bon” paradigme en fonction des situations fait partie du bagage de tout bon programmeur.\nIl est aussi important de bien comprendre que la frontière entre ces différents paradigmes est parfois floue, par exemple on utilise très souvent de l’impératif en programmation orientée objet.\nDans l’article Perceiving Python programming paradigms du site opensource.com/, les conseils suivants sont donnés :\n\nPour simplifier, si votre problème implique une série de manipulations séquentielles simples, suivre le paradigme de programmation impérative de la vieille école serait le moins cher en termes de temps et d’efforts et vous donnerait potentiellement les meilleures performances.\nDans le cas de problèmes nécessitant des transformations mathématiques des valeurs, le filtrage des informations, le mappage (transformer une liste en une autre) et les réductions (transformer une liste en une valeur), la programmation fonctionnelle pourrait être adaptée.\nSi le problème est structuré comme un tas d’objets interdépendants avec certains attributs qui peuvent changer avec le temps, en fonction de certaines conditions, la programmation orientée objet sera certainement la plus naturelle.\n\nBien sûr, il n’y a pas de règle simple, car le choix du paradigme de programmation dépend également fortement du type de données à traiter, des connaissances des programmeurs et de diverses autres choses comme l’évolutivité.\nNotons pour finir que cette courte présentation ne recouvre pas tous les paradigmes de programmation existants. On rencontrera notamment l’idée de programmation événementielle lors du développement d’interfaces graphiques."
  },
  {
    "objectID": "ressources.html",
    "href": "ressources.html",
    "title": "Sources utilisées",
    "section": "",
    "text": "Pour rédiger ce cours et préparer les exercices, TP, projets présentés ici, j’ai utilisé de nombreuses sources que je vais essayer de citer ici, sans prétendre être exhaustif.\n\nDocuments d’accompagnement Eduscol.\nContenus du MOOC “Numérique et Sciences Informatiques : les fondamentaux” de l’INRIA, disponible sur la plateforme fun-mooc.\nApprendre à programmer avec Python 3, Gérard Swinnen, éditions Eyrolles, 2012. Disponible en ligne\nLe site interstices : https://interstices.info/.\nLes images et illustrations sont soit produites par mes soins, soit issues de Pixabay ou de Wikimedia commons ou encore de Pexels et, dans tous les cas, libres de droits.\nCours de David Roche.\nCours de Frédéric Junier.\nCours de Van Zuijlen Stéphan.\nCours de Konieczko Quentin\nCours de Olivier Lécluse\nCours du Lycée Blaise Pascal de Clermont-Ferrand\nCours du lycée Champollion de Grenoble\nCours du site Lyceum\nCours du site Mon Lycée Numérique\nCours du Lycée Stanislas de Wissembourg\nCours d’informatique de François Brucker (école Centrale de Marseille)\nCours de Philippe Rigaux sur les bases de données.\nCours de Gilles Lassus\nLe site MDN Web Docs : excellentissime ressource pour tout apprendre sur les langages HTML, CSS, Javascript et le protocole HTTP.\nLe site de M. JANVIER."
  },
  {
    "objectID": "bac/index.html",
    "href": "bac/index.html",
    "title": "Épreuve de NSI au bac en Terminale",
    "section": "",
    "text": "Fichier à télécharger…"
  },
  {
    "objectID": "bac/index.html#nature-de-lépreuve-de-nsi-au-bac-en-terminale",
    "href": "bac/index.html#nature-de-lépreuve-de-nsi-au-bac-en-terminale",
    "title": "Épreuve de NSI au bac en Terminale",
    "section": "Nature de l’épreuve de NSI au bac en Terminale",
    "text": "Nature de l’épreuve de NSI au bac en Terminale\nD’après le Bulletin Officiel n°36 du 30 septembre 2022 :\n\nDurée : 3 heures 30 + 1 heure\nCoefficient : 16\nFormat : L’épreuve terminale obligatoire de spécialité est composée de deux parties :\n\nune partie écrite, comptant pour 12 points sur 20,\nune partie pratique comptant pour 8 points sur 20.\n\n\nPartie écrite de l’épreuve de NSI au bac en terminale\n\nDurée : 3 heures 30\nModalités : La partie écrite consiste en la résolution de trois exercices permettant d’évaluer les connaissances et les capacités attendues conformément aux programmes de première et de terminale de la spécialité.\nChaque exercice est noté sur 4 points.\nLe sujet comporte trois exercices indépendants les uns des autres, qui permettent d’évaluer les connaissances et compétences des candidats.\n\n\nPoints du programme évaluables lors de l’épreuve écrite\nRéférence : Bulletin officiel n°36 du 30 septembre 2022\n\nThème 2 – Structures de données\n\nStructures de données, interface et implémentation.\nVocabulaire de la programmation objet : classes, attributs, méthodes, objets.\nListes, piles, files : structures linéaires. Dictionnaires, index et clé.\nArbres : structures hiérarchiques. Arbres binaires : nœuds, racines, feuilles, sous-arbres gauches, sous-arbres droits.\n\nThème 3 – Bases de données\n\nModèle relationnel : relation, attribut, domaine, clef primaire, clef étrangère, schéma relationnel.\nBase de données relationnelle.\nLangage SQL : requêtes d’interrogation et de mise à jour d’une base de données.\n\nThème 4 – Architectures matérielles, systèmes d’exploitation et réseaux\n\nGestion des processus et des ressources par un système d’exploitation.\nProtocoles de routage.\n\nThème 5 – Langages et programmation\n\nRécursivité.\nModularité.\nMise au point des programmes. Gestion des bugs.\n\nThème 6 – Algorithmique\n\nAlgorithmes sur les arbres binaires et sur les arbres binaires de recherche.\nMéthode « diviser pour régner »\n\n\n\n\nPoints du programme non évalués à l’écrit\n\nThème 1 – Histoire de l’informatique\nThème 2 – Structures de données\n\nGraphes : structures relationnelles. Sommets, arcs, arêtes, graphes orientés ou non orientés.\n\nThème 3 – Bases de données\n\nSystème de gestion de bases de données relationnelles.\n\nThème 4 – Architectures matérielles, systèmes d’exploitation et réseaux\n\nComposants intégrés d’un système sur puce.\nSécurisation des communications.\n\nThème 5 – Langages et programmation\n\nNotion de programme en tant que donnée. Calculabilité, décidabilité.\nParadigmes de programmation\n\nThème 6 – Algorithmique\n\nAlgorithmes sur les graphes.\nProgrammation dynamique.\nRecherche textuelle."
  },
  {
    "objectID": "bac/index.html#partie-pratique-de-lépreuve-de-nsi-au-bac-en-terminale",
    "href": "bac/index.html#partie-pratique-de-lépreuve-de-nsi-au-bac-en-terminale",
    "title": "Épreuve de NSI au bac en Terminale",
    "section": "Partie pratique de l’épreuve de NSI au bac en terminale",
    "text": "Partie pratique de l’épreuve de NSI au bac en terminale\n\nDurée : 1 heure\nModalités : La partie pratique consiste en la résolution de deux exercices sur ordinateur, chacun étant noté sur 4 points.\nLe candidat est évalué sur la base d’un dialogue avec un professeur-examinateur.\nUn examinateur évalue au maximum quatre élèves. L’examinateur ne peut pas évaluer un élève qu’il a eu en classe durant l’année en cours.\nL’évaluation de cette partie se déroule au cours du deuxième trimestre pendant la période de l’épreuve écrite de spécialité.\n\nPremier exercice\nLe premier exercice consiste à programmer un algorithme figurant explicitement au programme, ne présentant pas de difficulté particulière, dont on fournit une spécification.\nIl s’agit donc de restituer un algorithme rencontré et travaillé à plusieurs reprises en cours de formation.\nLe sujet peut proposer un jeu de test avec les réponses attendues pour permettre au candidat de vérifier son travail.\nDeuxième exercice\nPour le second exercice, un programme est fourni au candidat.\nCet exercice ne demande pas l’écriture complète d’un programme, mais permet de valider des compétences de programmation suivant des modalités variées : le candidat doit, par exemple, compléter un programme « à trous » afin de répondre à une spécification donnée, ou encore compléter un programme pour le documenter, ou encore compléter un programme en ajoutant des assertions, etc."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Spécialité NSI - Terminale",
    "section": "",
    "text": "Bienvenue !\nCe site est destiné à regrouper les cours et les exercices concernant l’enseignement de spécialité NSI de terminale du lycée Emile Duclaux d’Aurillac.\nLien vers l’ENT du lycée : https://cas.ent.auvergnerhonealpes.fr/login"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  }
]