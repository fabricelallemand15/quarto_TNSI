% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
\PassOptionsToPackage{dvipsnames,svgnames,x11names}{xcolor}
%
\documentclass[
  a4paper,
  DIV=11,
  numbers=noendperiod]{scrartcl}

\usepackage{amsmath,amssymb}
\usepackage{iftex}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
\usepackage{lmodern}
\ifPDFTeX\else  
    % xetex/luatex font selection
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\usepackage[top=20mm,bottom=20mm,left=20mm,right=20mm,heightrounded]{geometry}
\setlength{\emergencystretch}{3em} % prevent overfull lines
\setcounter{secnumdepth}{-\maxdimen} % remove section numbering
% Make \paragraph and \subparagraph free-standing
\ifx\paragraph\undefined\else
  \let\oldparagraph\paragraph
  \renewcommand{\paragraph}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
  \let\oldsubparagraph\subparagraph
  \renewcommand{\subparagraph}[1]{\oldsubparagraph{#1}\mbox{}}
\fi

\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{241,243,245}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.40,0.45,0.13}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\BuiltInTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\ExtensionTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.28,0.35,0.67}{#1}}
\newcommand{\ImportTok}[1]{\textcolor[rgb]{0.00,0.46,0.62}{#1}}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\NormalTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\RegionMarkerTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.07,0.07,0.07}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}

\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}\usepackage{longtable,booktabs,array}
\usepackage{calc} % for calculating minipage widths
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\usepackage{graphicx}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
% Set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother

\usepackage{fancyhdr} \pagestyle{fancy} \usepackage{lastpage}
\KOMAoption{captions}{tablesignature}
\makeatletter
\@ifpackageloaded{tcolorbox}{}{\usepackage[skins,breakable]{tcolorbox}}
\@ifpackageloaded{fontawesome5}{}{\usepackage{fontawesome5}}
\definecolor{quarto-callout-color}{HTML}{909090}
\definecolor{quarto-callout-note-color}{HTML}{0758E5}
\definecolor{quarto-callout-important-color}{HTML}{CC1914}
\definecolor{quarto-callout-warning-color}{HTML}{EB9113}
\definecolor{quarto-callout-tip-color}{HTML}{00A047}
\definecolor{quarto-callout-caution-color}{HTML}{FC5300}
\definecolor{quarto-callout-color-frame}{HTML}{acacac}
\definecolor{quarto-callout-note-color-frame}{HTML}{4582ec}
\definecolor{quarto-callout-important-color-frame}{HTML}{d9534f}
\definecolor{quarto-callout-warning-color-frame}{HTML}{f0ad4e}
\definecolor{quarto-callout-tip-color-frame}{HTML}{02b875}
\definecolor{quarto-callout-caution-color-frame}{HTML}{fd7e14}
\makeatother
\makeatletter
\makeatother
\makeatletter
\makeatother
\makeatletter
\@ifpackageloaded{caption}{}{\usepackage{caption}}
\AtBeginDocument{%
\ifdefined\contentsname
  \renewcommand*\contentsname{Table des matières}
\else
  \newcommand\contentsname{Table des matières}
\fi
\ifdefined\listfigurename
  \renewcommand*\listfigurename{Liste des Figures}
\else
  \newcommand\listfigurename{Liste des Figures}
\fi
\ifdefined\listtablename
  \renewcommand*\listtablename{Liste des Tables}
\else
  \newcommand\listtablename{Liste des Tables}
\fi
\ifdefined\figurename
  \renewcommand*\figurename{Figure}
\else
  \newcommand\figurename{Figure}
\fi
\ifdefined\tablename
  \renewcommand*\tablename{Tableau}
\else
  \newcommand\tablename{Tableau}
\fi
}
\@ifpackageloaded{float}{}{\usepackage{float}}
\floatstyle{ruled}
\@ifundefined{c@chapter}{\newfloat{codelisting}{h}{lop}}{\newfloat{codelisting}{h}{lop}[chapter]}
\floatname{codelisting}{Listing}
\newcommand*\listoflistings{\listof{codelisting}{Liste des Listings}}
\makeatother
\makeatletter
\@ifpackageloaded{caption}{}{\usepackage{caption}}
\@ifpackageloaded{subcaption}{}{\usepackage{subcaption}}
\makeatother
\makeatletter
\@ifpackageloaded{tcolorbox}{}{\usepackage[skins,breakable]{tcolorbox}}
\makeatother
\makeatletter
\@ifundefined{shadecolor}{\definecolor{shadecolor}{rgb}{.97, .97, .97}}
\makeatother
\makeatletter
\makeatother
\makeatletter
\makeatother
\ifLuaTeX
\usepackage[bidi=basic]{babel}
\else
\usepackage[bidi=default]{babel}
\fi
\babelprovide[main,import]{french}
% get rid of language-specific shorthands (see #6817):
\let\LanguageShortHands\languageshorthands
\def\languageshorthands#1{}
\ifLuaTeX
  \usepackage{selnolig}  % disable illegal ligatures
\fi
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\urlstyle{same} % disable monospaced font for URLs
\hypersetup{
  pdftitle={Paradigmes de programmation (Cours)},
  pdflang={fr},
  colorlinks=true,
  linkcolor={blue},
  filecolor={Maroon},
  citecolor={Blue},
  urlcolor={Blue},
  pdfcreator={LaTeX via pandoc}}

\title{Paradigmes de programmation (Cours)}
\usepackage{etoolbox}
\makeatletter
\providecommand{\subtitle}[1]{% add subtitle to \maketitle
  \apptocmd{\@title}{\par {\large #1 \par}}{}{}
}
\makeatother
\subtitle{S1 - Langages et programmation}
\author{}
\date{}

\begin{document}
\maketitle
\lhead{Spécialité NSI} \rhead{Terminale} \chead{} \cfoot{} \lfoot{Lycée \'Emile Duclaux} \rfoot{Page \thepage/\pageref{LastPage}} \renewcommand{\headrulewidth}{0pt} \renewcommand{\footrulewidth}{0pt} \thispagestyle{fancy} \vspace{-2cm}

\ifdefined\Shaded\renewenvironment{Shaded}{\begin{tcolorbox}[sharp corners, interior hidden, boxrule=0pt, enhanced, borderline west={3pt}{0pt}{shadecolor}, breakable, frame hidden]}{\end{tcolorbox}}\fi

\hypertarget{introduction-et-duxe9finition}{%
\subsection{Introduction et
définition}\label{introduction-et-duxe9finition}}

Tout d'abord, nous pouvons nous demander ce que signifie le mot
\textbf{paradigme}. Parmi les trois définitions fournies par le
\href{https://dictionnaire.lerobert.com/definition/paradigme}{dictionnaire
Le Robert}, celle qui nous intéresse est la suivante :

\begin{tcolorbox}[enhanced jigsaw, opacityback=0, rightrule=.15mm, toptitle=1mm, colframe=quarto-callout-note-color-frame, colbacktitle=quarto-callout-note-color!10!white, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Définition}, toprule=.15mm, titlerule=0mm, bottomrule=.15mm, coltitle=black, bottomtitle=1mm, left=2mm, breakable, arc=.35mm, leftrule=.75mm, colback=white, opacitybacktitle=0.6]

\begin{description}
\tightlist
\item[\textbf{Paradigme}]
Modèle de pensée.
\end{description}

\end{tcolorbox}

En programmation, un paradigme est donc une manière de penser un
programme, une méthode de programmation.

Un programme est un texte, avec ses conventions d'écriture. Il s'agit
bien d'un langage écrit, au sens commun, mais il doit toujours avoir un
sens \textbf{univoque} et non contextuel.

Il faut que la formulation textuelle d'un programme soit :

\begin{itemize}
\tightlist
\item
  suffisamment proche d'un code réel, conforme à une famille
  d'ordinateurs particuliers ;
\item
  standardisée et générale pour permettre une adaptation immédiate et
  automatique --- on parle de « portabilité » --- à d'autres contextes
  similaires ;
\item
  parfaitement univoque, non ambiguë, puisque destinée à un traitement
  automatique ;
\item
  intelligible par un être humain.
\end{itemize}

Vu le grand nombre de langages existants, une classification s'est fait
jour. On regroupe en général les langages en « familles » selon le
paradigme de programmation auquel ils sont (le mieux) adaptés.

Conformément au programme, nous allons définir les paradigmes
\textbf{impératif}, \textbf{fonctionnel} et \textbf{objet}.

Notons tout d'abord que la plupart des langages de programmation
modernes sont \textbf{multiparadigmes} : ils permettent de programmer
aussi bien de façon impérative, fonctionnelle qu'avec des objets.

\hypertarget{paradigme-impuxe9ratif}{%
\subsection{Paradigme impératif}\label{paradigme-impuxe9ratif}}

La programmation \textbf{impérative} est la méthode de programmation que
vous avez le plus couramment utilisée jusqu'à présent.

Il s'agit d'un paradigme de programmation qui décrit les opérations en
séquences d'instructions exécutées par l'ordinateur pour modifier l'état
du programme.

La programmation impérative se concentre sur la description du
fonctionnement d'un programme.

La plupart des langages de haut niveau comporte cinq types
d'instructions principales :

\begin{itemize}
\tightlist
\item
  la séquence d'instructions
\item
  l'assignation ou affectation
\item
  l'instruction conditionnelle (if, else)
\item
  la boucle (for, while)
\item
  les branchements.
\end{itemize}

Ce type de programmation est le plus ancien et utilisé, il est facile à
comprendre, souvent efficace, car proche des instructions réalisées par
les processeurs. Par contre, il est assez difficile à tester, car l'état
du programme ne cesse de changer et il est difficile de tester une
petite partie du programme au milieu de son exécution par exemple, car
elle nécessite que toutes les instructions précédentes aient déjà été
appliquées correctement.

Les langages C, C++, Java, JavaScript, Python et beaucoup d'autres
permettent la programmation impérative.

\hypertarget{paradigme-fonctionnel}{%
\subsection{Paradigme fonctionnel}\label{paradigme-fonctionnel}}

\hypertarget{introduction}{%
\subsubsection{Introduction}\label{introduction}}

Le paradigme fonctionnel est un paradigme de programmation qui reprend
les principes du lambda-calcul introduit par
\href{https://fr.wikipedia.org/wiki/Alonzo_Church}{Alonzo Church} dans
les années 1930.

L'idée fondamentale du lambda-calcul est de considérer que les fonctions
sont des données comme les autres. Ainsi, elles peuvent être par exemple
passées en paramètre à d'autres fonctions.

D'autres principes découlent également de la thèse de Church :

\begin{itemize}
\tightlist
\item
  les fonctions sont des fonctions au sens mathématique du terme : elles
  se contentent de renvoyer une valeur en fonction de leurs arguments ;
\item
  il n'y a pas de notion « d'état », ni à l'extérieur des fonctions, ni
  dans les fonctions. Un programme n'est donc qu'une composition de
  fonctions.
\end{itemize}

Le paradigme fonctionnel a d'abord été implanté au sein de langages
dédiés, plus ou moins « purement fonctionnel ». Parmi les langages dits
fonctionnels, on peut citer :

\begin{itemize}
\tightlist
\item
  LISP (List Processing) : 1958 ;
\item
  SML (Standard Meta Language) : 1983 ;
\item
  CAML (Categorical Abstract Machine Language) : 1987, puis son
  extension objet OCAML ;
\item
  Haskell : 1990 ;
\item
  Clojure : 2007.
\end{itemize}

Mais certains aspects du paradigme fonctionnel ont fini par être
intégrés dans des langages impératifs, car ils présentent certains
avantages :

\begin{itemize}
\tightlist
\item
  fonctions pures ;
\item
  fonctions d'ordre supérieur ;
\item
  lambda-expressions ;
\item
  évaluation paresseuse.
\end{itemize}

En programmation fonctionnelle, les variables sont toujours constantes :
une fois qu'elles ont été affectées, leur valeur ne doit plus changer ;
de plus les boucles sont remplacées par des appels récursifs.

\hypertarget{mise-en-ux153uvre-en-python}{%
\subsubsection{Mise en œuvre en
Python}\label{mise-en-ux153uvre-en-python}}

\hypertarget{fonctions-pures}{%
\paragraph{Fonctions pures}\label{fonctions-pures}}

Une fonction pure est une fonction qui ne modifie rien ; elle ne fait
que renvoyer des valeurs en fonction de ses paramètres. Et les valeurs
renvoyées ne doivent dépendre que de ses paramètres, et pas de variables
extérieures à la fonction.

Les modifications qu'une fonction peut effectuer sur l'état du système
sont appelées \textbf{effets de bord}. Un affichage à l'écran est un
exemple d'effet de bord.

En Python, rien n'impose d'implémenter des fonctions pures. Notamment,
étant donné la façon dont les arguments sont passés à une fonction en
Python (utilisation d'une copie de la référence initiale), rien
n'interdit qu'une fonction modifie l'objet référencé par l'un de ses
paramètres.

Voici un tel exemple :

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ retirer\_dernier(liste) :}
\NormalTok{    liste.pop()}
\end{Highlighting}
\end{Shaded}

On utilise cette fonction ainsi :

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\textgreater{}\textgreater{}\textgreater{}}\NormalTok{ ma\_liste }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{]}
\OperatorTok{\textgreater{}\textgreater{}\textgreater{}}\NormalTok{ retirer\_dernier(ma\_liste)}
\end{Highlighting}
\end{Shaded}

L'inconvénient de ce type de fonction est qu'elle modifie la variable
\texttt{ma\_liste} qui, à l'issue de l'exécution des deux lignes
précédentes contient \texttt{{[}1,\ 2{]}}. Cela peut rendre le code plus
difficile à comprendre et générer des comportements inattendus. Une
fonction pure, au contraire, doit renvoyer la valeur calculée sans
modifier ses paramètres. Ainsi, on peut réécrire le traitement précédent
de la façon suivante :

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ retirer\_dernier\_pure(liste) :}
\NormalTok{    retour }\OperatorTok{=}\NormalTok{ liste[:]}
\NormalTok{    retour.pop()}
    \ControlFlowTok{return}\NormalTok{ retour}
\end{Highlighting}
\end{Shaded}

Cette fonction s'utilise ainsi :

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\textgreater{}\textgreater{}\textgreater{}}\NormalTok{ l1 }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{]}
\OperatorTok{\textgreater{}\textgreater{}\textgreater{}}\NormalTok{ l2 }\OperatorTok{=}\NormalTok{ retirer\_dernier\_pure(l1)}
\end{Highlighting}
\end{Shaded}

Dans ce dernier cas, le fait que l'appel à
\texttt{retirer\_dernier\_pure} ne modifie par \texttt{l1} est bien plus
intuitif.

\begin{tcolorbox}[enhanced jigsaw, opacityback=0, rightrule=.15mm, toptitle=1mm, colframe=quarto-callout-important-color-frame, colbacktitle=quarto-callout-important-color!10!white, title=\textcolor{quarto-callout-important-color}{\faExclamation}\hspace{0.5em}{À retenir}, toprule=.15mm, titlerule=0mm, bottomrule=.15mm, coltitle=black, bottomtitle=1mm, left=2mm, breakable, arc=.35mm, leftrule=.75mm, colback=white, opacitybacktitle=0.6]

Pour faciliter l'écriture de fonctions pures en Python, on peut :

\begin{itemize}
\tightlist
\item
  utiliser au maximum des données non mutables (tuples plutôt que listes
  par exemple) ;
\item
  copier systématiquement au début des fonctions les paramètres
  référençant des données mutables et utiliser ces copies dans la
  fonction.
\item
  on veille à ne pas modifier de valeur existante, mais plutôt à créer
  une nouvelle valeur à partir de la valeur existante.
\end{itemize}

\end{tcolorbox}

Essayer de n'écrire que des fonctions pures permet de limiter les
risques de bugs et facilite la relecture des programmes. Il s'agit donc
d'un style de programmation à privilégier.

\hypertarget{fonctions-dordre-supuxe9rieur}{%
\subsubsection{Fonctions d'ordre
supérieur}\label{fonctions-dordre-supuxe9rieur}}

Les fonctions étant considérées comme des données comme les autres, il
est possible de définir des fonctions dont les arguments sont d'autres
fonctions. On parle alors de \textbf{fonctions d'ordre supérieur}.

Python fournit des fonctions d'ordre supérieur dans sa bibliothèque
standard. Voyons par exemple la fonction \texttt{map} qui permet
d'appliquer une fonction à tous les éléments d'une liste. Quelques
remarques et explications s'imposent :

\begin{itemize}
\tightlist
\item
  \texttt{map} peut s'appliquer à tout objet \emph{itérable}, donc aux
  chaînes de caractères, aux tuples, aux listes.
\item
  \texttt{map} retourne un objet itérable : les valeurs résultat ne sont
  pas toutes calculées par avance, elles le seront à la demande. Cet
  itérable peut être transformé en liste en tapant
  \texttt{list(map(...))} ou être utilisé dans une boucle
  \texttt{for\ item\ in\ map(...):}. Ce calcul des valeurs à la demande
  est une mise en œuvre du principe de l'\textbf{évaluation paresseuse}
  caractéristique de la programmation fonctionnelle.
\end{itemize}

Considérons le programme suivant :

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ carre(x):}
    \ControlFlowTok{return}\NormalTok{ x}\OperatorTok{**}\DecValTok{2}


\KeywordTok{def}\NormalTok{ capit(ch):}
    \ControlFlowTok{return}\NormalTok{ ch.capitalize()}


\NormalTok{ma\_str }\OperatorTok{=} \StringTok{"azerty"}
\NormalTok{mon\_tuple }\OperatorTok{=}\NormalTok{ (}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{)}
\NormalTok{ma\_liste }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{]}

\NormalTok{iter1 }\OperatorTok{=} \BuiltInTok{map}\NormalTok{(capit, ma\_str)}
\NormalTok{iter2 }\OperatorTok{=} \BuiltInTok{map}\NormalTok{(carre, mon\_tuple)}
\NormalTok{iter3 }\OperatorTok{=} \BuiltInTok{map}\NormalTok{(carre, ma\_liste)}

\ControlFlowTok{for}\NormalTok{ car }\KeywordTok{in}\NormalTok{ iter1:}
    \BuiltInTok{print}\NormalTok{(car, end}\OperatorTok{=}\StringTok{""}\NormalTok{)}
\BuiltInTok{print}\NormalTok{()}
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{tuple}\NormalTok{(iter2))}
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{list}\NormalTok{(iter3))}
\end{Highlighting}
\end{Shaded}

On obtient en sortie :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{AZERTY}
\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{9}\NormalTok{, }\DecValTok{16}\NormalTok{, }\DecValTok{25}\NormalTok{)}
\NormalTok{[}\DecValTok{1}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{9}\NormalTok{, }\DecValTok{16}\NormalTok{, }\DecValTok{25}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{tcolorbox}[enhanced jigsaw, opacityback=0, rightrule=.15mm, toptitle=1mm, colframe=quarto-callout-warning-color-frame, colbacktitle=quarto-callout-warning-color!10!white, title=\textcolor{quarto-callout-warning-color}{\faExclamationTriangle}\hspace{0.5em}{Remarque}, toprule=.15mm, titlerule=0mm, bottomrule=.15mm, coltitle=black, bottomtitle=1mm, left=2mm, breakable, arc=.35mm, leftrule=.75mm, colback=white, opacitybacktitle=0.6]

Le programme ci-dessus est donné pour illustrer l'idée de fonction
d'ordre supérieur, mais il n'est pas rédigé, notamment sa partie
itérative, dans l'esprit de la programmation fonctionnelle !

\end{tcolorbox}

Les langages OCamL, Haskell, F\#, Rust par exemple sont des langages
fonctionnels.

\hypertarget{paradigme-objet}{%
\subsection{Paradigme objet}\label{paradigme-objet}}

La POO consiste en la définition et l'interaction de briques logicielles
appelées objets; un objet représente un concept, une idée ou toute
entité du monde physique, comme une voiture, une personne ou encore une
page d'un livre.

Un objet possède:

\begin{itemize}
\tightlist
\item
  des données: ses \textbf{attributs} et
\item
  des fonctions: ses \textbf{méthodes}
\end{itemize}

Les différents principes de la conception orientée objet aident à la
réutilisation du code, au masquage des données, etc. Les bases de la POO
sont détaillées dans le \href{POO_cours.qmd}{cours précédent}, avec ses
\href{POO_complements.qmd}{compléments}.

\hypertarget{uxe0-quel-paradigme-se-vouer}{%
\subsection{À quel paradigme se vouer
?}\label{uxe0-quel-paradigme-se-vouer}}

Comment choisir entre les différents paradigmes existants ?

Il est important de bien comprendre qu'un programmeur doit maitriser
plusieurs paradigmes de programmation (impératif, objet ou encore
fonctionnelle). En effet, il sera plus facile d'utiliser le paradigme
objet dans certains cas alors que dans d'autres situations,
l'utilisation du paradigme fonctionnel sera préférable. Être capable de
choisir le ``bon'' paradigme en fonction des situations fait partie du
bagage de tout bon programmeur.

Il est aussi important de bien comprendre que la frontière entre ces
différents paradigmes est parfois floue, par exemple on utilise très
souvent de l'impératif en programmation orientée objet.

Dans l'article
\href{https://opensource.com/article/19/10/python-programming-paradigms}{Perceiving
Python programming paradigms} du site
\href{https://opensource.com/}{opensource.com/}, les conseils suivants
sont donnés :

\begin{itemize}
\tightlist
\item
  Pour simplifier, si votre problème implique une série de manipulations
  séquentielles simples, suivre le paradigme de programmation impérative
  de la vieille école serait le moins cher en termes de temps et
  d'efforts et vous donnerait potentiellement les meilleures
  performances.
\item
  Dans le cas de problèmes nécessitant des transformations mathématiques
  des valeurs, le filtrage des informations, le mappage (transformer une
  liste en une autre) et les réductions (transformer une liste en une
  valeur), la programmation fonctionnelle pourrait être adaptée.
\item
  Si le problème est structuré comme un tas d'objets interdépendants
  avec certains attributs qui peuvent changer avec le temps, en fonction
  de certaines conditions, la programmation orientée objet sera
  certainement la plus naturelle.
\end{itemize}

Bien sûr, il n'y a pas de règle simple, car le choix du paradigme de
programmation dépend également fortement du type de données à traiter,
des connaissances des programmeurs et de diverses autres choses comme
l'évolutivité.

Notons pour finir que cette courte présentation ne recouvre pas tous les
paradigmes de programmation existants. On rencontrera notamment l'idée
de \textbf{programmation événementielle} lors du développement
d'interfaces graphiques.



\end{document}
