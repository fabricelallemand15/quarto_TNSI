{"title":"Programmation orientée objets (Compléments)","markdown":{"yaml":{"title":"Programmation orientée objets (Compléments)","subtitle":"S1 - Langages et programmation","lang":"fr","tbl-cap-location":"bottom","crossref":{"eq-prefix":"Éq.","tbl-prefix":"Tableau","tbl-title":"Tableau"},"format":{"html":"default","pdf":{"geometry":["top=20mm","bottom=20mm","left=20mm","right=20mm","heightrounded"],"include-in-header":[{"text":"\\usepackage{fancyhdr} \\pagestyle{fancy} \\usepackage{lastpage}"}],"include-before-body":[{"text":"\\lhead{Spécialité NSI} \\rhead{Terminale} \\chead{} \\cfoot{} \\lfoot{Lycée \\'Emile Duclaux} \\rfoot{Page \\thepage/\\pageref{LastPage}} \\renewcommand{\\headrulewidth}{0pt} \\renewcommand{\\footrulewidth}{0pt} \\thispagestyle{fancy} \\vspace{-2cm}"}],"biblio-title":"Sources utilisées","reference-location":"document","keep-tex":true}},"format-links":["pdf","tex"]},"headingText":"Avertissement","containsRefs":false,"markdown":"\n\n::: {.callout-warning}\n\nLes compléments présentés ici sont hors programme. Ils peuvent néanmoins apporter une connaissance et une compréhension plus fine de la POO et être utiles dans le cadre du travail sur les projets.\n:::\n\n## Principes et définitions\n\n**Objet**\n: Un **objet** est une donnée manipulable par un programme : il s'agit d'un conteneur pour une _valeur_ ou un _état_ auquel est associé un _ensemble d'opérations_. Cet objet est associé à un **type**, défini comme l'ensemble des valeurs possibles, cette liste d'opérations, ainsi que leur codage (binaire).\n\nUn objet est identifié dans un programme par un _nom_ ou une _notation littérale_, mais peut parfois être _anonyme_ (comme les variables temporaires ou les composantes d'un tableau).\n\nEt pour une définition d'un langage orienté objet, l'idée première que l'on retrouve dans la définition de wikipédia offre un cadre intéressant : un langage objet doit permettre l'analyse et le développement logiciel fondés sur des _relations entre objets_. \n\nConcrètement, un objet est une structure de données qui répond à un ensemble de messages. Cette structure de données définit son état tandis que l'ensemble des messages qu'il comprend décrit son comportement :\n\n- les données, ou champs, qui décrivent sa structure interne sont appelées ses **attributs** ;\n- l'ensemble des messages forme ce que l'on appelle l'interface de l'objet ; c'est seulement au travers de celle-ci que les objets interagissent entre eux. La réponse à la réception d'un message par un objet est appelée une **méthode** (méthode de mise en œuvre du message) ; elle décrit quelle réponse doit être donnée au message.\n\nLes attributs et les méthodes constituent les **membres** d'un objet. Un objet possède un **type**.\n\nEn Python, un objet la création d'un objet se fait en utilisant une **classe** : un objet est alors une instance de sa classe. La **classe** est un _type_, un ensemble d'objets partageant les mêmes propriétés concrétisées par une liste de membres.\n\n**Langage orienté objet**\n: Un **langage orienté objet** est un langage de programmation qui comporte de manière native les éléments suivants : l'_encapsulation_, l'_héritage_, le _polymorphisme_ et la _programmation générique_.\n\n## Les principes clés de la POO\n\n### L'encapsulation\n\nCertains membres (ou plus exactement leur représentation informatique) sont cachés : c'est le principe d'**[encapsulation](https://fr.wikipedia.org/wiki/Encapsulation_(programmation))**. Ainsi, le programme peut modifier la structure interne des objets ou leurs méthodes associées sans avoir d'impact sur les utilisateurs de l'objet. C'est un des principes fondamentaux notamment pour la robustesse du code.\n\nEn particulier, les bonnes pratiques de POO recommandent de na pas permettre un accès direct aux attributs d'un objet à l'extérieur de celui-ci. On appelle **interface** d'un objet l'ensemble de ses membres qui sont accessibles à l'extérieur de celui-ci. L'interface ne devrait donc contenir que des méthodes. Pas forcément toutes, certaines méthodes (comme `__init__`) restent privées.\n\nContrairement à d'autres langages, Python offre une totale liberté de modification sur les membres d'un objet. C'est au programmeur de rester vigilant. Il existe néanmoins des conventions permettant d'identifier les membres de l'interface des autres membres d'un objet.\n\n::: {.callout-important}\n## Conventions de nommage en Python\n\n* un nom d'attribut commençant par un double underscore `__` désigne un attribut privé.\n* une méthode dont le nom est de la forme ``__nom__`` désigne une méthode privée.\n:::\n\nMais alors si les attributs doivent rester privés, comment y accéder, et comment les modifier ?\n\nIl convient pour cela, en toute rigueur, de définir des méthodes ad-hoc : une méthode qui permet d'accéder à un attribut est un `getter`, une période qui permet de changer la valeur d'un attribut est un `setter`.\n\nVoici par exemple une nouvelle définition de la classe \"Rectangle\" tenant compte des remarques précédentes.\n\n````python\nclass Rectangle:\n    \"\"\"Représente un rectangle\"\"\"\n\n    def __init__(self, largeur=2, hauteur=3):\n        self.__largeur = largeur\n        self.__hauteur = hauteur\n\n    def get_largeur(self):\n        return self.__largeur\n\n    def set_largeur(self, largeur):\n        self.__largeur = largeur\n\n    def get_hauteur(self):\n        return self.__hauteur\n\n    def set_hauteur(self, hauteur):\n        self.__hauteur = hauteur\n\n    def perimetre(self):\n        \"\"\"Retourne le périmètre\"\"\"\n        return 2 * (self.__largeur + self.__hauteur)\n\n    def aire(self):\n        \"\"\"Retourne l'aire\"\"\"\n        return self.__largeur * self.__hauteur\n````\n\nUtilisation : \n\n````python\n>>> rec = Rectangle(10, 5)\n>>> rec.__hauteur\nAttributeError: 'Rectangle' object has no attribute '__hauteur'\n>>> rec.get_hauteur()\n5\n````\n\nNous voyons que l'accès direct à l'attribut n'est plus possible.\n\nCela n'est pas très pratique et change nos habitudes : nous aimerions en effet pouvoir accéder à la valeur d'un attribut en utilisant la notation pointée. Deux remarques à ces objections. D'une part, ces règles de programmation ne sont pas là pour nous embêter ! Il s'agit de sécuriser notre code : la définition d'un `setter` par exemple, peut permettre de vérifier la validité des arguments entrés et afficher un message d'erreur si besoin (par exemple si on appelle `set_hauteur(-10`). Deuxième remarque : Python propose une fonctionnalité avancée, appelée **décorateurs** et qui permet de retrouver, en apparence, l'accès direct aux attributs. Voici une nouvelle version de la classe \"Rectangle\" avec l'utilisation du décorateur `@property` et la redéfinition des `getter` et `setter` (qui doivent maintenant porter le même nom que le pseudo argument). On a introduit dans les `setter` des tests de validité des données.\n\n````python\nclass Rectangle:\n    \"\"\"Représente un rectangle\"\"\"\n\n    def __init__(self, largeur=2, hauteur=3):\n        self.__largeur = largeur\n        self.__hauteur = hauteur\n\n    @property\n    def largeur(self):\n        return self.__largeur\n\n    @largeur.setter\n    def largeur(self, largeur):\n        if isinstance(largeur, (int, float)) and largeur >= 0:\n            self.__largeur = largeur\n        else:\n            print(\"Argument invalide, largeur inchangée !\")\n\n    @property\n    def hauteur(self):\n        return self.__hauteur\n\n    @hauteur.setter\n    def hauteur(self, hauteur):\n        if isinstance(hauteur, (int, float)) and hauteur >= 0:\n            self.__hauteur = hauteur\n        else:\n            print(\"Argument invalide, hauteur inchangée !\")\n\n    def perimetre(self):\n        \"\"\"Retourne le périmètre\"\"\"\n        return 2 * (self.__largeur + self.__hauteur)\n\n    def aire(self):\n        \"\"\"Retourne l'aire\"\"\"\n        return self.__largeur * self.__hauteur\n\n\nrec = Rectangle(10, 25)\nprint(rec.largeur)\nrec.largeur = -15\nprint(rec.largeur)\n````\n\nSortie en console : \n\n````python\n10\nArgument invalide, largeur inchangée !\n10\n````\n\n### L'héritage\n\nL'**héritage** est une relation asymétrique entre deux classes : l'une est la **classe mère** (aussi nommée classe parente, superclasse, classe de base), l'autre la **classe-fille**. L'héritage permet une économie d'écriture par la réutilisation automatique, lors de la définition de la classe-fille, de tous les membres et autres éléments définis dans la classe mère. Ainsi, les objets de la classe-fille _héritent de toutes les propriétés_ de leur classe mère.\n\nPar exemple, nous pouvons définir une classe `carre`, fille de la classe `Rectangle`. Les attributs et les méthodes définis pour la classe `Rectangle` existent alors automatiquement aussi pour la classe `carre`.\n\nVoici la syntaxe Python pour définir une classe fille :\n\n````py\nclass Carre(Rectangle):\n\n    def __init__(self, cote=2):\n        Rectangle.__init__(self, cote, cote)\n````\n\nUtilisation : \n\n````python\n>>> car = Carre(5)\n>>> car.perimetre()\n20\n````\n\nLa méthode `perimetre` est héritée de la classe mère `Rectangle`.\n\n::: {.callout-warning}\n## Héritage et initialiseur\n\nLa méthode initialiseur de la classe `Carre` fait appel à la méthode initialiseur de sa classe parente par la commande `Rectangle.__init__(self, cote, cote)`. Cet appel est nécessaire afin que les membres de la classe `Carre` soient définis de la même manière que les membres de la classe `Rectangle`. La méthode `__init__` est un initialiseur d'instance : elle n'est pas invoquée automatiquement lorsqu'on instancie des objets d'une classe fille.\n:::\n\n### Le polymorphisme et la redéfinition\n\nLa **redéfinition des méthodes** permet à un objet de raffiner une méthode définie avec la même en-tête dans la classe mère. Une même méthode pourra ainsi avoir un comportement différent selon qu'elle s'applique à la classe mère ou à la classe fille : on parle de **polymorphisme d'héritage**.\n\nPar exemple, nous pouvons redéfinir la méthode `aire` de la classe `Carre` comme ci-dessous : appliquée à un objet `Carre`, la nouvelle définition sera utilisée à la place de la méthode héritée.\n\n````python\nclass Carre(Rectangle):\n\n    def __init__(self, cote=2):\n        self.__largeur = cote\n        self.__hauteur = cote\n    \n    def aire(self):\n        \"\"\"Retourne l'aire\"\"\"\n        return self.__largeur ** 2\n````\n\n## Les méthodes spéciales\n\nUn bon exemple de polymorphisme est fourni par la redéfinition des méthodes spéciales.\n\nNous savons que la fonction `dir()` renvoie tous les membres d'un objet.\n\nAppliquons cette commande à notre objet `rec`, instance de la classe `Rectangle` : \n\n````python\n>>> dir(rec)\n['__class__',\n '__delattr__',\n '__dict__',\n '__dir__',\n '__doc__',\n '__eq__',\n '__format__',\n '__ge__',\n '__getattribute__',\n '__gt__',\n '__hash__',\n '__init__',\n '__init_subclass__',\n '__le__',\n '__lt__',\n '__module__',\n '__ne__',\n '__new__',\n '__reduce__',\n '__reduce_ex__',\n '__repr__',\n '__setattr__',\n '__sizeof__',\n '__str__',\n '__subclasshook__',\n '__weakref__',\n '_hauteur',\n '_largeur',\n 'aire',\n 'hauteur',\n 'largeur',\n 'perimetre']\n````\n\n Nous reconnaissons en fin de liste les attributs et méthodes que nous avons définis, mais nous découvrons l'existence d'un grand nombre de **méthodes spéciales** privées (puisque leur nom est entouré de `__`) qui sont en fait **héritées** d'une classe `Object` parente de toutes les classes. Parmi celles-ci, nous avons déjà rencontré `__init__`, la méthode initialiseur.\n\n Les curieux pourront rechercher le rôle de chacune de ces méthodes spéciales. Le voici pour certaines d'entre elles : \n\n| Méthode spéciale | Usage |\n| --- | --- |\n| __add__ | + |\n| __mul__ |\t* |\n| __sub__ |\t- |\n| __eq__ | == |\n| __ne__ | != |\n| __lt__ | < |\n| __ge__ | <= |\n| __gt__ | > |\n| __ge__ | >= |\n| __repr__ | affichage dans la console >>> obj |\n| __str__ |\tstr(obj), print(obj) |\n\nLa redéfinition de la méthode `__add__` permettrait par exemple de donner un sens à l'utilisation du symbole `+` entre deux objets (instruction du type `rec1 + rec 2`).\n\nDans notre exemple, nous allons redéfinir la méthode `__str__` pour spécifier ce qui doit s'afficher quand l'instruction `print(rec)` est exécutée.\n\nPour l'instant, on obtient : \n\n````python\n>>> print(rec)\n<__main__.Rectangle object at 0x000002386735C730>\n````\n\nAjoutons la méthode ci-dessous **dans la classe `Rectangle`** :\n\n````python\ndef __str__(self):\n    return f\"Rectangle de largeur {self.__largeur} et de hauteur {self.__hauteur}.\"\n````\n\nOn obtient maintenant : \n\n````python\n>>> print(rec)\nRectangle de largeur 10 et de hauteur 25.\n````","srcMarkdownNoYaml":"\n\n::: {.callout-warning}\n## Avertissement\n\nLes compléments présentés ici sont hors programme. Ils peuvent néanmoins apporter une connaissance et une compréhension plus fine de la POO et être utiles dans le cadre du travail sur les projets.\n:::\n\n## Principes et définitions\n\n**Objet**\n: Un **objet** est une donnée manipulable par un programme : il s'agit d'un conteneur pour une _valeur_ ou un _état_ auquel est associé un _ensemble d'opérations_. Cet objet est associé à un **type**, défini comme l'ensemble des valeurs possibles, cette liste d'opérations, ainsi que leur codage (binaire).\n\nUn objet est identifié dans un programme par un _nom_ ou une _notation littérale_, mais peut parfois être _anonyme_ (comme les variables temporaires ou les composantes d'un tableau).\n\nEt pour une définition d'un langage orienté objet, l'idée première que l'on retrouve dans la définition de wikipédia offre un cadre intéressant : un langage objet doit permettre l'analyse et le développement logiciel fondés sur des _relations entre objets_. \n\nConcrètement, un objet est une structure de données qui répond à un ensemble de messages. Cette structure de données définit son état tandis que l'ensemble des messages qu'il comprend décrit son comportement :\n\n- les données, ou champs, qui décrivent sa structure interne sont appelées ses **attributs** ;\n- l'ensemble des messages forme ce que l'on appelle l'interface de l'objet ; c'est seulement au travers de celle-ci que les objets interagissent entre eux. La réponse à la réception d'un message par un objet est appelée une **méthode** (méthode de mise en œuvre du message) ; elle décrit quelle réponse doit être donnée au message.\n\nLes attributs et les méthodes constituent les **membres** d'un objet. Un objet possède un **type**.\n\nEn Python, un objet la création d'un objet se fait en utilisant une **classe** : un objet est alors une instance de sa classe. La **classe** est un _type_, un ensemble d'objets partageant les mêmes propriétés concrétisées par une liste de membres.\n\n**Langage orienté objet**\n: Un **langage orienté objet** est un langage de programmation qui comporte de manière native les éléments suivants : l'_encapsulation_, l'_héritage_, le _polymorphisme_ et la _programmation générique_.\n\n## Les principes clés de la POO\n\n### L'encapsulation\n\nCertains membres (ou plus exactement leur représentation informatique) sont cachés : c'est le principe d'**[encapsulation](https://fr.wikipedia.org/wiki/Encapsulation_(programmation))**. Ainsi, le programme peut modifier la structure interne des objets ou leurs méthodes associées sans avoir d'impact sur les utilisateurs de l'objet. C'est un des principes fondamentaux notamment pour la robustesse du code.\n\nEn particulier, les bonnes pratiques de POO recommandent de na pas permettre un accès direct aux attributs d'un objet à l'extérieur de celui-ci. On appelle **interface** d'un objet l'ensemble de ses membres qui sont accessibles à l'extérieur de celui-ci. L'interface ne devrait donc contenir que des méthodes. Pas forcément toutes, certaines méthodes (comme `__init__`) restent privées.\n\nContrairement à d'autres langages, Python offre une totale liberté de modification sur les membres d'un objet. C'est au programmeur de rester vigilant. Il existe néanmoins des conventions permettant d'identifier les membres de l'interface des autres membres d'un objet.\n\n::: {.callout-important}\n## Conventions de nommage en Python\n\n* un nom d'attribut commençant par un double underscore `__` désigne un attribut privé.\n* une méthode dont le nom est de la forme ``__nom__`` désigne une méthode privée.\n:::\n\nMais alors si les attributs doivent rester privés, comment y accéder, et comment les modifier ?\n\nIl convient pour cela, en toute rigueur, de définir des méthodes ad-hoc : une méthode qui permet d'accéder à un attribut est un `getter`, une période qui permet de changer la valeur d'un attribut est un `setter`.\n\nVoici par exemple une nouvelle définition de la classe \"Rectangle\" tenant compte des remarques précédentes.\n\n````python\nclass Rectangle:\n    \"\"\"Représente un rectangle\"\"\"\n\n    def __init__(self, largeur=2, hauteur=3):\n        self.__largeur = largeur\n        self.__hauteur = hauteur\n\n    def get_largeur(self):\n        return self.__largeur\n\n    def set_largeur(self, largeur):\n        self.__largeur = largeur\n\n    def get_hauteur(self):\n        return self.__hauteur\n\n    def set_hauteur(self, hauteur):\n        self.__hauteur = hauteur\n\n    def perimetre(self):\n        \"\"\"Retourne le périmètre\"\"\"\n        return 2 * (self.__largeur + self.__hauteur)\n\n    def aire(self):\n        \"\"\"Retourne l'aire\"\"\"\n        return self.__largeur * self.__hauteur\n````\n\nUtilisation : \n\n````python\n>>> rec = Rectangle(10, 5)\n>>> rec.__hauteur\nAttributeError: 'Rectangle' object has no attribute '__hauteur'\n>>> rec.get_hauteur()\n5\n````\n\nNous voyons que l'accès direct à l'attribut n'est plus possible.\n\nCela n'est pas très pratique et change nos habitudes : nous aimerions en effet pouvoir accéder à la valeur d'un attribut en utilisant la notation pointée. Deux remarques à ces objections. D'une part, ces règles de programmation ne sont pas là pour nous embêter ! Il s'agit de sécuriser notre code : la définition d'un `setter` par exemple, peut permettre de vérifier la validité des arguments entrés et afficher un message d'erreur si besoin (par exemple si on appelle `set_hauteur(-10`). Deuxième remarque : Python propose une fonctionnalité avancée, appelée **décorateurs** et qui permet de retrouver, en apparence, l'accès direct aux attributs. Voici une nouvelle version de la classe \"Rectangle\" avec l'utilisation du décorateur `@property` et la redéfinition des `getter` et `setter` (qui doivent maintenant porter le même nom que le pseudo argument). On a introduit dans les `setter` des tests de validité des données.\n\n````python\nclass Rectangle:\n    \"\"\"Représente un rectangle\"\"\"\n\n    def __init__(self, largeur=2, hauteur=3):\n        self.__largeur = largeur\n        self.__hauteur = hauteur\n\n    @property\n    def largeur(self):\n        return self.__largeur\n\n    @largeur.setter\n    def largeur(self, largeur):\n        if isinstance(largeur, (int, float)) and largeur >= 0:\n            self.__largeur = largeur\n        else:\n            print(\"Argument invalide, largeur inchangée !\")\n\n    @property\n    def hauteur(self):\n        return self.__hauteur\n\n    @hauteur.setter\n    def hauteur(self, hauteur):\n        if isinstance(hauteur, (int, float)) and hauteur >= 0:\n            self.__hauteur = hauteur\n        else:\n            print(\"Argument invalide, hauteur inchangée !\")\n\n    def perimetre(self):\n        \"\"\"Retourne le périmètre\"\"\"\n        return 2 * (self.__largeur + self.__hauteur)\n\n    def aire(self):\n        \"\"\"Retourne l'aire\"\"\"\n        return self.__largeur * self.__hauteur\n\n\nrec = Rectangle(10, 25)\nprint(rec.largeur)\nrec.largeur = -15\nprint(rec.largeur)\n````\n\nSortie en console : \n\n````python\n10\nArgument invalide, largeur inchangée !\n10\n````\n\n### L'héritage\n\nL'**héritage** est une relation asymétrique entre deux classes : l'une est la **classe mère** (aussi nommée classe parente, superclasse, classe de base), l'autre la **classe-fille**. L'héritage permet une économie d'écriture par la réutilisation automatique, lors de la définition de la classe-fille, de tous les membres et autres éléments définis dans la classe mère. Ainsi, les objets de la classe-fille _héritent de toutes les propriétés_ de leur classe mère.\n\nPar exemple, nous pouvons définir une classe `carre`, fille de la classe `Rectangle`. Les attributs et les méthodes définis pour la classe `Rectangle` existent alors automatiquement aussi pour la classe `carre`.\n\nVoici la syntaxe Python pour définir une classe fille :\n\n````py\nclass Carre(Rectangle):\n\n    def __init__(self, cote=2):\n        Rectangle.__init__(self, cote, cote)\n````\n\nUtilisation : \n\n````python\n>>> car = Carre(5)\n>>> car.perimetre()\n20\n````\n\nLa méthode `perimetre` est héritée de la classe mère `Rectangle`.\n\n::: {.callout-warning}\n## Héritage et initialiseur\n\nLa méthode initialiseur de la classe `Carre` fait appel à la méthode initialiseur de sa classe parente par la commande `Rectangle.__init__(self, cote, cote)`. Cet appel est nécessaire afin que les membres de la classe `Carre` soient définis de la même manière que les membres de la classe `Rectangle`. La méthode `__init__` est un initialiseur d'instance : elle n'est pas invoquée automatiquement lorsqu'on instancie des objets d'une classe fille.\n:::\n\n### Le polymorphisme et la redéfinition\n\nLa **redéfinition des méthodes** permet à un objet de raffiner une méthode définie avec la même en-tête dans la classe mère. Une même méthode pourra ainsi avoir un comportement différent selon qu'elle s'applique à la classe mère ou à la classe fille : on parle de **polymorphisme d'héritage**.\n\nPar exemple, nous pouvons redéfinir la méthode `aire` de la classe `Carre` comme ci-dessous : appliquée à un objet `Carre`, la nouvelle définition sera utilisée à la place de la méthode héritée.\n\n````python\nclass Carre(Rectangle):\n\n    def __init__(self, cote=2):\n        self.__largeur = cote\n        self.__hauteur = cote\n    \n    def aire(self):\n        \"\"\"Retourne l'aire\"\"\"\n        return self.__largeur ** 2\n````\n\n## Les méthodes spéciales\n\nUn bon exemple de polymorphisme est fourni par la redéfinition des méthodes spéciales.\n\nNous savons que la fonction `dir()` renvoie tous les membres d'un objet.\n\nAppliquons cette commande à notre objet `rec`, instance de la classe `Rectangle` : \n\n````python\n>>> dir(rec)\n['__class__',\n '__delattr__',\n '__dict__',\n '__dir__',\n '__doc__',\n '__eq__',\n '__format__',\n '__ge__',\n '__getattribute__',\n '__gt__',\n '__hash__',\n '__init__',\n '__init_subclass__',\n '__le__',\n '__lt__',\n '__module__',\n '__ne__',\n '__new__',\n '__reduce__',\n '__reduce_ex__',\n '__repr__',\n '__setattr__',\n '__sizeof__',\n '__str__',\n '__subclasshook__',\n '__weakref__',\n '_hauteur',\n '_largeur',\n 'aire',\n 'hauteur',\n 'largeur',\n 'perimetre']\n````\n\n Nous reconnaissons en fin de liste les attributs et méthodes que nous avons définis, mais nous découvrons l'existence d'un grand nombre de **méthodes spéciales** privées (puisque leur nom est entouré de `__`) qui sont en fait **héritées** d'une classe `Object` parente de toutes les classes. Parmi celles-ci, nous avons déjà rencontré `__init__`, la méthode initialiseur.\n\n Les curieux pourront rechercher le rôle de chacune de ces méthodes spéciales. Le voici pour certaines d'entre elles : \n\n| Méthode spéciale | Usage |\n| --- | --- |\n| __add__ | + |\n| __mul__ |\t* |\n| __sub__ |\t- |\n| __eq__ | == |\n| __ne__ | != |\n| __lt__ | < |\n| __ge__ | <= |\n| __gt__ | > |\n| __ge__ | >= |\n| __repr__ | affichage dans la console >>> obj |\n| __str__ |\tstr(obj), print(obj) |\n\nLa redéfinition de la méthode `__add__` permettrait par exemple de donner un sens à l'utilisation du symbole `+` entre deux objets (instruction du type `rec1 + rec 2`).\n\nDans notre exemple, nous allons redéfinir la méthode `__str__` pour spécifier ce qui doit s'afficher quand l'instruction `print(rec)` est exécutée.\n\nPour l'instant, on obtient : \n\n````python\n>>> print(rec)\n<__main__.Rectangle object at 0x000002386735C730>\n````\n\nAjoutons la méthode ci-dessous **dans la classe `Rectangle`** :\n\n````python\ndef __str__(self):\n    return f\"Rectangle de largeur {self.__largeur} et de hauteur {self.__hauteur}.\"\n````\n\nOn obtient maintenant : \n\n````python\n>>> print(rec)\nRectangle de largeur 10 et de hauteur 25.\n````"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"markdown"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":true,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":[true,"pdf","tex"]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../styles.css"],"toc":true,"filters":["lightbox"],"output-file":"POO_complements.html"},"language":{"toc-title-document":"Table des matières","toc-title-website":"Sur cette page","related-formats-title":"Autres formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"La source","section-title-abstract":"Résumé","section-title-appendices":"Annexes","section-title-footnotes":"Notes de bas de page","section-title-references":"Les références","section-title-reuse":"Réutilisation","section-title-copyright":"Droits d'auteur","section-title-citation":"Citation","appendix-attribution-cite-as":"Veuillez citer ce travail comme suit :","appendix-attribution-bibtex":"BibTeX","title-block-author-single":"Auteur·rice","title-block-author-plural":"Auteur·rice·s","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Date de publication","title-block-modified":"Modifié","callout-tip-title":"Astuce","callout-note-title":"Note","callout-warning-title":"Avertissement","callout-important-title":"Important","callout-caution-title":"Mise en garde","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Montrer tout le code","code-tools-hide-all-code":"Cacher tout le code","code-tools-view-source":"Voir les sources","code-tools-source-code":"Code source","code-line":"Ligne","code-lines":"Lignes","copy-button-tooltip":"Copier vers le presse-papier","copy-button-tooltip-success":"Copié","repo-action-links-edit":"Modifier cette page","repo-action-links-source":"Voir la source","repo-action-links-issue":"Faire part d'un problème","back-to-top":"Retour au sommet","search-no-results-text":"Pas de résultats","search-matching-documents-text":"documents trouvés","search-copy-link-title":"Copier le lien vers la recherche","search-hide-matches-text":"Cacher les correspondances additionnelles","search-more-match-text":"correspondance de plus dans ce document","search-more-matches-text":"correspondances de plus dans ce document","search-clear-button-title":"Effacer","search-detached-cancel-button-title":"Annuler","search-submit-button-title":"Envoyer","search":"Recherche","toggle-section":"Basculer la section","toggle-sidebar":"Basculer la barre latérale","toggle-dark-mode":"Basculer le mode sombre","toggle-reader-mode":"Basculer en mode lecteur","toggle-navigation":"Basculer la navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Théorème","crossref-lem-title":"Lemme","crossref-cor-title":"Corollaire","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Définition","crossref-exm-title":"Exemple","crossref-exr-title":"Exercice","crossref-ch-prefix":"Chapitre","crossref-apx-prefix":"Annexe","crossref-sec-prefix":"Section","crossref-eq-prefix":"Équation","crossref-lof-title":"Liste des Figures","crossref-lot-title":"Liste des Tables","crossref-lol-title":"Liste des Listings","environment-proof-title":"Preuve","environment-remark-title":"Remarque","environment-solution-title":"Solution","listing-page-order-by":"Trier par","listing-page-order-by-default":"Ordre par défaut","listing-page-order-by-date-asc":"Le plus ancien","listing-page-order-by-date-desc":"Le plus récent","listing-page-order-by-number-desc":"Descendant","listing-page-order-by-number-asc":"Ascendant","listing-page-field-date":"Date","listing-page-field-title":"Titre","listing-page-field-description":"Description","listing-page-field-author":"Auteur·rice","listing-page-field-filename":"Nom de fichier","listing-page-field-filemodified":"Modifié","listing-page-field-subtitle":"Sous-titre","listing-page-field-readingtime":"Temps de lecture","listing-page-field-categories":"Catégories","listing-page-minutes-compact":"{0} min.","listing-page-category-all":"Tous","listing-page-no-matches":"Aucun article correspondant"},"metadata":{"lang":"fr","fig-responsive":true,"quarto-version":"1.3.296","bibliography":["../references.bib"],"theme":{"light":["flatly","../theme_light.scss"],"dark":["darkly","../theme_dark.scss"]},"grid":{"sidebar-width":"250px","body-width":"1000px","margin-width":"300px"},"lightbox":"auto","code-block-border-left":"#31BAE9","code-block-bg":true,"title":"Programmation orientée objets (Compléments)","subtitle":"S1 - Langages et programmation","tbl-cap-location":"bottom","crossref":{"eq-prefix":"Éq.","tbl-prefix":"Tableau","tbl-title":"Tableau"}},"extensions":{"book":{"multiFile":true}}},"pdf":{"identifier":{"display-name":"PDF","target-format":"pdf","base-format":"pdf"},"execute":{"fig-width":5.5,"fig-height":3.5,"fig-format":"pdf","fig-dpi":300,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"markdown"},"render":{"keep-tex":true,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"pdf","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"format-links":["pdf","tex"]},"pandoc":{"pdf-engine":"xelatex","standalone":true,"variables":{"graphics":true,"tables":true},"default-image-extension":"pdf","to":"pdf","include-in-header":[{"text":"\\usepackage{fancyhdr} \\pagestyle{fancy} \\usepackage{lastpage}"}],"include-before-body":[{"text":"\\lhead{Spécialité NSI} \\rhead{Terminale} \\chead{} \\cfoot{} \\lfoot{Lycée \\'Emile Duclaux} \\rfoot{Page \\thepage/\\pageref{LastPage}} \\renewcommand{\\headrulewidth}{0pt} \\renewcommand{\\footrulewidth}{0pt} \\thispagestyle{fancy} \\vspace{-2cm}"}],"reference-location":"document","output-file":"POO_complements.pdf"},"language":{"toc-title-document":"Table des matières","toc-title-website":"Sur cette page","related-formats-title":"Autres formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"La source","section-title-abstract":"Résumé","section-title-appendices":"Annexes","section-title-footnotes":"Notes de bas de page","section-title-references":"Les références","section-title-reuse":"Réutilisation","section-title-copyright":"Droits d'auteur","section-title-citation":"Citation","appendix-attribution-cite-as":"Veuillez citer ce travail comme suit :","appendix-attribution-bibtex":"BibTeX","title-block-author-single":"Auteur·rice","title-block-author-plural":"Auteur·rice·s","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Date de publication","title-block-modified":"Modifié","callout-tip-title":"Astuce","callout-note-title":"Note","callout-warning-title":"Avertissement","callout-important-title":"Important","callout-caution-title":"Mise en garde","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Montrer tout le code","code-tools-hide-all-code":"Cacher tout le code","code-tools-view-source":"Voir les sources","code-tools-source-code":"Code source","code-line":"Ligne","code-lines":"Lignes","copy-button-tooltip":"Copier vers le presse-papier","copy-button-tooltip-success":"Copié","repo-action-links-edit":"Modifier cette page","repo-action-links-source":"Voir la source","repo-action-links-issue":"Faire part d'un problème","back-to-top":"Retour au sommet","search-no-results-text":"Pas de résultats","search-matching-documents-text":"documents trouvés","search-copy-link-title":"Copier le lien vers la recherche","search-hide-matches-text":"Cacher les correspondances additionnelles","search-more-match-text":"correspondance de plus dans ce document","search-more-matches-text":"correspondances de plus dans ce document","search-clear-button-title":"Effacer","search-detached-cancel-button-title":"Annuler","search-submit-button-title":"Envoyer","search":"Recherche","toggle-section":"Basculer la section","toggle-sidebar":"Basculer la barre latérale","toggle-dark-mode":"Basculer le mode sombre","toggle-reader-mode":"Basculer en mode lecteur","toggle-navigation":"Basculer la navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Théorème","crossref-lem-title":"Lemme","crossref-cor-title":"Corollaire","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Définition","crossref-exm-title":"Exemple","crossref-exr-title":"Exercice","crossref-ch-prefix":"Chapitre","crossref-apx-prefix":"Annexe","crossref-sec-prefix":"Section","crossref-eq-prefix":"Équation","crossref-lof-title":"Liste des Figures","crossref-lot-title":"Liste des Tables","crossref-lol-title":"Liste des Listings","environment-proof-title":"Preuve","environment-remark-title":"Remarque","environment-solution-title":"Solution","listing-page-order-by":"Trier par","listing-page-order-by-default":"Ordre par défaut","listing-page-order-by-date-asc":"Le plus ancien","listing-page-order-by-date-desc":"Le plus récent","listing-page-order-by-number-desc":"Descendant","listing-page-order-by-number-asc":"Ascendant","listing-page-field-date":"Date","listing-page-field-title":"Titre","listing-page-field-description":"Description","listing-page-field-author":"Auteur·rice","listing-page-field-filename":"Nom de fichier","listing-page-field-filemodified":"Modifié","listing-page-field-subtitle":"Sous-titre","listing-page-field-readingtime":"Temps de lecture","listing-page-field-categories":"Catégories","listing-page-minutes-compact":"{0} min.","listing-page-category-all":"Tous","listing-page-no-matches":"Aucun article correspondant"},"metadata":{"block-headings":true,"bibliography":["../references.bib"],"title":"Programmation orientée objets (Compléments)","subtitle":"S1 - Langages et programmation","lang":"fr","tbl-cap-location":"bottom","crossref":{"eq-prefix":"Éq.","tbl-prefix":"Tableau","tbl-title":"Tableau"},"geometry":["top=20mm","bottom=20mm","left=20mm","right=20mm","heightrounded"],"biblio-title":"Sources utilisées"},"extensions":{"book":{"selfContainedOutput":true}}}},"projectFormats":["html"]}