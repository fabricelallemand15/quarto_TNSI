{"title":"Programmation orientée objets (Cours)","markdown":{"yaml":{"title":"Programmation orientée objets (Cours)","subtitle":"S1 - Langages et programmation","lang":"fr","tbl-cap-location":"bottom","crossref":{"eq-prefix":"Éq.","tbl-prefix":"Tableau","tbl-title":"Tableau"},"format":{"html":"default","pdf":{"geometry":["top=20mm","bottom=20mm","left=20mm","right=20mm","heightrounded"],"include-in-header":[{"text":"\\usepackage{fancyhdr} \\pagestyle{fancy} \\usepackage{lastpage}"}],"include-before-body":[{"text":"\\lhead{Spécialité NSI} \\rhead{Terminale} \\chead{} \\cfoot{} \\lfoot{Lycée \\'Emile Duclaux} \\rfoot{Page \\thepage/\\pageref{LastPage}} \\renewcommand{\\headrulewidth}{0pt} \\renewcommand{\\footrulewidth}{0pt} \\thispagestyle{fancy} \\vspace{-2cm}"}],"biblio-title":"Sources utilisées","reference-location":"document","keep-tex":true}},"format-links":["pdf","tex"]},"headingText":"Objectifs","containsRefs":false,"markdown":"\n\n::: {.callout-tip}\n\n* Connaître le vocabulaire de la POO : classes, attributs, méthodes objets.\n* Écrire la définition d'une classe.\n* Accéder aux méthodes et attributs d'une classe.\n:::\n\nDes [compléments sur la POO](POO_complements.md) sont proposés à la suite de ce cours.\n\n## Introduction\n\nLa Programmation Orientée Objets (**POO**) pour les intimes (que vous allez devenir !) est un **paradigme** (c'est-à-dire une manière de faire) de programmation \n\nPour un bref aperçu historique de l'idée d'objet en programmation, lire l'encadré ci-dessous, en grande partie tiré de l'article [Object-oriented programming](https://en.wikipedia.org/wiki/Object-oriented_programming) de Wikipedia en anglais.\n\n:::{.callout-note}\n## Un peu d'histoire\n\nLes termes **objets** **orienté** au sens moderne de la programmation orientée objet ont fait leur première apparition au MIT à la fin des années 1950 et au début des années 1960. Dans l'environnement du groupe d'intelligence artificielle, dès 1960, \"objet\" pouvait désigner des éléments identifiés avec des propriétés (attributs).\n\nC'est l'informaticien Alan Kay (1940-) qui est considéré comme l'un de pères de la programmation orientée objets.\n\n> Je pensais que les objets étaient comme des cellules biologiques et / ou des ordinateurs individuels sur un réseau, uniquement capables de communiquer avec des messages.\n> \n> Alan Kay\n\nLe langage Simula dans les années 1960, puis Smalltalk dans les années 1970 posent les bases toujours actuelles de ce paradigme.\n\nAu début et au milieu des années 1990, la programmation orientée objet s'est développée comme le paradigme de programmation dominant lorsque les langages de programmation prenant en charge ces techniques sont devenus largement disponibles. Ceux-ci incluent par exemple C++ ou Delphi. Sa domination a été renforcée par la popularité croissante des interfaces utilisateur graphiques, qui reposent fortement sur des techniques de programmation orientées objet.\n\nDes fonctionnalités orientées objet ont été ajoutées à de nombreux langages existants, notamment Ada, BASIC, Fortran, Pascal et COBOL.\n\nPlus récemment, un certain nombre de langages ont émergé qui sont principalement orientés objet, mais qui sont également compatibles avec la méthodologie procédurale. Deux de ces langages sont Python et Ruby. Les langages orientés objet récents les plus importants sur le plan commercial sont probablement Java, développé par Sun Microsystems, ainsi que C# et Visual Basic.NET (VB.NET), tous deux conçus pour la plate-forme.NET de Microsoft. \n\n*[MIT] : Massachusetts Institute of Technology\n:::\n\nAlors de quoi s'agit-il ? Une approche intuitive consiste à dire que cette méthode de programmation nous permet de définir des nouveaux types de données, de nouveaux objets, correspondant à un objectif précis. Ces nouveaux types sont appelés **classes**. En définissant une classe, nous pouvons également définir ses **attributs**, c'est-à-dire les variables qui lui sont associées et ses **méthodes**, c'est-à-dire les fonctions sui lui sont propres.\n\nVoici ce que Gérard SWINNEN écrit dans son livre _Apprendre à programmer avec Python 3_ : \n\n> Les classes sont les principaux outils de la programmation orientée objet (Object Oriented Programming ou OOP). Ce type de programmation permet de structurer les logiciels complexes en les organisant comme des ensembles d’objets qui interagissent, entre eux et avec le monde extérieur.\n> \n> Le premier bénéfice de cette approche de la programmation réside dans le fait que les différents objets utilisés peuvent être construits indépendamment les uns des autres (par exemple par des programmeurs différents) sans qu’il n’y ait de risque d’interférence. Ce résultat est obtenu grâce au concept d’encapsulation : la fonctionnalité interne de l’objet et les variables qu’il utilise pour effectuer son travail, sont en quelque sorte « enfermées » dans l’objet. Les autres objets et le monde extérieur ne peuvent y avoir accès qu’à travers des procédures bien définies : l’interface de l’objet.\n> \n> En particulier, l’utilisation de classes dans vos programmes va vous permettre – entre autres avantages – d’éviter au maximum l’emploi de variables globales. Vous devez savoir en effet que l’utilisation de variables globales comporte des risques, d’autant plus importants que les programmes sont volumineux, parce qu’il est toujours possible que de telles variables soient modifiées, ou même redéfinies, n’importe où dans le corps du programme (ce risque s’aggrave particulièrement si plusieurs programmeurs différents travaillent sur un même logiciel).\n\nEn utilisant Python, nous avons déjà fréquenté des classes d'objets : il est usuel de lire qu'en Python \"tout est objet\", même si Python ne permet pas vraiment de faire de la POO dans toute sa rigueur.\n\nPar exemple, définissons une chaîne de caractères et demandons à Python quel est son type :\n\n````python\n>>> a = \"Coucou !\"\n>>> type(a)\n<class 'str'>\n````\n\nLe type 'str' bien connu est en fait une classe d'objet prédéfinie. On dit que `a` est une **instance** de l'objet `str`.\n\nUn exemple de **méthode** rattachée à la classe str est la fonction `capitalize` qui met le premier caractère en majuscule. Cette méthode est appelée par la notation pointée déjà rencontrée.\n\n````python\n>>> a.capitalize()\n'Coucou !'\n````\n\nLa commande `help(str)` affiche toutes les méthodes prédéfinies pour les objets de la classe `str`.\n\n## Classe, initialiseur, attributs\n\nEn Python, la définition d'une classe se fait avec le mot-clef `class` suivi du nom de la classe.\n\nSupposons par exemple que nous voulons définir une classe pour représenter des rectangles. Nous avons besoin, pour chaque rectangle, de connaître sa largeur et se hauteur, ce qui nous permettra de faire quelques calculs.\n\nObservons le code suivant : \n\n````py\nclass Rectangle:\n    \"\"\"Représente un rectangle\"\"\"\n    \n    def __init__(self, largeur = 2, hauteur = 3):\n        self.largeur = largeur\n        self.hauteur = hauteur\n````\n\nÀ l'intérieur de la classe `Rectangle`, la **méthode** `__init__` est l'**initialiseur** : elle est toujours exécutée lorsqu'une **instance** de l'objet `Rectangle` est créée (on parle aussi de **constructeur**). Cette _fonction_ accepte des paramètres qui seront les valeurs à donner aux attributs à la création de l'objet (ici on a aussi donné des valeurs par défaut à ces paramètres) ; le premier paramètre est particulier : ce sera **toujours** le mot-clé `self` : ce mot-clef désigne l'instance qui est en train d'être définie au moment où cette fonction s'exécute.\n\n::: {.callout-tip}\n## Remarque\n\nIl est d'usage, et recommandé, de nommer une classe par un nom commençant par une majuscule.\n:::\n\nObservons les lignes suivantes dans la console Python :\n\n````python\n>>> rec1 = Rectangle()\n>>> rec2=Rectangle(15, 25)\n>>> rec1.largeur\n2\n>>> rec2.largeur\n15\n````\n\n`rec1` est une instance de l'objet `Rectangle`. Aucun paramètre n'étant donné lors de sa création, les valeurs par défaut ont été appliquées. `rec2` est une autre instance de l'objet `Rectangle` pour laquelle on a défini les **attributs d'instance** `largeur` et `hauteur`. On accède à ces attributs par la notation pointée.\n\n\n## Méthodes\n\nUne **méthode**, c'est ce qui permet à une instance de réaliser des actions. Techniquement se sont des fonctions définies **dans le corps de la classe**, et qui prennent toujours au moins un premier paramètre qui est `self`.\n\nCertaines méthodes sont particulières, leurs noms commencent par un double _undescore_ (le caractère `_`). On a vu une première de ces méthodes : l'initialiseur `__init__`.\n\nDéfinissons ici une méthode permettant de calculer le périmètre d'un rectangle et une autre pour l'aire :\n\n````py\nclass Rectangle:\n    \"\"\"Représente un rectangle\"\"\"\n\n    def __init__(self, largeur=2, hauteur=3):\n        self.largeur = largeur\n        self.hauteur = hauteur\n\n    def perimetre(self):\n        \"\"\"Retourne le périmètre\"\"\"\n        return 2 * (self.largeur + self.hauteur)\n\n    def aire(self):\n        \"\"\"Retourne l'aire\"\"\"\n        return self.largeur * self.hauteur\n````\n\nUtilisation : \n\n````python\n>>> rec = Rectangle(10, 5)\n>>> rec.perimetre()\n30\n>>> rec.aire()\n50\n````\n\nUne méthode peut modifier la valeur d'un attribut. Définissons par exemple une méthode permettant de doubler la largeur d'un rectangle.\n\n````python\ndef double_largeur(self):\n    \"\"\"Double la largeur du rectangle)\"\"\"\n    self.largeur *= 2\n````\n\n````python\n>>> rec = Rectangle(10, 5)\n>>> rec.double_largeur()\n>>> rec.largeur\n20\n````\n\nLa POO encourage à n'exposer que des méthodes vers l'extérieur (on parle d'**interface**) en masquant les attributs. Il s'agit d'un des quatre éléments constitutifs de l'orienté objet : l'**encapsulation**.\n\n::: {.callout-note}\n## Remarque\n\nNous avons présenté ci-dessus les **attributs d'instance**, mais il est aussi possible de définir des **attributs de classe** qui seront donc les mêmes pour toutes les instances d'une même classe créées dans un programme. Ces attributs sont définis à l'intérieur de la classe, sans le préfixe `self` (puisque celui-ci fait référence à l'instance en train d'être créée).\n\nPar exemple, dans la définition de la classe `Atome` ci-dessous, la liste `table` est un attribut de classe, alors que l'entier `np` est un attribut d'instance. Dans la méthode `__init__`, on accède à l'attribut de classe en le préfixant par le nom de la classe `Atome.table` et on accède à l'attribut d'instance en le préfixant par le nom de l'instance `self.np`.\n\n````python\nclass Atome:\n\"\"\"atomes simplifiés, choisis parmi les 10 premiers éléments du TP\"\"\"\ntable = [None, ('hydrogène', 0), ('hélium', 2), ('lithium', 4), ('béryllium', 5),\n            ('bore', 6), ('carbone', 6), ('azote', 7), ('oxygène', 8), ('fluor', 10), ('néon', 10)]\n\ndef __init__(self, nat):\n    \"le n° atomique détermine le n. de protons, d'électrons et de neutrons\"\n    self.np, self.ne = nat, nat  # nat = numéro atomique\n    self.nn = Atome.table[nat][1]\n\ndef affiche(self):\n    print()\n    print(\"Nom de l'élément :\", Atome.table[self.np][0])\n    print(f\"{self.np} protons, {self.ne} électrons, {self.nn} neutrons\")\n````\n\nDe la même façon, il est possible de définir des **méthodes de classe**.\n:::\n\n## Représentation simplifiée d'une classe\n\nLorsqu'un module comportant plusieurs définitions de classe est développé, on peut réaliser une représentation graphique, appelée **diagramme de classes** qui permet de visualiser le nom de chaque classe, son interface (c'est-à-dire l'ensemble de ses attributs et méthodes publiques) et les relations éventuelles entre les différentes classes.\n\nUne présentation détaillée de ce type de diagramme n'est pas au programme, mais de manière simplifiée, le diagramme correspondant à la classe `Rectangle` pourrait ressembler à ce qui suit :\n\n![Diagramme de classe](classe_mermaid.png)\n\nDans des cases séparées, on place d'abord le nom de la classe, puis ses attributs et enfin ses méthodes. Un codage spécifique permet de préciser le type des différents membres, leur caractère public ou privé (voir les compléments à ce sujet) ou même leur état.\n\nUn attribut de classe ou une méthode de classe seront soulignés dans un tel diagramme.\n\nPour en savoir un peu plus sur les diagrammes de classes, je vous conseille [ce document](https://inf1410.teluq.ca/teluqDownload.php?file=2014/01/INF1410_Guide_UML_DCC.pdf){ target=_blank } ou encore [ce cours](https://laurent-audibert.developpez.com/Cours-UML/?page=diagramme-classes){ target=_blank } plus difficile.\n\n--------------------------------\n\nDes [compléments sur la POO](POO_complements.md) sont proposés à la suite de ce cours."},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"markdown"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":true,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":[true,"pdf","tex"]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../styles.css"],"toc":true,"filters":["lightbox"],"output-file":"POO_cours.html"},"language":{},"metadata":{"lang":"fr","fig-responsive":true,"quarto-version":"1.3.208","bibliography":["../references.bib"],"theme":{"light":["flatly","../theme_light.scss"],"dark":["darkly","../theme_dark.scss"]},"grid":{"sidebar-width":"250px","body-width":"1000px","margin-width":"300px"},"lightbox":"auto","code-block-border-left":"#31BAE9","code-block-bg":true,"title":"Programmation orientée objets (Cours)","subtitle":"S1 - Langages et programmation","tbl-cap-location":"bottom","crossref":{"eq-prefix":"Éq.","tbl-prefix":"Tableau","tbl-title":"Tableau"}},"extensions":{"book":{"multiFile":true}}},"pdf":{"identifier":{"display-name":"PDF","target-format":"pdf","base-format":"pdf"},"execute":{"fig-width":5.5,"fig-height":3.5,"fig-format":"pdf","fig-dpi":300,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"markdown"},"render":{"keep-tex":true,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"pdf","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"format-links":["pdf","tex"]},"pandoc":{"pdf-engine":"xelatex","standalone":true,"variables":{"graphics":true,"tables":true},"default-image-extension":"pdf","to":"pdf","include-in-header":[{"text":"\\usepackage{fancyhdr} \\pagestyle{fancy} \\usepackage{lastpage}"}],"include-before-body":[{"text":"\\lhead{Spécialité NSI} \\rhead{Terminale} \\chead{} \\cfoot{} \\lfoot{Lycée \\'Emile Duclaux} \\rfoot{Page \\thepage/\\pageref{LastPage}} \\renewcommand{\\headrulewidth}{0pt} \\renewcommand{\\footrulewidth}{0pt} \\thispagestyle{fancy} \\vspace{-2cm}"}],"reference-location":"document","output-file":"POO_cours.pdf"},"language":{},"metadata":{"block-headings":true,"bibliography":["../references.bib"],"papersize":"a4","title":"Programmation orientée objets (Cours)","subtitle":"S1 - Langages et programmation","lang":"fr","tbl-cap-location":"bottom","crossref":{"eq-prefix":"Éq.","tbl-prefix":"Tableau","tbl-title":"Tableau"},"geometry":["top=20mm","bottom=20mm","left=20mm","right=20mm","heightrounded"],"biblio-title":"Sources utilisées"},"extensions":{"book":{"selfContainedOutput":true}}}}}