{"title":"Récursivité (Exercices)","markdown":{"yaml":{"title":"Récursivité (Exercices)","subtitle":"S1 - Langages et programmation","lang":"fr","tbl-cap-location":"bottom","crossref":{"eq-prefix":"Éq.","tbl-prefix":"Tableau","tbl-title":"Tableau"},"format":{"html":"default","pdf":{"geometry":["top=20mm","bottom=20mm","left=20mm","right=20mm","heightrounded"],"include-in-header":[{"text":"\\usepackage{fancyhdr} \\pagestyle{fancy} \\usepackage{lastpage}"}],"include-before-body":[{"text":"\\lhead{Spécialité NSI} \\rhead{Terminale} \\chead{} \\cfoot{} \\lfoot{Lycée \\'Emile Duclaux} \\rfoot{Page \\thepage/\\pageref{LastPage}} \\renewcommand{\\headrulewidth}{0pt} \\renewcommand{\\footrulewidth}{0pt} \\thispagestyle{fancy} \\vspace{-2cm}"}],"biblio-title":"Sources utilisées","reference-location":"document","keep-tex":true}},"format-links":["pdf","tex"]},"headingText":"Attention !","containsRefs":false,"markdown":"\n\n_Les exercices précédés du symbole {{< fa desktop >}} sont à faire sur machine, en sauvegardant le fichier si nécessaire._\n\n_Les exercices précédés du symbole {{< fa solid pencil-alt >}} doivent être résolus par écrit._\n\n::: {.callout-warning}\nLes exercices suivants comportent également quelques compléments de cours.\n\nLes exemples présentés dans ces exercices sont  des exemples très classiques qu'il faut connaître.\n:::\n\n## {{< fa solid pencil-alt >}} Exercice 1 : factorielle\n\nOn rappelle l'exemple du premier paragraphe du cours concernant le calcul de la factorielle $n!=1\\times 2\\times 3\\times\\ldots\\times n$ d'un entier naturel $n$, dans sa version récursive.\n\n```python\n  def fact(n):\n    \"\"\"Renvoie la factorielle de n (méthode récursive).\"\"\"\n    if n == 0:\n      res = 1\n    else:\n      res = n*fact(n-1)\n    return res\n```\n\n1. Dans cette fonction, quel est le cas de base ?\n2. Démontrer que l'algorithme se termine (**preuve de terminaison**) dès lors que l'argument $n$ donné initialement est un entier naturel.\n3. Que se passe-t-il si on appelle la fonction `fact` avec $n=-2$ ? Proposer une modification de la fonction pour traiter ce type de cas.\n3. Pour démontrer que cet algorithme renvoie bien $n!$ lorsque $n$ est un entier naturel, on peut procéder par un **raisonnement par récurrence**.\n    \n    * *Cas de base* : pour $n=0$, la fonction renvoie-t-elle $0!$ ?\n    * *Hypothèse* : on suppose que, pour une certaine valeur de l'entier naturel non nul $n$, `fact(n-1)` renvoie $(n-1)!$. Montrer que, sous cette hypothèse, `fac(n)` renvoie bien $n!$.\n    * *Conclusion* : en déduire que `fac(n)` renvoie $n!$ pour tout entier naturel $n$.\n\n4. Pour évaluer la **complexité** de cet algorithme, nous allons compter le nombre de multiplications et de comparaisons effectuées. Démontrer, à l'aide d'un raisonnement pas récurrence, que la complexité de cet algorithme est en $\\mathcal{O}(n)$.\n\n::: {.callout-note}\n## À retenir ...\n* Le principe de la preuve de terminaison.\n* Le principe du raisonnement pas récurrence\n:::\n\n\n## {{< fa solid pencil-alt >}} {{< fa desktop >}} Exercice 2 : suite de Fibonacci\n\nLa suite de Fibonacci est une suite de nombres entiers notés $F_n$, définie par $F_0=0$, $F_1=1$ et dans laquelle chaque terme est égal à la somme des deux termes qui le précèdent.\n\n1. Calculer $F_n$ à la main pour les valeurs de $n$ allant de 2 jusqu'à 5.\n2. Recopier et compléter le code de la fonction `fibo_iter` qui retourne $F_n$ en utilisant un algorithme itératif.\n\n    ````python\n    def fibo_iter(n: int) -> int:\n        \"\"\"Suite de Fibonacci, version itérative\"\"\"\n        if n == 0:\n            return 0\n        else:\n            f0, f1 = 0, 1\n            for k in range(1, n):\n                f0, f1 = ...  # Ligne à compléter ...\n            return f1\n\n\n    for k in range(10):\n        print(fibo_iter(k))\n    ````\n\n3. Évaluer la complexité en termes de nombre d'additions.\n4. D'après la définition de la suite, on a, pour tout entier naturel $n\\geqslant 2$ : \n    \n    $$F_{n}=F_{n-2}+F_{n-1}$$\n    \n    En déduire une version **récursive** de l'algorithme de calcul de $F_n$. Cet algorithme a ceci de particulier que chaque fonction procède à **deux** appels récursifs. On pourra recopier et compléter le code ci-dessous.\n\n    ````python\n    def fibo_rec(n: int) -> int:\n        \"\"\"Suite de Fibonacci version récursive\"\"\"\n        # Cas de base\n        if ...:\n            return n\n        # Récursion\n        else:\n            return ...\n\n\n    for k in range(10):\n        print(fibo_rec(k))\n    ````\n\n6. Utiliser chacune des deux versions pour calculer la valeur de $F_{50}$. Que constate-t-on ? Expliquer.\n\n::: {.callout-tip collapse=\"true\"}\n## Remarques et compléments\n\nLa version récursive se révèle beaucoup moins efficace. Pour comprendre pourquoi, nous pouvons représenter par un arbre les appels récursifs nécessaires.\n\n![](fibo_mermaid.png)\n\nOn retrouve les cas de base dans les feuilles de l'arbre. Nous pouvons constater que le nombre d'appels récursifs est très grand. Il est possible de démontrer que ce nombre augmente de façon **exponentielle**. Pour calculer $F_{100}$, il y aurait environ $10^{20}$ opérations. À raison de $10^9$ opérations par seconde, la calcul prendra de l'ordre de $10^{11}$ secondes, soit environ 3 000 ans !\n\nUn autre constat qui montre l'inefficacité de ce programme : plusieurs calculs identiques sont répétés plusieurs fois. On calcule par exemple $F_3$ deux fois et $F_2$ trois fois. Une solution meilleure serait de garder en mémoire les éléments déjà calculés et de ne calculer que les nouveaux éléments encore jamais rencontrés. Une telle démarche relève de la **programmation dynamique** qui sera abordée en fin d'année.\n\nPour satisfaire votre curiosité insatiable, vous pouvez déjà observer et tester le programme ci-dessous :\n\n````python\ndef fibo_dyn(n: int, suite: dict = {0: 0, 1: 1}) -> int:\n    \"\"\"Suite de Fibonacci version dynamique\"\"\"\n    # Cas de base\n    if n == 0 or n == 1:\n        return n\n    # Récursion\n    else:\n        # Si Fn est déjà calculé, on le retourne\n        if n in suite.keys():\n            return suite[n]\n        else:\n            # Sinon, on le calcule et on le garde en mémoire\n            f = fibo_dyn(n-2, suite) + fibo_dyn(n-1, suite)\n            suite[n] = f\n            return f\n\n\nfor k in range(10):\n    print(fibo_dyn(k))\n````\n\nUne exécution dans PythonTutor est instructive :\n\n<iframe width=\"800\" height=\"500\" frameborder=\"0\" src=\"https://pythontutor.com/iframe-embed.html#code=def%20fibo_dyn%28n%3A%20int,%20suite%3A%20dict%20%3D%20%7B0%3A%200,%201%3A%201%7D%29%20-%3E%20int%3A%0A%20%20%20%20%22%22%22Suite%20de%20Fibonacci%20version%20dynamique%22%22%22%0A%20%20%20%20%23%20Cas%20de%20base%0A%20%20%20%20if%20n%20%3D%3D%200%20or%20n%20%3D%3D%201%3A%0A%20%20%20%20%20%20%20%20return%20n%0A%20%20%20%20%23%20R%C3%A9cursion%0A%20%20%20%20else%3A%0A%20%20%20%20%20%20%20%20%23%20Si%20Fn%20est%20d%C3%A9j%C3%A0%20calcul%C3%A9,%20on%20le%20retourne%0A%20%20%20%20%20%20%20%20if%20n%20in%20suite.keys%28%29%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20return%20suite%5Bn%5D%0A%20%20%20%20%20%20%20%20else%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20%23%20Sinon,%20on%20le%20calcule%20et%20on%20le%20garde%20en%20m%C3%A9moire%0A%20%20%20%20%20%20%20%20%20%20%20%20print%28%22calcul%20avec%20n%20%3D%22,%20n%29%0A%20%20%20%20%20%20%20%20%20%20%20%20f%20%3D%20fibo_dyn%28n-2,%20suite%29%20%2B%20fibo_dyn%28n-1,%20suite%29%0A%20%20%20%20%20%20%20%20%20%20%20%20suite%5Bn%5D%20%3D%20f%0A%20%20%20%20%20%20%20%20%20%20%20%20return%20f%0A%0A%0Afor%20k%20in%20range%285%29%3A%0A%20%20%20%20print%28fibo_dyn%28k%29%29&codeDivHeight=400&codeDivWidth=350&cumulative=false&curInstr=0&heapPrimitives=nevernest&origin=opt-frontend.js&py=3&rawInputLstJSON=%5B%5D&textReferences=false\"> </iframe>\n\nVoir [cet article du blog](https://www.flallemand.fr/wp/2022/06/05/mesurer-le-temps-dexecution-dun-fragment-de-code/){ target=_blank } qui explique comment visualiser le temps d'exécution d'une fonction.\n:::\n\n\n## {{< fa solid pencil-alt >}} {{< fa desktop >}} Exercice 3 : calcul de $x^n$\n\nPour tout nombre réel $x$ et tout entier naturel $n$, $x^n$ est défini par $x^0=1$ et, pour $n>0$, $x^n=x\\times x\\times x\\times \\ldots \\times x$ : produit de $n$ facteurs tous égaux à $x$.\n\nLes règles de calcul sur les exposants permettent d'affirmer que, pour $n>0$, $x^n=x\\times x^{n-1}$.\n\n1. Écrire la fonction récursive ``puissance(x,n)`` qui calcule le nombre $x^n$  pour tout entier naturel $n$.\n2. Dessiner l'arbre d'appels de cette fonction pour $x=3$ et $n=5$.\n3. Pour les plus rapides\n\n::: {.callout-caution}\n## Question bonus\nUn autre méthode de calcul de $x^n$ consiste à distinguer le cas où $n$ est pair et celui où $n$ est impair :\n\n* si $n=0$, alors $x^n=1$ ;\n* si $n$ est pair, alors $x^n=\\left(x^{n/2}\\right)^2$ ;\n* si $n$ est impair, alors $x^n=x\\times\\left(x^{(n-1)/2}\\right)^2$.\n\nL'algorithme qui découle de cette définition porte également le nom **d'exponentiation rapide**. Comme son nom l'indique, il s'agit d'un algorithme particulièrement efficace pour calculer rapidement de grandes puissances entières.\n\nÉcrire la fonction récursive ``puissancev2(x,n)`` qui calcule le nombre $x^n$ pour tout entier naturel n selon la méthode d'exponentiation rapide.\n:::\n\n\n## {{< fa solid pencil-alt >}} Exercice 4 : maximum d'une liste\n\nOn considère le programme ci-dessous :\n\n````python\ndef maximum(a, b):\n    if a > b:\n        return a\n    else:\n        return b\n\ndef maximum_tab(tab):\n    if len(tab) == 1:\n        return tab[0]\n    else:\n        return maximum(tab[0], maximum_tab(tab[1:]))\n\nfrom random import randint\n\nmon_tab = []\nfor i in range(20):\n    mon_tab.append(randint(-100, 100))\nprint(mon_tab)\nprint(maximum_tab(mon_tab))\n````\n\n1. Décrire, en langage usuel, le principe de fonctionnement de la fonction ``maximum_tab``.\n1. Expliquer en quoi la fonction ``maximum_tab`` est récursive. Quel est le cas de base ?\n2. Prouver la terminaison de cette fonction.\n3. Effectuer par récurrence la preuve de cet algorithme (c'est-à-dire prouver que la fonction retourne bien le maximum du tableau donné en argument).\n4. Dessiner l'arbre d'appels de cette fonction pour l'appel ``maximum_tab([-4,55,-1,-35,-52,31])``.\n\n\n## {{< fa desktop >}} Exercice 5 : palindromes\n\nOn appelle palindrome un mot qui se lit dans les deux sens comme « été » ou « radar ».\n\nÉcrire une fonction récursive ``palindrome`` qui teste si un mot est un palindrome.\n\n* Entrée : Un mot (type ``str``).\n* Sortie : Un booléen égal à ``True`` si le mot est un palindrome, ``False`` sinon.\n\nOn considérera les deux cas suivant comme cas de base :\n\n* si le mot est la chaîne vide, c'est un palindrome ;\n* si le mot ne contient qu'une seule lettre, c'est un palindrome\n\n\n## {{< fa solid pencil-alt >}} {{< fa desktop >}} Exercice 6 : flocon de von Koch\n\nUne image qui a une apparence similaire quelle que soit l'échelle à laquelle on l'observe est appelée une **fractale** (il y a d'autres types de fractales).\n\nUn exemple simple de fractale est le flocon de Von Koch, dont voici une représentation (pour un degré 4).\n\n![Flocon de von Koch](koch.png)\n\nOn peut la créer à partir d'un segment de droite, en modifiant récursivement chaque segment de droite de la façon suivante :\n\n* on divise le segment de droite en trois segments de longueurs égales ;\n* on construit un triangle équilatéral ayant pour base le segment médian de la première étape ;\n* on supprime le segment de droite qui était la base du triangle de la deuxième étape.\n\nVoici le résultat obtenu en une étape :\n\n![Étape de construction](koch_etape.png)\n\nPour continuer, il suffit de considérer chaque segment de cette dernière figure comme segment de départ.\n\n````python\nfrom turtle import *\n\n\ndef Koch(n, d):\n    if n == 0:\n        forward(d)\n    else:\n        Koch(n-1, d/3)\n        left(60)\n        Koch(n-1, d/3)\n        right(120)\n        Koch(n-1, d/3)\n        left(60)\n        Koch(n-1, d/3)\n    return None\n\n\ndef flocon(n, d):\n    for k in range(3):\n        Koch(n, d)\n        right(120)\n    return None\n\n\nflocon(4, 300)\nexitonclick()\n````\n\n1. Identifier le cas de base de la fonction récursive ``Koch(n, d)``. Que fait-il ?\n2. Modifier les paramètres ``n`` et ``d`` lors de l'appel à la fonction ``flocon`` et observer l'impact de ces modifications sur le dessin.\n3. Combien d'appels récursifs sont-ils réalisés lors de l'appel de la fonction ``Koch(4, 300)`` ?\n\n\n\n## {{< fa solid pencil-alt >}} Exercice 7 (type bac)\n\n<iframe src=\"exo_type_bac_recursivite_1.pdf\" width=\"100%\" height=\"500px\"> </iframe>\n","srcMarkdownNoYaml":"\n\n_Les exercices précédés du symbole {{< fa desktop >}} sont à faire sur machine, en sauvegardant le fichier si nécessaire._\n\n_Les exercices précédés du symbole {{< fa solid pencil-alt >}} doivent être résolus par écrit._\n\n::: {.callout-warning}\n## Attention !\nLes exercices suivants comportent également quelques compléments de cours.\n\nLes exemples présentés dans ces exercices sont  des exemples très classiques qu'il faut connaître.\n:::\n\n## {{< fa solid pencil-alt >}} Exercice 1 : factorielle\n\nOn rappelle l'exemple du premier paragraphe du cours concernant le calcul de la factorielle $n!=1\\times 2\\times 3\\times\\ldots\\times n$ d'un entier naturel $n$, dans sa version récursive.\n\n```python\n  def fact(n):\n    \"\"\"Renvoie la factorielle de n (méthode récursive).\"\"\"\n    if n == 0:\n      res = 1\n    else:\n      res = n*fact(n-1)\n    return res\n```\n\n1. Dans cette fonction, quel est le cas de base ?\n2. Démontrer que l'algorithme se termine (**preuve de terminaison**) dès lors que l'argument $n$ donné initialement est un entier naturel.\n3. Que se passe-t-il si on appelle la fonction `fact` avec $n=-2$ ? Proposer une modification de la fonction pour traiter ce type de cas.\n3. Pour démontrer que cet algorithme renvoie bien $n!$ lorsque $n$ est un entier naturel, on peut procéder par un **raisonnement par récurrence**.\n    \n    * *Cas de base* : pour $n=0$, la fonction renvoie-t-elle $0!$ ?\n    * *Hypothèse* : on suppose que, pour une certaine valeur de l'entier naturel non nul $n$, `fact(n-1)` renvoie $(n-1)!$. Montrer que, sous cette hypothèse, `fac(n)` renvoie bien $n!$.\n    * *Conclusion* : en déduire que `fac(n)` renvoie $n!$ pour tout entier naturel $n$.\n\n4. Pour évaluer la **complexité** de cet algorithme, nous allons compter le nombre de multiplications et de comparaisons effectuées. Démontrer, à l'aide d'un raisonnement pas récurrence, que la complexité de cet algorithme est en $\\mathcal{O}(n)$.\n\n::: {.callout-note}\n## À retenir ...\n* Le principe de la preuve de terminaison.\n* Le principe du raisonnement pas récurrence\n:::\n\n\n## {{< fa solid pencil-alt >}} {{< fa desktop >}} Exercice 2 : suite de Fibonacci\n\nLa suite de Fibonacci est une suite de nombres entiers notés $F_n$, définie par $F_0=0$, $F_1=1$ et dans laquelle chaque terme est égal à la somme des deux termes qui le précèdent.\n\n1. Calculer $F_n$ à la main pour les valeurs de $n$ allant de 2 jusqu'à 5.\n2. Recopier et compléter le code de la fonction `fibo_iter` qui retourne $F_n$ en utilisant un algorithme itératif.\n\n    ````python\n    def fibo_iter(n: int) -> int:\n        \"\"\"Suite de Fibonacci, version itérative\"\"\"\n        if n == 0:\n            return 0\n        else:\n            f0, f1 = 0, 1\n            for k in range(1, n):\n                f0, f1 = ...  # Ligne à compléter ...\n            return f1\n\n\n    for k in range(10):\n        print(fibo_iter(k))\n    ````\n\n3. Évaluer la complexité en termes de nombre d'additions.\n4. D'après la définition de la suite, on a, pour tout entier naturel $n\\geqslant 2$ : \n    \n    $$F_{n}=F_{n-2}+F_{n-1}$$\n    \n    En déduire une version **récursive** de l'algorithme de calcul de $F_n$. Cet algorithme a ceci de particulier que chaque fonction procède à **deux** appels récursifs. On pourra recopier et compléter le code ci-dessous.\n\n    ````python\n    def fibo_rec(n: int) -> int:\n        \"\"\"Suite de Fibonacci version récursive\"\"\"\n        # Cas de base\n        if ...:\n            return n\n        # Récursion\n        else:\n            return ...\n\n\n    for k in range(10):\n        print(fibo_rec(k))\n    ````\n\n6. Utiliser chacune des deux versions pour calculer la valeur de $F_{50}$. Que constate-t-on ? Expliquer.\n\n::: {.callout-tip collapse=\"true\"}\n## Remarques et compléments\n\nLa version récursive se révèle beaucoup moins efficace. Pour comprendre pourquoi, nous pouvons représenter par un arbre les appels récursifs nécessaires.\n\n![](fibo_mermaid.png)\n\nOn retrouve les cas de base dans les feuilles de l'arbre. Nous pouvons constater que le nombre d'appels récursifs est très grand. Il est possible de démontrer que ce nombre augmente de façon **exponentielle**. Pour calculer $F_{100}$, il y aurait environ $10^{20}$ opérations. À raison de $10^9$ opérations par seconde, la calcul prendra de l'ordre de $10^{11}$ secondes, soit environ 3 000 ans !\n\nUn autre constat qui montre l'inefficacité de ce programme : plusieurs calculs identiques sont répétés plusieurs fois. On calcule par exemple $F_3$ deux fois et $F_2$ trois fois. Une solution meilleure serait de garder en mémoire les éléments déjà calculés et de ne calculer que les nouveaux éléments encore jamais rencontrés. Une telle démarche relève de la **programmation dynamique** qui sera abordée en fin d'année.\n\nPour satisfaire votre curiosité insatiable, vous pouvez déjà observer et tester le programme ci-dessous :\n\n````python\ndef fibo_dyn(n: int, suite: dict = {0: 0, 1: 1}) -> int:\n    \"\"\"Suite de Fibonacci version dynamique\"\"\"\n    # Cas de base\n    if n == 0 or n == 1:\n        return n\n    # Récursion\n    else:\n        # Si Fn est déjà calculé, on le retourne\n        if n in suite.keys():\n            return suite[n]\n        else:\n            # Sinon, on le calcule et on le garde en mémoire\n            f = fibo_dyn(n-2, suite) + fibo_dyn(n-1, suite)\n            suite[n] = f\n            return f\n\n\nfor k in range(10):\n    print(fibo_dyn(k))\n````\n\nUne exécution dans PythonTutor est instructive :\n\n<iframe width=\"800\" height=\"500\" frameborder=\"0\" src=\"https://pythontutor.com/iframe-embed.html#code=def%20fibo_dyn%28n%3A%20int,%20suite%3A%20dict%20%3D%20%7B0%3A%200,%201%3A%201%7D%29%20-%3E%20int%3A%0A%20%20%20%20%22%22%22Suite%20de%20Fibonacci%20version%20dynamique%22%22%22%0A%20%20%20%20%23%20Cas%20de%20base%0A%20%20%20%20if%20n%20%3D%3D%200%20or%20n%20%3D%3D%201%3A%0A%20%20%20%20%20%20%20%20return%20n%0A%20%20%20%20%23%20R%C3%A9cursion%0A%20%20%20%20else%3A%0A%20%20%20%20%20%20%20%20%23%20Si%20Fn%20est%20d%C3%A9j%C3%A0%20calcul%C3%A9,%20on%20le%20retourne%0A%20%20%20%20%20%20%20%20if%20n%20in%20suite.keys%28%29%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20return%20suite%5Bn%5D%0A%20%20%20%20%20%20%20%20else%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20%23%20Sinon,%20on%20le%20calcule%20et%20on%20le%20garde%20en%20m%C3%A9moire%0A%20%20%20%20%20%20%20%20%20%20%20%20print%28%22calcul%20avec%20n%20%3D%22,%20n%29%0A%20%20%20%20%20%20%20%20%20%20%20%20f%20%3D%20fibo_dyn%28n-2,%20suite%29%20%2B%20fibo_dyn%28n-1,%20suite%29%0A%20%20%20%20%20%20%20%20%20%20%20%20suite%5Bn%5D%20%3D%20f%0A%20%20%20%20%20%20%20%20%20%20%20%20return%20f%0A%0A%0Afor%20k%20in%20range%285%29%3A%0A%20%20%20%20print%28fibo_dyn%28k%29%29&codeDivHeight=400&codeDivWidth=350&cumulative=false&curInstr=0&heapPrimitives=nevernest&origin=opt-frontend.js&py=3&rawInputLstJSON=%5B%5D&textReferences=false\"> </iframe>\n\nVoir [cet article du blog](https://www.flallemand.fr/wp/2022/06/05/mesurer-le-temps-dexecution-dun-fragment-de-code/){ target=_blank } qui explique comment visualiser le temps d'exécution d'une fonction.\n:::\n\n\n## {{< fa solid pencil-alt >}} {{< fa desktop >}} Exercice 3 : calcul de $x^n$\n\nPour tout nombre réel $x$ et tout entier naturel $n$, $x^n$ est défini par $x^0=1$ et, pour $n>0$, $x^n=x\\times x\\times x\\times \\ldots \\times x$ : produit de $n$ facteurs tous égaux à $x$.\n\nLes règles de calcul sur les exposants permettent d'affirmer que, pour $n>0$, $x^n=x\\times x^{n-1}$.\n\n1. Écrire la fonction récursive ``puissance(x,n)`` qui calcule le nombre $x^n$  pour tout entier naturel $n$.\n2. Dessiner l'arbre d'appels de cette fonction pour $x=3$ et $n=5$.\n3. Pour les plus rapides\n\n::: {.callout-caution}\n## Question bonus\nUn autre méthode de calcul de $x^n$ consiste à distinguer le cas où $n$ est pair et celui où $n$ est impair :\n\n* si $n=0$, alors $x^n=1$ ;\n* si $n$ est pair, alors $x^n=\\left(x^{n/2}\\right)^2$ ;\n* si $n$ est impair, alors $x^n=x\\times\\left(x^{(n-1)/2}\\right)^2$.\n\nL'algorithme qui découle de cette définition porte également le nom **d'exponentiation rapide**. Comme son nom l'indique, il s'agit d'un algorithme particulièrement efficace pour calculer rapidement de grandes puissances entières.\n\nÉcrire la fonction récursive ``puissancev2(x,n)`` qui calcule le nombre $x^n$ pour tout entier naturel n selon la méthode d'exponentiation rapide.\n:::\n\n\n## {{< fa solid pencil-alt >}} Exercice 4 : maximum d'une liste\n\nOn considère le programme ci-dessous :\n\n````python\ndef maximum(a, b):\n    if a > b:\n        return a\n    else:\n        return b\n\ndef maximum_tab(tab):\n    if len(tab) == 1:\n        return tab[0]\n    else:\n        return maximum(tab[0], maximum_tab(tab[1:]))\n\nfrom random import randint\n\nmon_tab = []\nfor i in range(20):\n    mon_tab.append(randint(-100, 100))\nprint(mon_tab)\nprint(maximum_tab(mon_tab))\n````\n\n1. Décrire, en langage usuel, le principe de fonctionnement de la fonction ``maximum_tab``.\n1. Expliquer en quoi la fonction ``maximum_tab`` est récursive. Quel est le cas de base ?\n2. Prouver la terminaison de cette fonction.\n3. Effectuer par récurrence la preuve de cet algorithme (c'est-à-dire prouver que la fonction retourne bien le maximum du tableau donné en argument).\n4. Dessiner l'arbre d'appels de cette fonction pour l'appel ``maximum_tab([-4,55,-1,-35,-52,31])``.\n\n\n## {{< fa desktop >}} Exercice 5 : palindromes\n\nOn appelle palindrome un mot qui se lit dans les deux sens comme « été » ou « radar ».\n\nÉcrire une fonction récursive ``palindrome`` qui teste si un mot est un palindrome.\n\n* Entrée : Un mot (type ``str``).\n* Sortie : Un booléen égal à ``True`` si le mot est un palindrome, ``False`` sinon.\n\nOn considérera les deux cas suivant comme cas de base :\n\n* si le mot est la chaîne vide, c'est un palindrome ;\n* si le mot ne contient qu'une seule lettre, c'est un palindrome\n\n\n## {{< fa solid pencil-alt >}} {{< fa desktop >}} Exercice 6 : flocon de von Koch\n\nUne image qui a une apparence similaire quelle que soit l'échelle à laquelle on l'observe est appelée une **fractale** (il y a d'autres types de fractales).\n\nUn exemple simple de fractale est le flocon de Von Koch, dont voici une représentation (pour un degré 4).\n\n![Flocon de von Koch](koch.png)\n\nOn peut la créer à partir d'un segment de droite, en modifiant récursivement chaque segment de droite de la façon suivante :\n\n* on divise le segment de droite en trois segments de longueurs égales ;\n* on construit un triangle équilatéral ayant pour base le segment médian de la première étape ;\n* on supprime le segment de droite qui était la base du triangle de la deuxième étape.\n\nVoici le résultat obtenu en une étape :\n\n![Étape de construction](koch_etape.png)\n\nPour continuer, il suffit de considérer chaque segment de cette dernière figure comme segment de départ.\n\n````python\nfrom turtle import *\n\n\ndef Koch(n, d):\n    if n == 0:\n        forward(d)\n    else:\n        Koch(n-1, d/3)\n        left(60)\n        Koch(n-1, d/3)\n        right(120)\n        Koch(n-1, d/3)\n        left(60)\n        Koch(n-1, d/3)\n    return None\n\n\ndef flocon(n, d):\n    for k in range(3):\n        Koch(n, d)\n        right(120)\n    return None\n\n\nflocon(4, 300)\nexitonclick()\n````\n\n1. Identifier le cas de base de la fonction récursive ``Koch(n, d)``. Que fait-il ?\n2. Modifier les paramètres ``n`` et ``d`` lors de l'appel à la fonction ``flocon`` et observer l'impact de ces modifications sur le dessin.\n3. Combien d'appels récursifs sont-ils réalisés lors de l'appel de la fonction ``Koch(4, 300)`` ?\n\n\n\n## {{< fa solid pencil-alt >}} Exercice 7 (type bac)\n\n<iframe src=\"exo_type_bac_recursivite_1.pdf\" width=\"100%\" height=\"500px\"> </iframe>\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":true,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":[true,"pdf","tex"]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../styles.css"],"toc":true,"filters":["lightbox"],"output-file":"recursivite_exercices.html"},"language":{"toc-title-document":"Table des matières","toc-title-website":"Sur cette page","related-formats-title":"Autres formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"La source","section-title-abstract":"Résumé","section-title-appendices":"Annexes","section-title-footnotes":"Notes de bas de page","section-title-references":"Les références","section-title-reuse":"Réutilisation","section-title-copyright":"Droits d'auteur","section-title-citation":"Citation","appendix-attribution-cite-as":"Veuillez citer ce travail comme suit :","appendix-attribution-bibtex":"BibTeX","title-block-author-single":"Auteur·rice","title-block-author-plural":"Auteur·rice·s","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Date de publication","title-block-modified":"Modifié","callout-tip-title":"Astuce","callout-note-title":"Note","callout-warning-title":"Avertissement","callout-important-title":"Important","callout-caution-title":"Mise en garde","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Montrer tout le code","code-tools-hide-all-code":"Cacher tout le code","code-tools-view-source":"Voir les sources","code-tools-source-code":"Code source","code-line":"Ligne","code-lines":"Lignes","copy-button-tooltip":"Copier vers le presse-papier","copy-button-tooltip-success":"Copié","repo-action-links-edit":"Modifier cette page","repo-action-links-source":"Voir la source","repo-action-links-issue":"Faire part d'un problème","back-to-top":"Retour au sommet","search-no-results-text":"Pas de résultats","search-matching-documents-text":"documents trouvés","search-copy-link-title":"Copier le lien vers la recherche","search-hide-matches-text":"Cacher les correspondances additionnelles","search-more-match-text":"correspondance de plus dans ce document","search-more-matches-text":"correspondances de plus dans ce document","search-clear-button-title":"Effacer","search-detached-cancel-button-title":"Annuler","search-submit-button-title":"Envoyer","search":"Recherche","toggle-section":"Basculer la section","toggle-sidebar":"Basculer la barre latérale","toggle-dark-mode":"Basculer le mode sombre","toggle-reader-mode":"Basculer en mode lecteur","toggle-navigation":"Basculer la navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Théorème","crossref-lem-title":"Lemme","crossref-cor-title":"Corollaire","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Définition","crossref-exm-title":"Exemple","crossref-exr-title":"Exercice","crossref-ch-prefix":"Chapitre","crossref-apx-prefix":"Annexe","crossref-sec-prefix":"Section","crossref-eq-prefix":"Équation","crossref-lof-title":"Liste des Figures","crossref-lot-title":"Liste des Tables","crossref-lol-title":"Liste des Listings","environment-proof-title":"Preuve","environment-remark-title":"Remarque","environment-solution-title":"Solution","listing-page-order-by":"Trier par","listing-page-order-by-default":"Ordre par défaut","listing-page-order-by-date-asc":"Le plus ancien","listing-page-order-by-date-desc":"Le plus récent","listing-page-order-by-number-desc":"Descendant","listing-page-order-by-number-asc":"Ascendant","listing-page-field-date":"Date","listing-page-field-title":"Titre","listing-page-field-description":"Description","listing-page-field-author":"Auteur·rice","listing-page-field-filename":"Nom de fichier","listing-page-field-filemodified":"Modifié","listing-page-field-subtitle":"Sous-titre","listing-page-field-readingtime":"Temps de lecture","listing-page-field-categories":"Catégories","listing-page-minutes-compact":"{0} min.","listing-page-category-all":"Tous","listing-page-no-matches":"Aucun article correspondant"},"metadata":{"lang":"fr","fig-responsive":true,"quarto-version":"1.4.11","bibliography":["../references.bib"],"theme":{"light":["flatly","../theme_light.scss"],"dark":["darkly","../theme_dark.scss"]},"grid":{"sidebar-width":"250px","body-width":"1000px","margin-width":"300px"},"lightbox":"auto","code-block-border-left":"#31BAE9","code-block-bg":true,"title":"Récursivité (Exercices)","subtitle":"S1 - Langages et programmation","tbl-cap-location":"bottom","crossref":{"eq-prefix":"Éq.","tbl-prefix":"Tableau","tbl-title":"Tableau"}},"extensions":{"book":{"multiFile":true}}},"pdf":{"identifier":{"display-name":"PDF","target-format":"pdf","base-format":"pdf"},"execute":{"fig-width":5.5,"fig-height":3.5,"fig-format":"pdf","fig-dpi":300,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"markdown"},"render":{"keep-tex":true,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"pdf","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"format-links":["pdf","tex"]},"pandoc":{"pdf-engine":"xelatex","standalone":true,"variables":{"graphics":true,"tables":true},"default-image-extension":"pdf","to":"pdf","include-in-header":[{"text":"\\usepackage{fancyhdr} \\pagestyle{fancy} \\usepackage{lastpage}"}],"include-before-body":[{"text":"\\lhead{Spécialité NSI} \\rhead{Terminale} \\chead{} \\cfoot{} \\lfoot{Lycée \\'Emile Duclaux} \\rfoot{Page \\thepage/\\pageref{LastPage}} \\renewcommand{\\headrulewidth}{0pt} \\renewcommand{\\footrulewidth}{0pt} \\thispagestyle{fancy} \\vspace{-2cm}"}],"reference-location":"document","output-file":"recursivite_exercices.pdf"},"language":{"toc-title-document":"Table des matières","toc-title-website":"Sur cette page","related-formats-title":"Autres formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"La source","section-title-abstract":"Résumé","section-title-appendices":"Annexes","section-title-footnotes":"Notes de bas de page","section-title-references":"Les références","section-title-reuse":"Réutilisation","section-title-copyright":"Droits d'auteur","section-title-citation":"Citation","appendix-attribution-cite-as":"Veuillez citer ce travail comme suit :","appendix-attribution-bibtex":"BibTeX","title-block-author-single":"Auteur·rice","title-block-author-plural":"Auteur·rice·s","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Date de publication","title-block-modified":"Modifié","callout-tip-title":"Astuce","callout-note-title":"Note","callout-warning-title":"Avertissement","callout-important-title":"Important","callout-caution-title":"Mise en garde","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Montrer tout le code","code-tools-hide-all-code":"Cacher tout le code","code-tools-view-source":"Voir les sources","code-tools-source-code":"Code source","code-line":"Ligne","code-lines":"Lignes","copy-button-tooltip":"Copier vers le presse-papier","copy-button-tooltip-success":"Copié","repo-action-links-edit":"Modifier cette page","repo-action-links-source":"Voir la source","repo-action-links-issue":"Faire part d'un problème","back-to-top":"Retour au sommet","search-no-results-text":"Pas de résultats","search-matching-documents-text":"documents trouvés","search-copy-link-title":"Copier le lien vers la recherche","search-hide-matches-text":"Cacher les correspondances additionnelles","search-more-match-text":"correspondance de plus dans ce document","search-more-matches-text":"correspondances de plus dans ce document","search-clear-button-title":"Effacer","search-detached-cancel-button-title":"Annuler","search-submit-button-title":"Envoyer","search":"Recherche","toggle-section":"Basculer la section","toggle-sidebar":"Basculer la barre latérale","toggle-dark-mode":"Basculer le mode sombre","toggle-reader-mode":"Basculer en mode lecteur","toggle-navigation":"Basculer la navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Théorème","crossref-lem-title":"Lemme","crossref-cor-title":"Corollaire","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Définition","crossref-exm-title":"Exemple","crossref-exr-title":"Exercice","crossref-ch-prefix":"Chapitre","crossref-apx-prefix":"Annexe","crossref-sec-prefix":"Section","crossref-eq-prefix":"Équation","crossref-lof-title":"Liste des Figures","crossref-lot-title":"Liste des Tables","crossref-lol-title":"Liste des Listings","environment-proof-title":"Preuve","environment-remark-title":"Remarque","environment-solution-title":"Solution","listing-page-order-by":"Trier par","listing-page-order-by-default":"Ordre par défaut","listing-page-order-by-date-asc":"Le plus ancien","listing-page-order-by-date-desc":"Le plus récent","listing-page-order-by-number-desc":"Descendant","listing-page-order-by-number-asc":"Ascendant","listing-page-field-date":"Date","listing-page-field-title":"Titre","listing-page-field-description":"Description","listing-page-field-author":"Auteur·rice","listing-page-field-filename":"Nom de fichier","listing-page-field-filemodified":"Modifié","listing-page-field-subtitle":"Sous-titre","listing-page-field-readingtime":"Temps de lecture","listing-page-field-categories":"Catégories","listing-page-minutes-compact":"{0} min.","listing-page-category-all":"Tous","listing-page-no-matches":"Aucun article correspondant"},"metadata":{"block-headings":true,"bibliography":["../references.bib"],"title":"Récursivité (Exercices)","subtitle":"S1 - Langages et programmation","lang":"fr","tbl-cap-location":"bottom","crossref":{"eq-prefix":"Éq.","tbl-prefix":"Tableau","tbl-title":"Tableau"},"geometry":["top=20mm","bottom=20mm","left=20mm","right=20mm","heightrounded"],"biblio-title":"Sources utilisées"},"extensions":{"book":{"selfContainedOutput":true}}}},"projectFormats":["html"]}