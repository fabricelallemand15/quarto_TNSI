{"title":"Paradigmes de programmation (Cours)","markdown":{"yaml":{"title":"Paradigmes de programmation (Cours)","subtitle":"S1 - Langages et programmation","lang":"fr","tbl-cap-location":"bottom","crossref":{"eq-prefix":"Éq.","tbl-prefix":"Tableau","tbl-title":"Tableau"},"format":{"html":"default","pdf":{"geometry":["top=20mm","bottom=20mm","left=20mm","right=20mm","heightrounded"],"include-in-header":[{"text":"\\usepackage{fancyhdr} \\pagestyle{fancy} \\usepackage{lastpage}"}],"include-before-body":[{"text":"\\lhead{Spécialité NSI} \\rhead{Terminale} \\chead{} \\cfoot{} \\lfoot{Lycée \\'Emile Duclaux} \\rfoot{Page \\thepage/\\pageref{LastPage}} \\renewcommand{\\headrulewidth}{0pt} \\renewcommand{\\footrulewidth}{0pt} \\thispagestyle{fancy} \\vspace{-2cm}"}],"biblio-title":"Sources utilisées","reference-location":"document","keep-tex":true}},"format-links":["pdf","tex"]},"headingText":"Introduction et définition","containsRefs":false,"markdown":"\n\n\nTout d'abord, nous pouvons nous demander ce que signifie le mot **paradigme**. Parmi les trois définitions fournies par le [dictionnaire Le Robert](https://dictionnaire.lerobert.com/definition/paradigme){ target=_blank }, celle qui nous intéresse est la suivante : \n\n:::{.callout-note}\n## Définition\n\n**Paradigme**\n: Modèle de pensée.\n:::\n\nEn programmation, un paradigme est donc une manière de penser un programme, une méthode de programmation.\n\nUn programme est un texte, avec ses conventions d'écriture. Il s'agit bien d'un langage écrit, au sens commun, mais il doit toujours avoir un sens **univoque** et non contextuel. \n\nIl faut que la formulation textuelle d'un programme soit :\n\n* suffisamment proche d'un code réel, conforme à une famille d'ordinateurs particuliers ;\n* standardisée et générale pour permettre une adaptation immédiate et automatique — on parle de « portabilité » — à d'autres contextes similaires ;\n* parfaitement univoque, non ambiguë, puisque destinée à un traitement automatique ;\n* intelligible par un être humain.\n\nVu le grand nombre de langages existants, une classification s'est fait jour. On regroupe en général les langages en « familles » selon le paradigme de programmation auquel ils sont (le mieux) adaptés.\n\nConformément au programme, nous allons définir les paradigmes **impératif**, **fonctionnel** et **objet**.\n\nNotons tout d'abord que la plupart des langages de programmation modernes sont **multiparadigmes** : ils permettent de programmer aussi bien de façon impérative, fonctionnelle qu'avec des objets.\n\n## Paradigme impératif\n\nLa programmation **impérative** est la méthode de programmation que vous avez le plus couramment utilisée jusqu'à présent.\n\nIl s'agit d'un paradigme de programmation qui décrit les opérations en séquences d'instructions exécutées par l'ordinateur pour modifier l'état du programme.\n\nLa programmation impérative se concentre sur la description du fonctionnement d'un programme.\n\nLa plupart des langages de haut niveau comporte cinq types d'instructions principales :\n\n* la séquence d'instructions\n* l'assignation ou affectation\n* l'instruction conditionnelle (if, else)\n* la boucle (for, while)\n* les branchements.\n\nCe type de programmation est le plus ancien et utilisé, il est facile à comprendre, souvent efficace, car proche des instructions réalisées par les processeurs. Par contre, il est assez difficile à tester, car l'état du programme ne cesse de changer et il est difficile de tester une petite partie du programme au milieu de son exécution par exemple, car elle nécessite que toutes les instructions précédentes aient déjà été appliquées correctement.\n\nLes langages C, C++, Java, JavaScript, Python et beaucoup d'autres permettent la programmation impérative.\n\n## Paradigme fonctionnel\n\n### Introduction\n\nLe paradigme fonctionnel est un paradigme de programmation qui reprend les principes du lambda-calcul introduit par [Alonzo Church](https://fr.wikipedia.org/wiki/Alonzo_Church) dans les années 1930.\n\nL'idée fondamentale du lambda-calcul est de considérer que les fonctions sont des données comme les autres. Ainsi, elles peuvent être par exemple passées en paramètre à d'autres fonctions.\n\nD'autres principes découlent également de la thèse de Church :\n\n* les fonctions sont des fonctions au sens mathématique du terme : elles se contentent de renvoyer une valeur en fonction de leurs arguments ;\n* il n'y a pas de notion « d'état », ni à l'extérieur des fonctions, ni dans les fonctions. Un programme n'est donc qu'une composition de fonctions.\n\nLe paradigme fonctionnel a d'abord été implanté au sein de langages dédiés, plus ou moins « purement fonctionnel ». Parmi les langages dits fonctionnels, on peut citer :\n\n* LISP (List Processing) : 1958 ;\n* SML (Standard Meta Language) : 1983 ;\n* CAML (Categorical Abstract Machine Language) : 1987, puis son extension objet OCAML ;\n* Haskell : 1990 ;\n* Clojure : 2007.\n\nMais certains aspects du paradigme fonctionnel ont fini par être intégrés dans des langages impératifs, car ils présentent certains avantages :\n\n* fonctions pures ;\n* fonctions d'ordre supérieur ;\n* lambda-expressions ;\n* évaluation paresseuse.\n\nEn programmation fonctionnelle, les variables sont toujours constantes : une fois qu'elles ont été affectées, leur valeur ne doit plus changer ; de plus les boucles sont remplacées par des appels récursifs.\n\n### Mise en œuvre en Python\n\n#### Fonctions pures\n\nUne fonction pure est une fonction qui ne modifie rien ; elle ne fait que renvoyer des valeurs en fonction de ses paramètres. Et les valeurs renvoyées ne doivent dépendre que de ses paramètres, et pas de variables extérieures à la fonction.\n\nLes modifications qu'une fonction peut effectuer sur l'état du système sont appelées **effets de bord**. Un affichage à l'écran est un exemple d'effet de bord.\n\nEn Python, rien n'impose d'implémenter des fonctions pures. Notamment, étant donné la façon dont les arguments sont passés à une fonction en Python (utilisation d'une copie de la référence initiale), rien n'interdit qu'une fonction modifie l'objet référencé par l'un de ses paramètres.\n\nVoici un tel exemple :\n\n````py\ndef retirer_dernier(liste) :\n    liste.pop()\n````\n\nOn utilise cette fonction ainsi :\n\n````python\n>>> ma_liste = [1, 2, 3]\n>>> retirer_dernier(ma_liste)\n````\n\nL'inconvénient de ce type de fonction est qu'elle modifie la variable `ma_liste` qui, à l'issue de l'exécution des deux lignes précédentes contient `[1, 2]`. Cela peut rendre le code plus difficile à comprendre et générer des comportements inattendus. Une fonction pure, au contraire, doit renvoyer la valeur calculée sans modifier ses paramètres. Ainsi, on peut réécrire le traitement précédent de la façon suivante :\n\n````py\ndef retirer_dernier_pure(liste) :\n    retour = liste[:]\n    retour.pop()\n    return retour\n````\n\nCette fonction s'utilise ainsi :\n\n````python\n>>> l1 = [1, 2, 3]\n>>> l2 = retirer_dernier_pure(l1)\n````\n\nDans ce dernier cas, le fait que l'appel à ``retirer_dernier_pure`` ne modifie par ``l1`` est bien plus intuitif.\n\n:::{.callout-important}\n## À retenir\n\nPour faciliter l'écriture de fonctions pures en Python, on peut :\n\n* utiliser au maximum des données non mutables (tuples plutôt que listes par exemple) ;\n* copier systématiquement au début des fonctions les paramètres référençant des données mutables et utiliser ces copies dans la fonction.\n* on veille à ne pas modifier de valeur existante, mais plutôt à créer une nouvelle valeur à partir de la valeur existante.\n:::\n\nEssayer de n'écrire que des fonctions pures permet de limiter les risques de bugs et facilite la relecture des programmes. Il s'agit donc d'un style de programmation à privilégier.\n\n### Fonctions d'ordre supérieur\n\nLes fonctions étant considérées comme des données comme les autres, il est possible de définir des fonctions dont les arguments sont d'autres fonctions. On parle alors de **fonctions d'ordre supérieur**.\n\nPython fournit des fonctions d'ordre supérieur dans sa bibliothèque standard. Voyons par exemple la fonction `map` qui permet d'appliquer une fonction à tous les éléments d'une liste. Quelques remarques et explications s'imposent :\n\n* `map` peut s'appliquer à tout objet _itérable_, donc aux chaînes de caractères, aux tuples, aux listes.\n* `map` retourne un objet itérable : les valeurs résultat ne sont pas toutes calculées par avance, elles le seront à la demande. Cet itérable peut être transformé en liste en tapant `list(map(...))` ou être utilisé dans une boucle `for item in map(...):`. Ce calcul des valeurs à la demande est une mise en œuvre du principe de l'**évaluation paresseuse** caractéristique de la programmation fonctionnelle.\n\nConsidérons le programme suivant :\n\n````py\ndef carre(x):\n    return x**2\n\n\ndef capit(ch):\n    return ch.capitalize()\n\n\nma_str = \"azerty\"\nmon_tuple = (1, 2, 3, 4, 5)\nma_liste = [1, 2, 3, 4, 5]\n\niter1 = map(capit, ma_str)\niter2 = map(carre, mon_tuple)\niter3 = map(carre, ma_liste)\n\nfor car in iter1:\n    print(car, end=\"\")\nprint()\nprint(tuple(iter2))\nprint(list(iter3))\n````\n\nOn obtient en sortie : \n\n````python\nAZERTY\n(1, 4, 9, 16, 25)\n[1, 4, 9, 16, 25]\n````\n\n:::{.callout-warning}\n## Remarque\n\nLe programme ci-dessus est donné pour illustrer l'idée de fonction d'ordre supérieur, mais il n'est pas rédigé, notamment sa partie itérative, dans l'esprit de la programmation fonctionnelle !\n:::\n\nLes langages OCamL, Haskell, F#, Rust par exemple sont des langages fonctionnels.\n\n## Paradigme objet\n\nLa POO consiste en la définition et l'interaction de briques logicielles appelées objets; un objet représente un concept, une idée ou toute entité du monde physique, comme une voiture, une personne ou encore une page d'un livre.\n\nUn objet possède:\n\n* des données: ses **attributs** et\n* des fonctions: ses **méthodes**\n\nLes différents principes de la conception orientée objet aident à la réutilisation du code, au masquage des données, etc. Les bases de la POO sont détaillées dans le [cours précédent](POO_cours.qmd), avec ses [compléments](POO_complements.qmd).\n\n## À quel paradigme se vouer ?\n\nComment choisir entre les différents paradigmes existants ?\n\nIl est important de bien comprendre qu'un programmeur doit maitriser plusieurs paradigmes de programmation (impératif, objet ou encore fonctionnelle). En effet, il sera plus facile d'utiliser le paradigme objet dans certains cas alors que dans d'autres situations, l'utilisation du paradigme fonctionnel sera préférable. Être capable de choisir le \"bon\" paradigme en fonction des situations fait partie du bagage de tout bon programmeur.\n\nIl est aussi important de bien comprendre que la frontière entre ces différents paradigmes est parfois floue, par exemple on utilise très souvent de l'impératif en programmation orientée objet.\n\nDans l'article [Perceiving Python programming paradigms](https://opensource.com/article/19/10/python-programming-paradigms) du site [opensource.com/](https://opensource.com/), les conseils suivants sont donnés :\n\n* Pour simplifier, si votre problème implique une série de manipulations séquentielles simples, suivre le paradigme de programmation impérative de la vieille école serait le moins cher en termes de temps et d'efforts et vous donnerait potentiellement les meilleures performances. \n* Dans le cas de problèmes nécessitant des transformations mathématiques des valeurs, le filtrage des informations, le mappage (transformer une liste en une autre) et les réductions (transformer une liste en une valeur), la programmation fonctionnelle pourrait être adaptée.\n* Si le problème est structuré comme un tas d'objets interdépendants avec certains attributs qui peuvent changer avec le temps, en fonction de certaines conditions, la programmation orientée objet sera certainement la plus naturelle. \n\nBien sûr, il n'y a pas de règle simple, car le choix du paradigme de programmation dépend également fortement du type de données à traiter, des connaissances des programmeurs et de diverses autres choses comme l'évolutivité. \n\nNotons pour finir que cette courte présentation ne recouvre pas tous les paradigmes de programmation existants. On rencontrera notamment l'idée de **programmation événementielle** lors du développement d'interfaces graphiques."},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"markdown"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":true,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":[true,"pdf","tex"]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../styles.css"],"toc":true,"filters":["lightbox"],"output-file":"paradigmes_cours.html"},"language":{},"metadata":{"lang":"fr","fig-responsive":true,"quarto-version":"1.3.208","bibliography":["../references.bib"],"theme":{"light":["flatly","../theme_light.scss"],"dark":["darkly","../theme_dark.scss"]},"grid":{"sidebar-width":"250px","body-width":"1000px","margin-width":"300px"},"lightbox":"auto","code-block-border-left":"#31BAE9","code-block-bg":true,"title":"Paradigmes de programmation (Cours)","subtitle":"S1 - Langages et programmation","tbl-cap-location":"bottom","crossref":{"eq-prefix":"Éq.","tbl-prefix":"Tableau","tbl-title":"Tableau"}},"extensions":{"book":{"multiFile":true}}},"pdf":{"identifier":{"display-name":"PDF","target-format":"pdf","base-format":"pdf"},"execute":{"fig-width":5.5,"fig-height":3.5,"fig-format":"pdf","fig-dpi":300,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"markdown"},"render":{"keep-tex":true,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"pdf","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"format-links":["pdf","tex"]},"pandoc":{"pdf-engine":"xelatex","standalone":true,"variables":{"graphics":true,"tables":true},"default-image-extension":"pdf","to":"pdf","include-in-header":[{"text":"\\usepackage{fancyhdr} \\pagestyle{fancy} \\usepackage{lastpage}"}],"include-before-body":[{"text":"\\lhead{Spécialité NSI} \\rhead{Terminale} \\chead{} \\cfoot{} \\lfoot{Lycée \\'Emile Duclaux} \\rfoot{Page \\thepage/\\pageref{LastPage}} \\renewcommand{\\headrulewidth}{0pt} \\renewcommand{\\footrulewidth}{0pt} \\thispagestyle{fancy} \\vspace{-2cm}"}],"reference-location":"document","output-file":"paradigmes_cours.pdf"},"language":{},"metadata":{"block-headings":true,"bibliography":["../references.bib"],"papersize":"a4","title":"Paradigmes de programmation (Cours)","subtitle":"S1 - Langages et programmation","lang":"fr","tbl-cap-location":"bottom","crossref":{"eq-prefix":"Éq.","tbl-prefix":"Tableau","tbl-title":"Tableau"},"geometry":["top=20mm","bottom=20mm","left=20mm","right=20mm","heightrounded"],"biblio-title":"Sources utilisées"},"extensions":{"book":{"selfContainedOutput":true}}}}}